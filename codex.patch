 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/fortress_director/orchestrator/orchestrator.py b/fortress_director/orchestrator/orchestrator.py
index bcbed353824754570f16aa57eaf8dc7a2ce12bd2..cfee1d190113da19d4e82835f36190b84f0bef50 100644
--- a/fortress_director/orchestrator/orchestrator.py
+++ b/fortress_director/orchestrator/orchestrator.py
@@ -1,39 +1,40 @@
 from __future__ import annotations
 
 import ast
 import json
 import logging
 from copy import deepcopy
 from dataclasses import dataclass
 from pathlib import Path
 from typing import Any, Callable, Dict, List, Optional, Tuple
 
 from fortress_director.codeaware.function_validator import FunctionCallValidator
 from fortress_director.codeaware.rollback_system import RollbackSystem
 from fortress_director.utils.output_validator import validate_turn_output
 from fortress_director.settings import DEFAULT_WORLD_STATE
+from fortress_director.agents.base_agent import AgentError, AgentOutputError
 from fortress_director.agents.character_agent import CharacterAgent
 from fortress_director.agents.event_agent import EventAgent
 from fortress_director.agents.judge_agent import JudgeAgent, check_win_loss
 from fortress_director.agents.world_agent import WorldAgent
 from fortress_director.settings import SETTINGS
 from fortress_director.rules.rules_engine import (
     RulesEngine,
     TierTwoValidationError,
 )
 from fortress_director.codeaware.function_registry import (
     FunctionCall,
     FunctionNotRegisteredError,
     FunctionValidationError,
     SafeFunctionRegistry,
     Validator,
 )
 from fortress_director.utils.glitch_manager import GlitchManager
 from fortress_director.utils.logging_config import configure_logging
 from fortress_director.utils.metrics_manager import MetricManager
 
 configure_logging()
 
 LOGGER = logging.getLogger(__name__)
 
 RELATIONSHIP_SUMMARY_DEFAULT = "No relationship summary available."
@@ -324,164 +325,193 @@ class Orchestrator:
 
             glitch_info = glitch_manager.resolve_turn(
                 metrics=metric_manager,
                 turn=current_turn + 1,
             )
             LOGGER.info(
                 "Glitch resolution outcome: roll=%s, triggered_loss=%s",
                 glitch_info.get("roll"),
                 glitch_info.get("triggered_loss"),
             )
             LOGGER.debug(
                 "Metrics after glitch resolution: %s",
                 metric_manager.snapshot(),
             )
 
             is_final_turn = current_turn >= turn_limit
             world_context = self._build_world_context(state_snapshot)
             LOGGER.info("World context built.")
             LOGGER.debug("World context payload: %s", world_context)
             LOGGER.info(
                 "Starting turn %s in room %s",
                 state_snapshot.get("turn", 0),
                 state_snapshot.get("current_room", "unknown"),
             )
 
+            warnings: List[str] = []
             world_request = {
                 "WORLD_CONTEXT": world_context,
                 "room": state_snapshot.get("current_room", "unknown"),
             }
             LOGGER.debug(
                 "World agent input: %s",
                 self._stringify(world_request),
             )
             LOGGER.info("Calling world_agent.describe...")
-            world_output = self.world_agent.describe(world_request)
-            LOGGER.info("World agent returned output.")
+            try:
+                world_output = self.world_agent.describe(world_request)
+                LOGGER.info("World agent returned output.")
+            except AgentError as exc:
+                fallback_world = self._build_fallback_world_output(state_snapshot)
+                warning = (
+                    "World agent unavailable; using fallback description."
+                )
+                LOGGER.warning("%s (%s)", warning, exc)
+                warnings.append(warning)
+                world_output = fallback_world
             LOGGER.debug(
                 "World agent output: %s",
                 self._stringify(world_output),
             )
 
             recent_motifs_text = (
                 ", ".join(state_snapshot.get("recent_motifs", [])) or "none"
             )
             event_request = {
                 "WORLD_CONTEXT": world_context,
                 "day": state_snapshot.get("day", 1),
                 "time": state_snapshot.get("time", "dawn"),
                 "room": state_snapshot.get("current_room", "unknown"),
                 "recent_events": self._format_recent_events(state_snapshot),
                 "world_constraint_from_prev_turn": json.dumps(
                     state_snapshot.get("world_constraint_from_prev_turn", {})
                 ),
                 "recent_motifs": recent_motifs_text,
                 # lore_continuity_weight: Kaç büyük olay tetiklendi?
                 "lore_continuity_weight": state_snapshot.get("metrics", {}).get(
                     "major_events_triggered", 0
                 ),
             }
             LOGGER.debug(
                 "Event agent input: %s",
                 self._stringify(event_request),
             )
             LOGGER.info("Calling event_agent.generate...")
-            event_output = self.event_agent.generate(event_request)
-            LOGGER.info("Event agent returned output.")
+            try:
+                event_output = self.event_agent.generate(event_request)
+                LOGGER.info("Event agent returned output.")
+            except (AgentError, AgentOutputError) as exc:
+                fallback_event = self._build_fallback_event_output(
+                    state_snapshot,
+                    world_output,
+                )
+                warning = "Event agent unavailable; using scripted fallback scene."
+                LOGGER.warning("%s (%s)", warning, exc)
+                warnings.append(warning)
+                event_output = fallback_event
             LOGGER.debug(
                 "Event agent output: %s",
                 self._stringify(event_output),
             )
 
             LOGGER.info("Resolving player choice...")
             if is_final_turn:
                 event_output["options"] = []
                 chosen_option = {
                     "id": "end",
                     "text": "The campaign concludes.",
                     "action_type": "end",
                 }
             else:
                 chosen_option = self._resolve_player_choice(
                     event_output,
                     player_choice_id,
                 )
             LOGGER.info("Player choice resolved: %s", chosen_option)
             LOGGER.debug(
                 "Player choice resolved: %s",
                 self._stringify(chosen_option),
             )
 
             player_record = state_snapshot.get("player") or {}
             player_inventory = player_record.get("inventory")
             if not isinstance(player_inventory, list):
                 player_inventory = []
             character_request = {
                 "WORLD_CONTEXT": world_context,
                 "scene_short": event_output.get("scene", ""),
                 "player_choice": chosen_option.get("text", ""),
                 "atmosphere": world_output.get("atmosphere", ""),
                 "sensory_details": world_output.get("sensory_details", ""),
                 "char_brief": state_snapshot.get("character_summary", ""),
                 "relationship_summary_from_state": state_snapshot.get(
                     "relationship_summary", ""
                 ),
                 "player_inventory_brief": ", ".join(
                     item for item in player_inventory if isinstance(item, str)
                 ),
             }
             LOGGER.debug(
                 "Character agent input: %s",
                 self._stringify(character_request),
             )
             LOGGER.info("Calling character_agent.react...")
-            character_output = self.character_agent.react(character_request)
-            LOGGER.info("Character agent returned output.")
+            try:
+                character_output = self.character_agent.react(character_request)
+                LOGGER.info("Character agent returned output.")
+            except (AgentError, AgentOutputError) as exc:
+                fallback = self._build_fallback_reaction(
+                    state_snapshot,
+                    chosen_option,
+                )
+                warning = "Character agent unavailable; using defensive fallback."
+                LOGGER.warning("%s (%s)", warning, exc)
+                warnings.append(warning)
+                character_output = [fallback]
             LOGGER.debug(
                 "Character agent output: %s",
                 self._stringify(character_output),
             )
 
             LOGGER.info("Injecting major event effect...")
             major_event_effect = self._inject_major_event_effect(
                 state_snapshot,
                 event_output,
                 character_output,
             )
             LOGGER.info("Major event effect injected.")
             if major_event_effect:
                 LOGGER.debug(
                     "Major event effect applied: %s",
                     self._stringify(major_event_effect),
                 )
             major_event_summary = (
                 self._format_major_event_summary(major_event_effect)
                 if major_event_effect
                 else None
             )
 
-            warnings: List[str] = []
             try:
                 LOGGER.info("Submitting reactions to rules engine...")
                 LOGGER.debug(
                     "Submitting reactions to rules engine: %s",
                     self._stringify(character_output),
                 )
                 state = self.rules_engine.process(
                     state=state_snapshot,
                     character_events=character_output,
                     world_context=world_context,
                     scene=event_output.get("scene", ""),
                     player_choice=chosen_option,
                 )
                 LOGGER.info(
                     "Rules engine accepted updates (turn=%s)",
                     state_snapshot.get("turn", 0) + 1,
                 )
             except TierTwoValidationError as exc:
                 LOGGER.warning("Judge vetoed character updates: %s", exc)
                 warnings.append(str(exc))
                 fallback = self._build_fallback_reaction(
                     state_snapshot,
                     chosen_option,
                 )
                 character_output = [fallback]
@@ -1233,50 +1263,102 @@ class Orchestrator:
         }
 
     def _build_fallback_reaction(
         self,
         state: Dict[str, Any],
         chosen_option: Optional[Dict[str, Any]],
     ) -> Dict[str, Any]:
         npc_name = self._infer_primary_npc_name(state)
         speech_hint = ""
         if isinstance(chosen_option, dict):
             candidate = chosen_option.get("text", "")
             if isinstance(candidate, str):
                 speech_hint = candidate.strip()
         fallback_speech = (
             speech_hint
             or "Holding the line until the storm breaks."
         )[:200]
         return {
             "name": npc_name,
             "intent": "defend",
             "action": "hold_position",
             "speech": fallback_speech,
             "effects": {},
         }
 
+    def _build_fallback_world_output(self, state: Dict[str, Any]) -> Dict[str, str]:
+        constraint = state.get("world_constraint_from_prev_turn", {})
+        atmosphere = constraint.get("atmosphere")
+        if not isinstance(atmosphere, str) or not atmosphere.strip():
+            atmosphere = "Low clouds gather above the fortress walls."
+        sensory = constraint.get("sensory_details")
+        if not isinstance(sensory, str) or not sensory.strip():
+            sensory = "Distant drums and the grit of the wind fill the air."
+        return {
+            "atmosphere": atmosphere.strip(),
+            "sensory_details": sensory.strip(),
+        }
+
+    def _build_fallback_event_output(
+        self,
+        state: Dict[str, Any],
+        world_output: Dict[str, Any],
+    ) -> Dict[str, Any]:
+        location = state.get("current_room", "the battlements")
+        player = state.get("player", {})
+        player_name = player.get("name", "The Shieldbearer")
+        atmosphere = world_output.get("atmosphere", "")
+        scene_parts = [
+            f"{player_name} holds their post within the {location}.",
+        ]
+        if isinstance(atmosphere, str) and atmosphere.strip():
+            scene_parts.append(atmosphere.strip())
+        scene = " ".join(scene_parts)
+        options = [
+            {
+                "id": "fallback_1",
+                "text": "Hold position and study the horizon.",
+                "action_type": "defend",
+            },
+            {
+                "id": "fallback_2",
+                "text": "Signal Rhea to report anything unusual.",
+                "action_type": "npc_interact",
+            },
+            {
+                "id": "fallback_3",
+                "text": "Inspect the nearby defenses for weaknesses.",
+                "action_type": "inspect",
+            },
+        ]
+        return {
+            "scene": scene,
+            "options": options,
+            "major_event": False,
+            "safe_functions": [],
+        }
+
     def _build_world_context(self, state: Dict[str, Any]) -> str:
         """Compose a textual snapshot of the world for prompt consumption."""
 
         player = state.get("player", {})
         inventory = ", ".join(player.get("inventory", [])) or "empty"
         metrics = state.get("metrics", {})
         world_constraint = state.get("world_constraint_from_prev_turn", {})
         motifs = state.get("recent_motifs", [])[-3:]
         recent_motifs = ", ".join(motifs) or "none"
         recent_major = (
             ", ".join(
                 "yes" if flag else "no"
                 for flag in state.get("recent_major_events", [])[-3:]
             )
             or "none"
         )
 
         sections = [
             (
                 "Turn {turn} | Day {day} | Time {time}".format(
                     turn=state.get("turn", 0),
                     day=state.get("day", 1),
                     time=state.get("time", "dawn"),
                 )
             ),
 
EOF
)
