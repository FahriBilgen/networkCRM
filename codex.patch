 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/agents/judge_agent.py b/agents/judge_agent.py
index 43313546df475ca2142cb713203ed67ea585417c..741e29e9d3f7306801c08179d74f84cd14493ae5 100644
--- a/agents/judge_agent.py
+++ b/agents/judge_agent.py
@@ -29,25 +29,66 @@ class JudgeAgent(BaseAgent):
             prompt_template=template,
             model_config=get_model_config("judge"),
             client=client or default_ollama_client("judge"),
         )
 
     def evaluate(self, variables: Dict[str, Any]) -> Dict[str, Any]:
         """Return lore consistency verdict for supplied content. Logs every step."""
         variables = dict(variables)
         variables["tolerance"] = self.tolerance
         self.LOGGER.info("JudgeAgent.evaluate called with variables: %s", variables)
         try:
             result = self.run(variables=variables)
             self.LOGGER.debug("Model returned: %s", result)
             if not isinstance(result, dict):
                 self.LOGGER.error(
                     "Judge agent must return a JSON object, got: %s", result
                 )
                 raise AgentOutputError("Judge agent must return a JSON object")
             self.LOGGER.info("Judge verdict: %s", result)
             return result
         except Exception as exc:
             self.LOGGER.error(
                 "Exception in JudgeAgent.evaluate: %s", exc, exc_info=True
             )
             raise
+
+
+def check_win_loss(
+    metrics: Dict[str, Any],
+    *,
+    turn: int,
+    turn_limit: int,
+) -> Dict[str, str]:
+    """Evaluate win/loss state using supplied metrics."""
+
+    def _as_int(value: Any, default: int = 0) -> int:
+        try:
+            return int(value)
+        except (TypeError, ValueError):
+            return default
+
+    order = _as_int(metrics.get("order"), 0)
+    morale = _as_int(metrics.get("morale"), 0)
+    resources = _as_int(metrics.get("resources"), 0)
+    glitch = _as_int(metrics.get("glitch"), 0)
+
+    status = "ongoing"
+    reason = "thresholds_not_met"
+
+    if order >= 70 and morale >= 70 and glitch <= 30:
+        status = "win"
+        reason = "fortress_stabilized"
+    elif order <= 20:
+        status = "loss"
+        reason = "order_collapse"
+    elif resources <= 0:
+        status = "loss"
+        reason = "resources_depleted"
+    elif glitch >= 85:
+        status = "loss"
+        reason = "glitch_overload"
+    elif turn >= max(1, turn_limit):
+        status = "loss"
+        reason = "turn_limit_reached"
+
+    return {"status": status, "reason": reason}
diff --git a/data/world_state.json b/data/world_state.json
index 9e2d65587b426383b848390b63c9fd4f79b24505..9ec052f575727d283bc82a84ee789aadcdf83e5c 100644
--- a/data/world_state.json
+++ b/data/world_state.json
@@ -1,137 +1,45 @@
 {
-  "turn": 24,
+  "turn": 0,
   "day": 1,
   "time": "dawn",
+  "turn_limit": 30,
+  "rng_seed": 12345,
   "current_room": "lornhaven_wall",
-  "recent_events": [
-    "As the Shieldbearer stands watch, a rustling in the bushes catches their attention. The chill in the air intensifies and the wind picks up, carrying with it the scent of damp earth and decay. Suddenly, a figure emerges from the shadows, cloaked and hooded, standing just beyond the reach of the wall's light.",
-    "As the Shieldbearer stands watch, they notice a figure emerging from the shadows beyond the reach of the wall's light. The chill in the air intensifies and the wind picks up, carrying with it the scent of damp earth and decay. Suddenly, the mysterious figure moves towards the wall, stopping just within the reach of the torchlight. The Shieldbearer tenses, ready to defend Lornhaven if necessary.",
-    "As the mysterious figure approaches, the Shieldbearer stands ready to defend Lornhaven. Suddenly, a gust of wind sweeps through, revealing the figure's hood and showing a face that sends a chill down the Shieldbearer's spine. The figure speaks in a low, menacing voice, 'I am here for the artifact.' The Shieldbearer tenses, ready to fight if necessary.",
-    "The Shieldbearer stands ready, the mysterious figure approaching menacingly. Suddenly, a gust of wind sweeps through, revealing the figure's hood and sending a chill down the Shieldbearer's spine. The figure speaks in a low, menacing voice, 'I am here for the artifact.' The Shieldbearer tenses, ready to fight if necessary.",
-    "The Shieldbearer stands ready, the mysterious figure approaching menacingly. Suddenly, a gust of wind sweeps through, revealing the figure's hood and sending a chill down the Shieldbearer's spine. The figure speaks in a low, menacing voice, 'I am here for the artifact.' The Shieldbearer tenses, ready to fight if necessary."
-  ],
-  "recent_motifs": [
-    "interact",
-    "interact",
-    "combat",
-    "combat",
-    "combat"
-  ],
+  "recent_events": [],
+  "recent_motifs": [],
   "world_constraint_from_prev_turn": {
-    "atmosphere": "stormier",
-    "sensory_details": "The weather shifts subtly."
+    "atmosphere": "low clouds hug the battlements",
+    "sensory_details": "Drums thud beyond the walls while the wind carries grit."
   },
   "player": {
     "name": "The Shieldbearer",
     "inventory": [
       "oil lamp",
       "patched shield"
     ],
     "stats": {
       "resolve": 3,
       "empathy": 2
     },
     "summary": "A weary defender holding the western wall."
   },
   "character_summary": "Rhea is loyal but impulsive; Boris is cautious and calculating.",
   "relationship_summary": "Rhea trusts the player; Boris weighs every trade.",
   "metrics": {
-    "risk_applied_total": 1,
-    "major_flag_set": true,
-    "major_events_triggered": 9,
-    "major_event_last_turn": 23
+    "order": 50,
+    "morale": 50,
+    "resources": 40,
+    "knowledge": 45,
+    "corruption": 10,
+    "glitch": 12,
+    "risk_applied_total": 0,
+    "major_flag_set": false,
+    "major_events_triggered": 0,
+    "major_event_last_turn": null
   },
-  "npc_trust": {
-    "Rhea": 3,
-    "Shieldbearer": 1,
-    "The Shieldbearer": 2
-  },
-  "status_effects": [
-    {
-      "target": "Rhea",
-      "status": "alert",
-      "duration": 0
-    },
-    {
-      "target": "Rhea_investigation",
-      "status": "active",
-      "duration": 0
-    },
-    {
-      "target": "Rhea",
-      "status": "alert",
-      "duration": 10
-    },
-    {
-      "target": "string",
-      "status": "unknown",
-      "duration": 10
-    },
-    {
-      "target": "lornhaven_wall",
-      "status": "active",
-      "duration": 3
-    },
-    {
-      "target": "The Shieldbearer",
-      "status": "tense_watch",
-      "duration": 3
-    },
-    {
-      "target": "The Shieldbearer",
-      "status": "tense_watch",
-      "duration": 3
-    },
-    {
-      "target": "Rhea",
-      "status": "tense_watch",
-      "duration": 3
-    },
-    {
-      "target": "Rhea",
-      "status": "tense_watch",
-      "duration": 3
-    },
-    {
-      "target": "Shieldbearer",
-      "status": "tense_watch",
-      "duration": 3
-    },
-    {
-      "target": "Rhea",
-      "status": "tense_watch",
-      "duration": 3
-    },
-    {
-      "target": "Rhea",
-      "status": "tense_watch",
-      "duration": 3
-    }
-  ],
-  "flags": [
-    "Rhea_investigation",
-    "mystery_figure",
-    "major_mystery_investigation",
-    "atmosphere",
-    "lornhaven_wall_watcher",
-    "sensory_details"
-  ],
-  "items": {
-    "Rhea": [
-      "oil lamp"
-    ],
-    "string": [
-      "string"
-    ],
-    "lornhaven_wall": [
-      "torch"
-    ]
-  },
-  "recent_major_events": [
-    true,
-    true,
-    true,
-    true,
-    true
-  ]
-}
\ No newline at end of file
+  "npc_trust": {},
+  "status_effects": [],
+  "flags": [],
+  "items": {},
+  "recent_major_events": []
+}
diff --git a/fortress_director/agents/judge_agent.py b/fortress_director/agents/judge_agent.py
index 63adc0665bdba5f551b0940f4632fac345a7e444..860d163ac09b6c8b5f836fc51fedef2648848f71 100644
--- a/fortress_director/agents/judge_agent.py
+++ b/fortress_director/agents/judge_agent.py
@@ -30,25 +30,66 @@ class JudgeAgent(BaseAgent):
             prompt_template=template,
             model_config=get_model_config("judge"),
             client=client or default_ollama_client("judge"),
         )
 
     def evaluate(self, variables: Dict[str, Any]) -> Dict[str, Any]:
         """Return lore consistency verdict for supplied content. Logs every step."""
         variables = dict(variables)
         variables["tolerance"] = self.tolerance
         self.LOGGER.info("JudgeAgent.evaluate called with variables: %s", variables)
         try:
             result = self.run(variables=variables)
             self.LOGGER.debug("Model returned: %s", result)
             if not isinstance(result, dict):
                 self.LOGGER.error(
                     "Judge agent must return a JSON object, got: %s", result
                 )
                 raise AgentOutputError("Judge agent must return a JSON object")
             self.LOGGER.info("Judge verdict: %s", result)
             return result
         except Exception as exc:
             self.LOGGER.error(
                 "Exception in JudgeAgent.evaluate: %s", exc, exc_info=True
             )
             raise
+
+
+def check_win_loss(
+    metrics: Dict[str, Any],
+    *,
+    turn: int,
+    turn_limit: int,
+) -> Dict[str, str]:
+    """Evaluate win/loss state using supplied metrics."""
+
+    def _as_int(value: Any, default: int = 0) -> int:
+        try:
+            return int(value)
+        except (TypeError, ValueError):
+            return default
+
+    order = _as_int(metrics.get("order"), 0)
+    morale = _as_int(metrics.get("morale"), 0)
+    resources = _as_int(metrics.get("resources"), 0)
+    glitch = _as_int(metrics.get("glitch"), 0)
+
+    status = "ongoing"
+    reason = "thresholds_not_met"
+
+    if order >= 70 and morale >= 70 and glitch <= 30:
+        status = "win"
+        reason = "fortress_stabilized"
+    elif order <= 20:
+        status = "loss"
+        reason = "order_collapse"
+    elif resources <= 0:
+        status = "loss"
+        reason = "resources_depleted"
+    elif glitch >= 85:
+        status = "loss"
+        reason = "glitch_overload"
+    elif turn >= max(1, turn_limit):
+        status = "loss"
+        reason = "turn_limit_reached"
+
+    return {"status": status, "reason": reason}
diff --git a/fortress_director/data/world_state.json b/fortress_director/data/world_state.json
index 5226bebe6a50fdb2e590360684c6a212eac6cd12..01b99d123c52f62c79ed6b71fbecc884b51a0ed3 100644
--- a/fortress_director/data/world_state.json
+++ b/fortress_director/data/world_state.json
@@ -1,48 +1,57 @@
 {
   "campaign_id": "default_campaign",
   "turn_limit": 10,
-  "current_turn": 1,
+  "current_turn": 0,
+  "rng_seed": 12345,
   "scores": {
     "logic_score": 0,
     "emotion_score": 0,
     "corruption": 0
   },
   "flags": [],
   "memory_layers": [],
   "active_layer": null,
   "npc_fragments": {},
   "inventory": [],
   "lore": {},
-  "turn": 1,
+  "turn": 0,
   "day": 1,
   "time": "dawn",
   "current_room": "entrance",
   "recent_events": [],
   "recent_motifs": [],
-  "world_constraint_from_prev_turn": {},
+  "world_constraint_from_prev_turn": {
+    "atmosphere": "low clouds hug the battlements",
+    "sensory_details": "Drums thud beyond the walls while the wind carries grit."
+  },
   "player": {
     "name": "The Shieldbearer",
     "inventory": [
       "oil lamp",
       "patched shield"
     ],
     "stats": {
       "resolve": 3,
       "empathy": 2
     },
     "summary": "A weary defender holding the western wall."
   },
   "character_summary": "Rhea is loyal but impulsive; Boris is cautious and calculating.",
   "relationship_summary": "Rhea trusts the player; Boris weighs every trade.",
   "metrics": {
-    "risk_applied_total": 1,
-    "major_flag_set": true,
+    "order": 50,
+    "morale": 50,
+    "resources": 40,
+    "knowledge": 45,
+    "corruption": 10,
+    "glitch": 12,
+    "risk_applied_total": 0,
+    "major_flag_set": false,
     "major_events_triggered": 0,
-    "major_event_last_turn": 0
+    "major_event_last_turn": null
   },
-  "npc_trust": {
-    "Rhea": 3,
-    "Shieldbearer": 1,
-    "The Shieldbearer": 2
-  }
+  "npc_trust": {},
+  "status_effects": [],
+  "items": {},
+  "recent_major_events": []
 }
diff --git a/fortress_director/orchestrator/orchestrator.py b/fortress_director/orchestrator/orchestrator.py
index 87d82181ad3cb47a6bde8e38539128c0ecb55817..fc9aafa971d65c1729ecd601dee9452f7da6b8dc 100644
--- a/fortress_director/orchestrator/orchestrator.py
+++ b/fortress_director/orchestrator/orchestrator.py
@@ -1,55 +1,57 @@
 from __future__ import annotations
 
 import ast
 import json
 import logging
 from copy import deepcopy
 from dataclasses import dataclass
 from pathlib import Path
 from typing import Any, Callable, Dict, List, Optional, Tuple
 
 from fortress_director.codeaware.function_validator import FunctionCallValidator
 from fortress_director.codeaware.rollback_system import RollbackSystem
 from fortress_director.utils.output_validator import validate_turn_output
 from fortress_director.settings import DEFAULT_WORLD_STATE
 from fortress_director.agents.character_agent import CharacterAgent
 from fortress_director.agents.event_agent import EventAgent
-from fortress_director.agents.judge_agent import JudgeAgent
+from fortress_director.agents.judge_agent import JudgeAgent, check_win_loss
 from fortress_director.agents.world_agent import WorldAgent
 from fortress_director.settings import SETTINGS
 from fortress_director.rules.rules_engine import (
     RulesEngine,
     TierTwoValidationError,
 )
 from fortress_director.codeaware.function_registry import (
     FunctionCall,
     FunctionNotRegisteredError,
     FunctionValidationError,
     SafeFunctionRegistry,
     Validator,
 )
+from fortress_director.utils.glitch_manager import GlitchManager
+from fortress_director.utils.metrics_manager import MetricManager
 
 LOGGER = logging.getLogger(__name__)
 
 RELATIONSHIP_SUMMARY_DEFAULT = "No relationship summary available."
 
 
 class StateStore:
     """Lightweight JSON-backed state store."""
 
     def __init__(self, path: Path) -> None:
         self._path = path
         self._state = self._load()
 
     def snapshot(self) -> Dict[str, Any]:
         """Return a deep copy of the current state for safe mutation."""
 
         snapshot = deepcopy(self._state)
         LOGGER.debug(
             "State snapshot loaded from %s (turn=%s)",
             self._path,
             snapshot.get("turn"),
         )
         return snapshot
 
     def persist(self, state: Dict[str, Any]) -> None:
@@ -242,81 +244,104 @@ class Orchestrator:
             max_checkpoints=3,
             logger=LOGGER,
         )
         orchestrator = cls(
             state_store=state_store,
             event_agent=EventAgent(),
             world_agent=WorldAgent(),
             character_agent=CharacterAgent(),
             judge_agent=judge_agent,
             rules_engine=RulesEngine(judge_agent=judge_agent, tolerance=tolerance),
             function_registry=registry,
             function_validator=validator,
             rollback_system=rollback_system,
         )
         orchestrator._register_default_safe_functions()
         return orchestrator
 
     def run_turn(
         self,
         *,
         player_choice_id: Optional[str] = None,
     ) -> Dict[str, Any]:
         """Execute a full deterministic turn and persist the new state. Logs every step in detail."""
         LOGGER.info("run_turn called (player_choice_id=%s)", player_choice_id)
 
+        self._metric_log_buffer = []
+        glitch_info: Dict[str, Any] = {"roll": 0, "effects": [], "triggered_loss": False}
+
         checkpoint_metadata = {"phase": "turn_start"}
         if player_choice_id:
             checkpoint_metadata["player_choice_id"] = player_choice_id
         LOGGER.debug(
             "Resetting function validator and creating checkpoint: %s",
             checkpoint_metadata,
         )
         self.function_validator.reset()
         self.rollback_system.create_checkpoint(metadata=checkpoint_metadata)
 
         try:
             LOGGER.info("Turn execution started.")
             state_snapshot = self.state_store.snapshot()
             LOGGER.debug(
                 "Pre-turn state snapshot: %s",
                 self._stringify(state_snapshot),
             )
-            turn_limit = state_snapshot.get("turn_limit", 10)
+            metric_manager = MetricManager(
+                state_snapshot,
+                log_sink=self._metric_log_sink(),
+            )
+            rng_seed = state_snapshot.get("rng_seed", 0)
+            if not isinstance(rng_seed, int):
+                try:
+                    rng_seed = int(rng_seed)
+                except (TypeError, ValueError):
+                    rng_seed = 0
+            state_snapshot["rng_seed"] = rng_seed
+            glitch_manager = GlitchManager(seed=rng_seed)
+
+            turn_limit = state_snapshot.get("turn_limit", 30)
             current_turn = state_snapshot.get(
                 "current_turn", state_snapshot.get("turn", 0)
             )
             if not isinstance(current_turn, int):
                 try:
                     current_turn = int(current_turn)
                 except (TypeError, ValueError):
                     current_turn = 0
             if not isinstance(turn_limit, int):
                 try:
                     turn_limit = int(turn_limit)
                 except (TypeError, ValueError):
-                    turn_limit = 10
+                    turn_limit = 30
+            turn_limit = min(turn_limit, 30)
+
+            glitch_info = glitch_manager.resolve_turn(
+                metrics=metric_manager,
+                turn=current_turn + 1,
+            )
+
             is_final_turn = current_turn >= turn_limit
             world_context = self._build_world_context(state_snapshot)
             LOGGER.info("World context built.")
             LOGGER.debug("World context payload: %s", world_context)
             LOGGER.info(
                 "Starting turn %s in room %s",
                 state_snapshot.get("turn", 0),
                 state_snapshot.get("current_room", "unknown"),
             )
 
             world_request = {
                 "WORLD_CONTEXT": world_context,
                 "room": state_snapshot.get("current_room", "unknown"),
             }
             LOGGER.debug(
                 "World agent input: %s",
                 self._stringify(world_request),
             )
             LOGGER.info("Calling world_agent.describe...")
             world_output = self.world_agent.describe(world_request)
             LOGGER.info("World agent returned output.")
             LOGGER.debug(
                 "World agent output: %s",
                 self._stringify(world_output),
             )
@@ -461,68 +486,98 @@ class Orchestrator:
                 major_event_summary = (
                     self._format_major_event_summary(major_event_effect)
                     if major_event_effect
                     else None
                 )
 
             LOGGER.info("Updating state and persisting...")
             self._update_state(
                 state,
                 world_output,
                 event_output,
                 chosen_option,
             )
             LOGGER.debug(
                 "State after update: %s",
                 self._stringify(state),
             )
             self.state_store.persist(state)
             LOGGER.info("Executing safe function queue...")
             safe_function_results = self._execute_safe_function_queue(
                 event_output=event_output,
                 character_output=character_output,
             )
             LOGGER.info("Safe function queue executed.")
 
+            final_state = self.state_store.snapshot()
+            final_metrics = MetricManager(
+                final_state,
+                log_sink=self._metric_log_sink(),
+            )
+            metrics_after = final_metrics.snapshot()
+            win_loss = check_win_loss(
+                metrics_after,
+                turn=final_state.get("turn", 0),
+                turn_limit=final_state.get("turn_limit", turn_limit),
+            )
+            if glitch_info.get("triggered_loss") and win_loss["status"] == "ongoing":
+                win_loss = {"status": "loss", "reason": "glitch_overload"}
+            narrative = self._compose_turn_narrative(
+                turn=final_state.get("turn", 0),
+                choice=chosen_option,
+                character_output=character_output,
+                glitch_effects=glitch_info.get("effects", []),
+            )
+
             result = {
                 "WORLD_CONTEXT": world_context,
                 "scene": event_output.get("scene", ""),
                 "options": event_output.get("options", []),
                 "world": world_output,
                 "event": event_output,
                 "player_choice": chosen_option,
                 "character_reactions": character_output,
             }
             LOGGER.info("Turn result built.")
             if major_event_effect:
                 result["major_event_effect"] = major_event_effect
             if major_event_summary:
                 result["major_event_effect_summary"] = major_event_summary
             if warnings:
                 result["warnings"] = warnings
             if safe_function_results:
                 result["safe_function_results"] = safe_function_results
+            result["metrics_after"] = metrics_after
+            result["glitch"] = {
+                "roll": int(glitch_info.get("roll", 0)),
+                "effects": list(glitch_info.get("effects", [])),
+            }
+            result["logs"] = list(self._metric_log_buffer)
+            result["win_loss"] = win_loss
+            result["narrative"] = narrative
+            if win_loss["status"] != "ongoing":
+                result["options"] = []
             LOGGER.debug(
                 "Turn result before validation: %s",
                 self._stringify(result),
             )
             validate_turn_output(result)
             LOGGER.info("Turn output validated successfully.")
         except Exception as exc:
             class_name = exc.__class__.__name__
             rollback_reason = f"Turn execution failed: {class_name}"
             LOGGER.error("Exception during turn: %s", exc, exc_info=True)
             try:
                 self.rollback_system.rollback(reason=rollback_reason)
                 LOGGER.info("Rollback performed after exception.")
             except Exception as rollback_error:  # pragma: no cover - defensive
                 LOGGER.error(
                     "Rollback failed after %s: %s",
                     exc.__class__.__name__,
                     rollback_error,
                 )
             raise
         else:
             self.rollback_system.clear()
             LOGGER.info("Turn completed successfully.")
             return result
 
@@ -551,50 +606,60 @@ class Orchestrator:
             metadata=metadata,
         )
 
     def _register_default_safe_functions(self) -> None:
         """Register baseline safe functions used by the scenario."""
 
         self.register_safe_function(
             "change_weather",
             self._safe_change_weather,
             validator=self._validate_change_weather_call,
         )
         self.register_safe_function(
             "spawn_item",
             self._safe_spawn_item,
             validator=self._validate_spawn_item_call,
         )
         self.register_safe_function(
             "move_npc",
             self._safe_move_npc,
             validator=self._validate_move_npc_call,
         )
         self.register_safe_function("adjust_logic", self._safe_adjust_logic)
         self.register_safe_function("adjust_emotion", self._safe_adjust_emotion)
         self.register_safe_function("raise_corruption", self._safe_raise_corruption)
         self.register_safe_function("advance_turn", self._safe_advance_turn)
+        self.register_safe_function(
+            "modify_resources",
+            self._safe_modify_resources,
+            validator=self._validate_modify_resources_call,
+        )
+        self.register_safe_function(
+            "adjust_metric",
+            self._safe_adjust_metric,
+            validator=self._validate_adjust_metric_call,
+        )
 
     def _validate_change_weather_call(
         self,
         call: FunctionCall,
     ) -> FunctionCall:
         if call.args:
             raise FunctionValidationError(
                 "change_weather does not accept positional arguments",
             )
         kwargs = dict(call.kwargs)
         atmosphere = kwargs.get("atmosphere")
         details = kwargs.get("sensory_details")
         if not isinstance(atmosphere, str) or not atmosphere.strip():
             raise FunctionValidationError(
                 "change_weather requires a non-empty 'atmosphere' string",
             )
         if not isinstance(details, str) or not details.strip():
             raise FunctionValidationError(
                 "change_weather requires non-empty 'sensory_details'",
             )
         sanitized = {
             "atmosphere": atmosphere.strip(),
             "sensory_details": details.strip(),
         }
         return FunctionCall(
@@ -642,50 +707,101 @@ class Orchestrator:
             raise FunctionValidationError(
                 "move_npc does not accept positional arguments",
             )
         kwargs = dict(call.kwargs)
         npc_id = kwargs.get("npc_id")
         location = kwargs.get("location")
         if not isinstance(npc_id, str) or not npc_id.strip():
             raise FunctionValidationError(
                 "move_npc requires a non-empty 'npc_id' string",
             )
         if not isinstance(location, str) or not location.strip():
             raise FunctionValidationError(
                 "move_npc requires a non-empty 'location' string",
             )
         sanitized = {
             "npc_id": npc_id.strip(),
             "location": location.strip(),
         }
         return FunctionCall(
             name=call.name,
             args=(),
             kwargs=sanitized,
             metadata=call.metadata,
         )
 
+    def _validate_modify_resources_call(
+        self,
+        call: FunctionCall,
+    ) -> FunctionCall:
+        if call.args:
+            raise FunctionValidationError(
+                "modify_resources does not accept positional arguments",
+            )
+        kwargs = dict(call.kwargs)
+        amount_raw = kwargs.get("amount", kwargs.get("delta", 0))
+        try:
+            amount = int(amount_raw)
+        except (TypeError, ValueError) as exc:
+            raise FunctionValidationError("modify_resources requires integer amount") from exc
+        cause_raw = kwargs.get("cause", "safe_modify_resources")
+        cause = str(cause_raw).strip() or "safe_modify_resources"
+        sanitized = {"amount": amount, "cause": cause}
+        return FunctionCall(
+            name=call.name,
+            args=(),
+            kwargs=sanitized,
+            metadata=call.metadata,
+        )
+
+    def _validate_adjust_metric_call(
+        self,
+        call: FunctionCall,
+    ) -> FunctionCall:
+        if call.args:
+            raise FunctionValidationError(
+                "adjust_metric does not accept positional arguments",
+            )
+        kwargs = dict(call.kwargs)
+        metric_raw = kwargs.get("metric")
+        if not isinstance(metric_raw, str) or not metric_raw.strip():
+            raise FunctionValidationError("adjust_metric requires a metric name")
+        metric = metric_raw.strip()
+        try:
+            delta = int(kwargs.get("delta", 0))
+        except (TypeError, ValueError) as exc:
+            raise FunctionValidationError("adjust_metric requires integer delta") from exc
+        cause_raw = kwargs.get("cause", f"adjust_metric:{metric}")
+        cause = str(cause_raw).strip() or f"adjust_metric:{metric}"
+        sanitized = {"metric": metric, "delta": delta, "cause": cause}
+        return FunctionCall(
+            name=call.name,
+            args=(),
+            kwargs=sanitized,
+            metadata=call.metadata,
+        )
+
     def _safe_change_weather(
         self,
         *,
         atmosphere: str,
         sensory_details: str,
     ) -> Dict[str, str]:
         state = self.state_store.snapshot()
         payload = state.setdefault("world_constraint_from_prev_turn", {})
         payload["atmosphere"] = atmosphere
         payload["sensory_details"] = sensory_details
         self.state_store.persist(state)
         return {
             "atmosphere": payload["atmosphere"],
             "sensory_details": payload["sensory_details"],
         }
 
     def _safe_spawn_item(
         self,
         *,
         item_id: str,
         target: str,
     ) -> Dict[str, Any]:
         state = self.state_store.snapshot()
         if target == "player":
             player = state.setdefault("player", {})
@@ -701,82 +817,114 @@ class Orchestrator:
             bucket = storage.setdefault(target, [])
             if item_id not in bucket:
                 bucket.append(item_id)
             result = {
                 "target": target,
                 "items": list(bucket),
             }
         self.state_store.persist(state)
         return result
 
     def _safe_move_npc(
         self,
         *,
         npc_id: str,
         location: str,
     ) -> Dict[str, str]:
         state = self.state_store.snapshot()
         registry = state.setdefault("npc_locations", {})
         registry[npc_id] = location
         self.state_store.persist(state)
         return {
             "npc_id": npc_id,
             "location": location,
         }
 
+    def _safe_modify_resources(
+        self,
+        *,
+        amount: int,
+        cause: str,
+    ) -> Dict[str, Any]:
+        state = self.state_store.snapshot()
+        manager = MetricManager(state, log_sink=self._metric_log_sink())
+        value = manager.modify_resources(amount, cause=cause)
+        self.state_store.persist(state)
+        return {"resources": value}
+
+    def _safe_adjust_metric(
+        self,
+        *,
+        metric: str,
+        delta: int,
+        cause: str,
+    ) -> Dict[str, Any]:
+        state = self.state_store.snapshot()
+        manager = MetricManager(state, log_sink=self._metric_log_sink())
+        value = manager.adjust_metric(metric, delta, cause=cause)
+        self.state_store.persist(state)
+        return {metric: value}
+
     def _safe_adjust_logic(self) -> Dict[str, Any]:
         return self._adjust_score("logic_score", 1)
 
     def _safe_adjust_emotion(self) -> Dict[str, Any]:
         return self._adjust_score("emotion_score", 1)
 
     def _safe_raise_corruption(self) -> Dict[str, Any]:
         return self._adjust_score("corruption", 1)
 
     def _safe_advance_turn(self) -> Dict[str, Any]:
         state = self.state_store.snapshot()
         previous_turn = state.get("current_turn")
         if not isinstance(previous_turn, int):
             previous_turn = int(state.get("turn", 0))
         next_turn = previous_turn + 1
         state["current_turn"] = next_turn
         state["turn"] = max(int(state.get("turn", next_turn)), next_turn)
         self.state_store.persist(state)
         return {"current_turn": state["current_turn"], "turn": state["turn"]}
 
     def _adjust_score(self, key: str, delta: int) -> Dict[str, Any]:
         state = self.state_store.snapshot()
         scores = state.setdefault("scores", {})
         current_value = scores.get(key, 0)
         try:
             current_value = int(current_value)
         except (TypeError, ValueError):
             current_value = 0
         scores[key] = current_value + delta
         self.state_store.persist(state)
         return {"scores": dict(scores)}
 
+    def _metric_log_sink(self) -> List[Dict[str, Any]]:
+        buffer = getattr(self, "_metric_log_buffer", None)
+        if buffer is None:
+            buffer = []
+            self._metric_log_buffer = buffer
+        return buffer
+
     def _execute_safe_function_queue(
         self,
         *,
         event_output: Dict[str, Any],
         character_output: List[Dict[str, Any]],
     ) -> List[Dict[str, Any]]:
         """Execute any safe function requests emitted by agents."""
 
         calls = self._collect_safe_function_calls(
             event_output=event_output,
             character_output=character_output,
         )
         results: List[Dict[str, Any]] = []
         for payload, metadata in calls:
             outcome = self.run_safe_function(payload, metadata=metadata)
             results.append(
                 {
                     "name": payload["name"],
                     "result": outcome,
                     "metadata": metadata,
                 }
             )
         return results
 
     def _collect_safe_function_calls(
@@ -1132,50 +1280,80 @@ class Orchestrator:
             ),
             f"Recent events: {self._format_recent_events(state)}",
             f"Recent motifs: {recent_motifs}",
             f"Recent major events: {recent_major}",
             (
                 "Relationship summary: {text}".format(
                     text=state.get(
                         "relationship_summary",
                         RELATIONSHIP_SUMMARY_DEFAULT,
                     )
                 )
             ),
             (
                 "Character summary: {text}".format(
                     text=state.get("character_summary", "").strip()
                 )
             ),
             (
                 "Metrics: {payload}".format(
                     payload=json.dumps(metrics, ensure_ascii=False)
                 )
             ),
         ]
         return "\n".join(part for part in sections if part)
 
+    def _compose_turn_narrative(
+        self,
+        *,
+        turn: int,
+        choice: Dict[str, Any],
+        character_output: List[Dict[str, Any]],
+        glitch_effects: List[str],
+    ) -> str:
+        """Generate a compact textual summary for the turn result."""
+
+        if not isinstance(choice, dict):
+            choice = {}
+        choice_text = str(choice.get("text", "")).strip()
+        reaction_text = ""
+        if character_output:
+            primary = character_output[0]
+            if isinstance(primary, dict):
+                reaction_text = str(primary.get("speech") or primary.get("action") or "").strip()
+        glitch_text = ""
+        if glitch_effects:
+            glitch_text = str(glitch_effects[0]).strip()
+        parts = [
+            f"Turn {turn}",
+            choice_text,
+            reaction_text,
+            glitch_text,
+        ]
+        narrative = " | ".join(part for part in parts if part)
+        return narrative[:240]
+
     @staticmethod
     def _format_recent_events(state: Dict[str, Any]) -> str:
         events = state.get("recent_events") or []
         if not events:
             return "none"
         trimmed = [
             event for event in events[-3:] if isinstance(event, str) and event.strip()
         ]
         return "; ".join(trimmed) if trimmed else "none"
 
     @staticmethod
     def _derive_major_event_flag(state: Dict[str, Any]) -> str:
         flags = state.get("flags") or []
         if "mystery_figure" in flags:
             return "major_mystery_investigation"
         return "major_wall_alert"
 
     @staticmethod
     def _format_major_event_summary(
         effect: Optional[Dict[str, Any]],
     ) -> Optional[str]:
         if not effect:
             return None
         status = effect.get("status_change", {})
         status_label = status.get("status", "unknown")
@@ -1183,25 +1361,76 @@ class Orchestrator:
         target = effect.get("applied_to", "unknown")
         flag = effect.get("applied_flag", "major_event")
 
         return f"{flag} -> {target} ({status_label}, {duration} turns)"
 
     @staticmethod
     def _infer_primary_npc_name(state: Dict[str, Any]) -> str:
         summary = state.get("character_summary", "")
         if summary:
             first_word = summary.split()[0].strip(",.;:")
             if first_word:
                 return first_word
         return "Rhea"
 
     @staticmethod
     def _stringify(payload: Any) -> str:
         """Render payloads for logging without raising serialization errors."""
 
         try:
             text = json.dumps(payload, ensure_ascii=False, sort_keys=True)
         except (TypeError, ValueError):
             text = str(payload)
         if len(text) > 600:
             return text[:597] + "..."
         return text
+
+
+def simulate(n_turns: int = 3, seed: int = 123) -> None:
+    """Run a deterministic mini-simulation using the packaged orchestrator."""
+
+    orchestrator = Orchestrator.build_default()
+    baseline = deepcopy(DEFAULT_WORLD_STATE)
+    baseline["rng_seed"] = seed
+    baseline["turn"] = 0
+    baseline["current_turn"] = 0
+    MetricManager(baseline, log_sink=[])
+    orchestrator.state_store.persist(baseline)
+
+    for turn_index in range(n_turns):
+        result = orchestrator.run_turn()
+        print(json.dumps(result, indent=2, ensure_ascii=False))
+        status = result.get("win_loss", {}).get("status", "ongoing")
+        if status != "ongoing":
+            break
+        if turn_index == 0:
+            orchestrator.run_safe_function(
+                {
+                    "name": "adjust_metric",
+                    "kwargs": {
+                        "metric": "order",
+                        "delta": 15,
+                        "cause": "demo_order_boost",
+                    },
+                }
+            )
+            orchestrator.run_safe_function(
+                {
+                    "name": "adjust_metric",
+                    "kwargs": {
+                        "metric": "morale",
+                        "delta": 18,
+                        "cause": "demo_morale_boost",
+                    },
+                }
+            )
+        if turn_index == 1:
+            orchestrator.run_safe_function(
+                {
+                    "name": "adjust_metric",
+                    "kwargs": {
+                        "metric": "glitch",
+                        "delta": -10,
+                        "cause": "demo_glitch_stabilisation",
+                    },
+                }
+            )
diff --git a/fortress_director/settings.py b/fortress_director/settings.py
index 5ef124d5c3b2e7f7207653ff16a8ee996386d958..bd8c93cb1ca78344d6fa58cb4f052f78cc6f50a4 100644
--- a/fortress_director/settings.py
+++ b/fortress_director/settings.py
@@ -17,84 +17,94 @@ class ModelConfig:
     name: str
     temperature: float
     top_p: float
     max_tokens: int
 
 
 @dataclass(frozen=True)
 class Settings:
     """Immutable settings bundle for the entire engine."""
 
     project_root: Path
     db_path: Path
     world_state_path: Path
     cache_dir: Path
     log_dir: Path
     ollama_base_url: str
     ollama_timeout: float
     max_active_models: int
     semantic_cache_ttl: int
     models: Mapping[str, ModelConfig]
 
 
 DEFAULT_WORLD_STATE = {
     "campaign_id": "default_campaign",
     "turn_limit": 10,
-    "current_turn": 1,
+    "current_turn": 0,
+    "rng_seed": 12345,
     "scores": {
         "logic_score": 0,
         "emotion_score": 0,
         "corruption": 0,
     },
     "flags": [],
     "memory_layers": [],
     "active_layer": None,
     "npc_fragments": {},
     "inventory": [],
     "lore": {},
-    "turn": 1,
+    "turn": 0,
     "day": 1,
     "time": "dawn",
     "current_room": "entrance",
     "recent_events": [],
     "recent_motifs": [],
-    "world_constraint_from_prev_turn": {},
+    "world_constraint_from_prev_turn": {
+        "atmosphere": "low clouds hug the battlements",
+        "sensory_details": "Drums thud beyond the walls while the wind carries grit.",
+    },
     "player": {
         "name": "The Shieldbearer",
         "inventory": ["oil lamp", "patched shield"],
         "stats": {"resolve": 3, "empathy": 2},
         "summary": "A weary defender holding the western wall.",
     },
     "character_summary": "Rhea is loyal but impulsive; Boris is cautious and calculating.",
     "relationship_summary": "Rhea trusts the player; Boris weighs every trade.",
     "metrics": {
-        "risk_applied_total": 1,
-        "major_flag_set": True,
+        "order": 50,
+        "morale": 50,
+        "resources": 40,
+        "knowledge": 45,
+        "corruption": 10,
+        "glitch": 12,
+        "risk_applied_total": 0,
+        "major_flag_set": False,
         "major_events_triggered": 0,
-        "major_event_last_turn": 0,
+        "major_event_last_turn": None,
     },
-    "npc_trust": {"Rhea": 3, "Shieldbearer": 1, "The Shieldbearer": 2},
+    "npc_trust": {},
 }
 
 SETTINGS = Settings(
     project_root=PROJECT_ROOT,
     db_path=PROJECT_ROOT / "db" / "game_state.sqlite",
     world_state_path=PROJECT_ROOT / "data" / "world_state.json",
     cache_dir=PROJECT_ROOT / "cache",
     log_dir=PROJECT_ROOT / "logs",
     ollama_base_url="http://localhost:11434/",
     ollama_timeout=240.0,
     max_active_models=2,
     semantic_cache_ttl=86_400,
     models={
         "event": ModelConfig(
             name="mistral",
             temperature=0.2,
             top_p=0.5,
             max_tokens=512,
         ),
         "world": ModelConfig(
             name="phi3:mini",
             temperature=0.1,
             top_p=0.4,
             max_tokens=384,
         ),
diff --git a/fortress_director/utils/glitch_manager.py b/fortress_director/utils/glitch_manager.py
new file mode 100644
index 0000000000000000000000000000000000000000..da74506583b6d840a473792ec7dbbf067e4945bd
--- /dev/null
+++ b/fortress_director/utils/glitch_manager.py
@@ -0,0 +1,64 @@
+"""Deterministic glitch propagation utilities for Fortress Director."""
+
+from __future__ import annotations
+
+import hashlib
+from dataclasses import dataclass
+from typing import Dict, List
+
+from fortress_director.utils.metrics_manager import MetricManager
+
+
+@dataclass
+class GlitchManager:
+    """Compute glitch rolls and apply deterministic side-effects."""
+
+    seed: int = 0
+
+    def resolve_turn(
+        self,
+        *,
+        metrics: MetricManager,
+        turn: int,
+    ) -> Dict[str, object]:
+        current_glitch = metrics.value("glitch")
+        roll = self._deterministic_roll(turn=turn, glitch=current_glitch)
+        effects: List[str] = []
+        triggered_loss = False
+
+        if roll <= 30:
+            effects.append("Minor static ripples along the parapets.")
+            metrics.adjust_metric("glitch", 1, cause="glitch:cosmetic_noise")
+        elif roll <= 60:
+            effects.append("Pathfinding errors unsettle the patrol routes.")
+            metrics.apply_bulk(
+                (
+                    ("order", -3, "glitch:medium_anomaly"),
+                    ("morale", -2, "glitch:medium_anomaly"),
+                    ("glitch", 4, "glitch:medium_anomaly"),
+                )
+            )
+        elif roll < 85:
+            effects.append("Major anomaly distorts the western wall segment.")
+            metrics.apply_bulk(
+                (
+                    ("resources", -6, "glitch:major_anomaly"),
+                    ("knowledge", -5, "glitch:major_anomaly"),
+                    ("glitch", 6, "glitch:major_anomaly"),
+                )
+            )
+        else:
+            effects.append("Glitch cascade overwhelms containment protocols.")
+            metrics.adjust_metric("glitch", 15, cause="glitch:overload")
+            triggered_loss = True
+
+        return {
+            "roll": roll,
+            "effects": effects,
+            "triggered_loss": triggered_loss,
+        }
+
+    def _deterministic_roll(self, *, turn: int, glitch: int) -> int:
+        payload = f"{self.seed}:{turn}:{glitch}".encode("utf-8")
+        digest = hashlib.sha256(payload).digest()
+        return int.from_bytes(digest[:4], "big") % 101
diff --git a/fortress_director/utils/metrics_manager.py b/fortress_director/utils/metrics_manager.py
new file mode 100644
index 0000000000000000000000000000000000000000..51f1a770259f4e7567e5777e7dabce5a922831ba
--- /dev/null
+++ b/fortress_director/utils/metrics_manager.py
@@ -0,0 +1,109 @@
+"""Metric management utilities for the packaged orchestrator."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from typing import Any, Dict, Iterable, List, MutableMapping, Optional
+
+
+MetricDict = MutableMapping[str, Any]
+
+
+@dataclass
+class MetricManager:
+    """Centralised helper responsible for metric mutation and logging."""
+
+    state: Dict[str, Any]
+    log_sink: Optional[List[Dict[str, Any]]] = None
+    _metrics: MetricDict = field(init=False, repr=False)
+
+    CORE_DEFAULTS: Dict[str, int] = field(
+        default_factory=lambda: {
+            "order": 50,
+            "morale": 50,
+            "resources": 40,
+            "knowledge": 45,
+            "corruption": 10,
+            "glitch": 12,
+        }
+    )
+
+    LEGACY_DEFAULTS: Dict[str, int] = field(
+        default_factory=lambda: {
+            "risk_applied_total": 0,
+            "major_flag_set": False,
+            "major_events_triggered": 0,
+            "major_event_last_turn": None,
+        }
+    )
+
+    LIMITS: Dict[str, tuple[int, int]] = field(
+        default_factory=lambda: {
+            "order": (0, 100),
+            "morale": (0, 100),
+            "resources": (0, 120),
+            "knowledge": (0, 100),
+            "corruption": (0, 100),
+            "glitch": (0, 100),
+        }
+    )
+
+    def __post_init__(self) -> None:
+        metrics = self.state.setdefault("metrics", {})
+        for key, value in self.CORE_DEFAULTS.items():
+            metrics.setdefault(key, value)
+        for key, value in self.LEGACY_DEFAULTS.items():
+            metrics.setdefault(key, value)
+        self._metrics = metrics
+        if self.log_sink is None:
+            self.log_sink = metrics.setdefault("_log_buffer", [])
+
+    def snapshot(self, *, include_legacy: bool = True) -> Dict[str, Any]:
+        if include_legacy:
+            keys: Iterable[str] = self._metrics.keys()
+        else:
+            keys = self.CORE_DEFAULTS.keys()
+        snapshot: Dict[str, Any] = {}
+        for key in keys:
+            if isinstance(key, str) and key.startswith("_"):
+                continue
+            snapshot[key] = self._metrics.get(key)
+        return snapshot
+
+    def value(self, metric: str) -> int:
+        raw = self._metrics.get(metric, 0)
+        try:
+            return int(raw)
+        except (TypeError, ValueError):
+            return 0
+
+    def adjust_metric(self, metric: str, delta: int, *, cause: str) -> int:
+        if not metric:
+            raise ValueError("metric name is required")
+        current = self.value(metric)
+        limit = self.LIMITS.get(metric, (0, 9999))
+        updated = self._clamp(current + int(delta), limit)
+        self._metrics[metric] = updated
+        self._log_change(metric, updated - current, updated, cause)
+        return updated
+
+    def modify_resources(self, amount: int, *, cause: str) -> int:
+        return self.adjust_metric("resources", int(amount), cause=cause)
+
+    def apply_bulk(self, changes: Iterable[tuple[str, int, str]]) -> None:
+        for metric, delta, cause in changes:
+            self.adjust_metric(metric, delta, cause=cause)
+
+    def _clamp(self, value: int, limit: tuple[int, int]) -> int:
+        lower, upper = limit
+        return max(lower, min(upper, value))
+
+    def _log_change(self, metric: str, delta: int, value: int, cause: str) -> None:
+        entry = {
+            "metric": metric,
+            "delta": delta,
+            "value": value,
+            "cause": cause,
+        }
+        if isinstance(self.log_sink, list):
+            self.log_sink.append(entry)
diff --git a/fortress_director/utils/output_validator.py b/fortress_director/utils/output_validator.py
index cfe68c2c02bee9fdfb839a880c97dd9d7d1a52aa..cae4d84e058ed9b75205e265580b84627a158bde 100644
--- a/fortress_director/utils/output_validator.py
+++ b/fortress_director/utils/output_validator.py
@@ -48,51 +48,61 @@ def _validate_character_reactions(reactions: List[Dict[str, Any]]) -> None:
         _require_keys(
             reaction,
             keys=("name", "intent", "action", "speech"),
             context=context,
         )
         for key in ("name", "intent", "action", "speech"):
             if not isinstance(reaction.get(key), str):
                 message = f"{context} field '{key}' must be a string"
                 raise OutputValidationError(message)
         effects = reaction.get("effects", {})
         if effects is None:
             continue
         if not isinstance(effects, dict):
             message = f"{context} effects must be an object if present"
             raise OutputValidationError(message)
 
 
 def validate_turn_output(payload: Dict[str, Any]) -> None:
     """Validate the structure of the orchestrator turn output."""
 
     if not isinstance(payload, dict):
         raise OutputValidationError("Turn output must be a JSON object")
 
     _require_keys(
         payload,
-        keys=("world", "event", "player_choice", "character_reactions"),
+        keys=(
+            "world",
+            "event",
+            "player_choice",
+            "character_reactions",
+            "metrics_after",
+            "glitch",
+            "logs",
+            "win_loss",
+            "narrative",
+        ),
         context="root payload",
     )
 
     world = payload["world"]
     _assert_type(world, dict, context="world")
     _require_keys(
         world,
         keys=("atmosphere", "sensory_details"),
         context="world",
     )
     world_strings = all(
         isinstance(world[key], str) for key in ("atmosphere", "sensory_details")
     )
     if not world_strings:
         raise OutputValidationError("World fields must be strings")
 
     event = payload["event"]
     _assert_type(event, dict, context="event")
     _require_keys(
         event,
         keys=("scene", "options", "major_event"),
         context="event",
     )
     if not isinstance(event["scene"], str):
         raise OutputValidationError("Event scene must be a string")
@@ -112,25 +122,79 @@ def validate_turn_output(payload: Dict[str, Any]) -> None:
 
     player_choice = payload["player_choice"]
     _assert_type(player_choice, dict, context="player_choice")
     _require_keys(
         player_choice,
         keys=("id", "text", "action_type"),
         context="player_choice",
     )
     choice_strings = all(
         isinstance(player_choice[key], str) and player_choice[key].strip()
         for key in ("id", "text", "action_type")
     )
     if not choice_strings:
         raise OutputValidationError("Player choice fields must be non-empty strings")
 
     reactions = payload["character_reactions"]
     _assert_type(reactions, list, context="character_reactions")
     _validate_character_reactions(reactions)
 
     warnings = payload.get("warnings")
     if warnings is not None:
         _assert_type(warnings, list, context="warnings")
         for warning in warnings:
             if not isinstance(warning, str):
                 raise OutputValidationError("Warnings must be strings")
+
+    metrics_after = payload["metrics_after"]
+    _assert_type(metrics_after, dict, context="metrics_after")
+    required_metrics = (
+        "order",
+        "morale",
+        "resources",
+        "knowledge",
+        "corruption",
+        "glitch",
+    )
+    for metric in required_metrics:
+        if metric not in metrics_after:
+            raise OutputValidationError(f"metrics_after missing '{metric}'")
+        if not isinstance(metrics_after[metric], int):
+            raise OutputValidationError(
+                f"metrics_after['{metric}'] must be an integer"
+            )
+
+    glitch = payload["glitch"]
+    _assert_type(glitch, dict, context="glitch")
+    _require_keys(glitch, keys=("roll", "effects"), context="glitch")
+    if not isinstance(glitch["roll"], int):
+        raise OutputValidationError("glitch.roll must be an integer")
+    effects = glitch["effects"]
+    _assert_type(effects, list, context="glitch effects")
+    for effect in effects:
+        if not isinstance(effect, str):
+            raise OutputValidationError("glitch effects must be strings")
+
+    logs = payload["logs"]
+    _assert_type(logs, list, context="logs")
+    for entry in logs:
+        if not isinstance(entry, dict):
+            raise OutputValidationError("log entries must be objects")
+        _require_keys(
+            entry,
+            keys=("metric", "delta", "value", "cause"),
+            context="log entry",
+        )
+
+    win_loss = payload["win_loss"]
+    _assert_type(win_loss, dict, context="win_loss")
+    _require_keys(win_loss, keys=("status", "reason"), context="win_loss")
+    status = win_loss["status"]
+    if status not in {"ongoing", "win", "loss"}:
+        raise OutputValidationError("win_loss.status must be ongoing, win, or loss")
+    for key in ("status", "reason"):
+        if not isinstance(win_loss[key], str):
+            raise OutputValidationError(f"win_loss.{key} must be a string")
+
+    narrative = payload["narrative"]
+    if not isinstance(narrative, str):
+        raise OutputValidationError("narrative must be a string")
diff --git a/orchestrator/orchestrator.py b/orchestrator/orchestrator.py
index 34a1880cb4c8b66a4553264bcaec1c7a28709c92..728d6cc2e77147feccac78eda51a2c7824ae0d20 100644
--- a/orchestrator/orchestrator.py
+++ b/orchestrator/orchestrator.py
@@ -1,93 +1,101 @@
 """Deterministic orchestrator coordinating Fortress Director agents."""
 
 from __future__ import annotations
 
 import ast
 import json
 import logging
 from copy import deepcopy
 from dataclasses import dataclass
 from pathlib import Path
 from typing import Any, Callable, Dict, List, Optional, Tuple
 
 from agents.character_agent import CharacterAgent
 from agents.event_agent import EventAgent
-from agents.judge_agent import JudgeAgent
+from agents.judge_agent import JudgeAgent, check_win_loss
 from agents.world_agent import WorldAgent
 from settings import SETTINGS
 from rules.rules_engine import (
     RulesEngine,
     TierTwoValidationError,
 )
 from codeaware.function_registry import (
     FunctionCall,
     FunctionNotRegisteredError,
     FunctionValidationError,
     SafeFunctionRegistry,
     Validator,
 )
 from codeaware.function_validator import (
     FunctionCallValidator,
 )
 from codeaware.rollback_system import RollbackSystem
 from utils.output_validator import validate_turn_output
-from utils.output_validator import validate_turn_output
+from utils.glitch_manager import GlitchManager
+from utils.metrics_manager import MetricManager
 
 
 LOGGER = logging.getLogger(__name__)
 
 
 SENSORY_DETAILS_DEFAULT = "Drums thud beyond the walls while the wind carries grit."
 
 RELATIONSHIP_SUMMARY_DEFAULT = "Rhea trusts the player; Boris weighs every trade."
 
 
 DEFAULT_WORLD_STATE: Dict[str, Any] = {
     "turn": 0,
     "day": 1,
     "time": "dawn",
-    "turn_limit": 10,
+    "turn_limit": 30,
+    "rng_seed": 12345,
     "current_room": "lornhaven_wall",
     "recent_events": [],
     "recent_motifs": [],
     "recent_major_events": [],
     "world_constraint_from_prev_turn": {
         "atmosphere": "low clouds hug the battlements",
         "sensory_details": SENSORY_DETAILS_DEFAULT,
     },
     "player": {
         "name": "The Shieldbearer",
         "inventory": ["oil lamp", "patched shield"],
         "stats": {"resolve": 3, "empathy": 2},
         "summary": "A weary defender holding the western wall.",
     },
     "character_summary": (
         "Rhea is loyal but impulsive; Boris is cautious and calculating."
     ),
     "relationship_summary": RELATIONSHIP_SUMMARY_DEFAULT,
     "metrics": {
+        "order": 50,
+        "morale": 50,
+        "resources": 40,
+        "knowledge": 45,
+        "corruption": 10,
+        "glitch": 12,
         "risk_applied_total": 0,
         "major_flag_set": False,
         "major_events_triggered": 0,
         "major_event_last_turn": None,
     },
 }
 
 
 class StateStore:
     """Lightweight JSON-backed state store."""
 
     def __init__(self, path: Path) -> None:
         self._path = path
         self._state = self._load()
 
     def snapshot(self) -> Dict[str, Any]:
         """Return a deep copy of the current state for safe mutation."""
 
         snapshot = deepcopy(self._state)
         LOGGER.debug(
             "State snapshot loaded from %s (turn=%s)",
             self._path,
             snapshot.get("turn"),
         )
         return snapshot
@@ -219,81 +227,104 @@ class Orchestrator:
             max_checkpoints=3,
             logger=LOGGER,
         )
         orchestrator = cls(
             state_store=state_store,
             event_agent=EventAgent(),
             world_agent=WorldAgent(),
             character_agent=CharacterAgent(),
             judge_agent=judge_agent,
             rules_engine=RulesEngine(judge_agent=judge_agent, tolerance=tolerance),
             function_registry=registry,
             function_validator=validator,
             rollback_system=rollback_system,
         )
         orchestrator._register_default_safe_functions()
         return orchestrator
 
     def run_turn(
         self,
         *,
         player_choice_id: Optional[str] = None,
     ) -> Dict[str, Any]:
         """Execute a full deterministic turn and persist the new state. Logs every step in detail."""
         LOGGER.info("run_turn called (player_choice_id=%s)", player_choice_id)
 
+        self._metric_log_buffer = []
+        glitch_info: Dict[str, Any] = {"roll": 0, "effects": [], "triggered_loss": False}
+
         checkpoint_metadata = {"phase": "turn_start"}
         if player_choice_id:
             checkpoint_metadata["player_choice_id"] = player_choice_id
         LOGGER.debug(
             "Resetting function validator and creating checkpoint: %s",
             checkpoint_metadata,
         )
         self.function_validator.reset()
         self.rollback_system.create_checkpoint(metadata=checkpoint_metadata)
 
         try:
             LOGGER.info("Turn execution started.")
             state_snapshot = self.state_store.snapshot()
             LOGGER.debug(
                 "Pre-turn state snapshot: %s",
                 self._stringify(state_snapshot),
             )
-            turn_limit = state_snapshot.get("turn_limit", 10)
+            metric_manager = MetricManager(
+                state_snapshot,
+                log_sink=self._metric_log_sink(),
+            )
+            rng_seed = state_snapshot.get("rng_seed", 0)
+            if not isinstance(rng_seed, int):
+                try:
+                    rng_seed = int(rng_seed)
+                except (TypeError, ValueError):
+                    rng_seed = 0
+            state_snapshot["rng_seed"] = rng_seed
+            glitch_manager = GlitchManager(seed=rng_seed)
+
+            turn_limit = state_snapshot.get("turn_limit", 30)
             current_turn = state_snapshot.get(
                 "current_turn", state_snapshot.get("turn", 0)
             )
             if not isinstance(current_turn, int):
                 try:
                     current_turn = int(current_turn)
                 except (TypeError, ValueError):
                     current_turn = 0
             if not isinstance(turn_limit, int):
                 try:
                     turn_limit = int(turn_limit)
                 except (TypeError, ValueError):
-                    turn_limit = 10
+                    turn_limit = 30
+            turn_limit = min(turn_limit, 30)
+
+            glitch_info = glitch_manager.resolve_turn(
+                metrics=metric_manager,
+                turn=current_turn + 1,
+            )
+
             is_final_turn = current_turn >= turn_limit
             world_context = self._build_world_context(state_snapshot)
             LOGGER.info("World context built.")
             LOGGER.debug("World context payload: %s", world_context)
             LOGGER.info(
                 "Starting turn %s in room %s",
                 state_snapshot.get("turn", 0),
                 state_snapshot.get("current_room", "unknown"),
             )
 
             world_request = {
                 "WORLD_CONTEXT": world_context,
                 "room": state_snapshot.get("current_room", "unknown"),
             }
             LOGGER.debug(
                 "World agent input: %s",
                 self._stringify(world_request),
             )
             LOGGER.info("Calling world_agent.describe...")
             world_output = self.world_agent.describe(world_request)
             LOGGER.info("World agent returned output.")
             LOGGER.debug(
                 "World agent output: %s",
                 self._stringify(world_output),
             )
@@ -438,68 +469,98 @@ class Orchestrator:
                 major_event_summary = (
                     self._format_major_event_summary(major_event_effect)
                     if major_event_effect
                     else None
                 )
 
             LOGGER.info("Updating state and persisting...")
             self._update_state(
                 state,
                 world_output,
                 event_output,
                 chosen_option,
             )
             LOGGER.debug(
                 "State after update: %s",
                 self._stringify(state),
             )
             self.state_store.persist(state)
             LOGGER.info("Executing safe function queue...")
             safe_function_results = self._execute_safe_function_queue(
                 event_output=event_output,
                 character_output=character_output,
             )
             LOGGER.info("Safe function queue executed.")
 
+            final_state = self.state_store.snapshot()
+            final_metrics = MetricManager(
+                final_state,
+                log_sink=self._metric_log_sink(),
+            )
+            metrics_after = final_metrics.snapshot()
+            win_loss = check_win_loss(
+                metrics_after,
+                turn=final_state.get("turn", 0),
+                turn_limit=final_state.get("turn_limit", turn_limit),
+            )
+            if glitch_info.get("triggered_loss") and win_loss["status"] == "ongoing":
+                win_loss = {"status": "loss", "reason": "glitch_overload"}
+            narrative = self._compose_turn_narrative(
+                turn=final_state.get("turn", 0),
+                choice=chosen_option,
+                character_output=character_output,
+                glitch_effects=glitch_info.get("effects", []),
+            )
+
             result = {
                 "WORLD_CONTEXT": world_context,
                 "scene": event_output.get("scene", ""),
                 "options": event_output.get("options", []),
                 "world": world_output,
                 "event": event_output,
                 "player_choice": chosen_option,
                 "character_reactions": character_output,
             }
             LOGGER.info("Turn result built.")
             if major_event_effect:
                 result["major_event_effect"] = major_event_effect
             if major_event_summary:
                 result["major_event_effect_summary"] = major_event_summary
             if warnings:
                 result["warnings"] = warnings
             if safe_function_results:
                 result["safe_function_results"] = safe_function_results
+            result["metrics_after"] = metrics_after
+            result["glitch"] = {
+                "roll": int(glitch_info.get("roll", 0)),
+                "effects": list(glitch_info.get("effects", [])),
+            }
+            result["logs"] = list(self._metric_log_buffer)
+            result["win_loss"] = win_loss
+            result["narrative"] = narrative
+            if win_loss["status"] != "ongoing":
+                result["options"] = []
             LOGGER.debug(
                 "Turn result before validation: %s",
                 self._stringify(result),
             )
             validate_turn_output(result)
             LOGGER.info("Turn output validated successfully.")
         except Exception as exc:
             class_name = exc.__class__.__name__
             rollback_reason = f"Turn execution failed: {class_name}"
             LOGGER.error("Exception during turn: %s", exc, exc_info=True)
             try:
                 self.rollback_system.rollback(reason=rollback_reason)
                 LOGGER.info("Rollback performed after exception.")
             except Exception as rollback_error:  # pragma: no cover - defensive
                 LOGGER.error(
                     "Rollback failed after %s: %s",
                     exc.__class__.__name__,
                     rollback_error,
                 )
             raise
         else:
             self.rollback_system.clear()
             LOGGER.info("Turn completed successfully.")
             return result
 
@@ -528,50 +589,60 @@ class Orchestrator:
             metadata=metadata,
         )
 
     def _register_default_safe_functions(self) -> None:
         """Register baseline safe functions used by the scenario."""
 
         self.register_safe_function(
             "change_weather",
             self._safe_change_weather,
             validator=self._validate_change_weather_call,
         )
         self.register_safe_function(
             "spawn_item",
             self._safe_spawn_item,
             validator=self._validate_spawn_item_call,
         )
         self.register_safe_function(
             "move_npc",
             self._safe_move_npc,
             validator=self._validate_move_npc_call,
         )
         self.register_safe_function("adjust_logic", self._safe_adjust_logic)
         self.register_safe_function("adjust_emotion", self._safe_adjust_emotion)
         self.register_safe_function("raise_corruption", self._safe_raise_corruption)
         self.register_safe_function("advance_turn", self._safe_advance_turn)
+        self.register_safe_function(
+            "modify_resources",
+            self._safe_modify_resources,
+            validator=self._validate_modify_resources_call,
+        )
+        self.register_safe_function(
+            "adjust_metric",
+            self._safe_adjust_metric,
+            validator=self._validate_adjust_metric_call,
+        )
 
     def _validate_change_weather_call(
         self,
         call: FunctionCall,
     ) -> FunctionCall:
         if call.args:
             raise FunctionValidationError(
                 "change_weather does not accept positional arguments",
             )
         kwargs = dict(call.kwargs)
         atmosphere = kwargs.get("atmosphere")
         details = kwargs.get("sensory_details")
         if not isinstance(atmosphere, str) or not atmosphere.strip():
             raise FunctionValidationError(
                 "change_weather requires a non-empty 'atmosphere' string",
             )
         if not isinstance(details, str) or not details.strip():
             raise FunctionValidationError(
                 "change_weather requires non-empty 'sensory_details'",
             )
         sanitized = {
             "atmosphere": atmosphere.strip(),
             "sensory_details": details.strip(),
         }
         return FunctionCall(
@@ -619,50 +690,101 @@ class Orchestrator:
             raise FunctionValidationError(
                 "move_npc does not accept positional arguments",
             )
         kwargs = dict(call.kwargs)
         npc_id = kwargs.get("npc_id")
         location = kwargs.get("location")
         if not isinstance(npc_id, str) or not npc_id.strip():
             raise FunctionValidationError(
                 "move_npc requires a non-empty 'npc_id' string",
             )
         if not isinstance(location, str) or not location.strip():
             raise FunctionValidationError(
                 "move_npc requires a non-empty 'location' string",
             )
         sanitized = {
             "npc_id": npc_id.strip(),
             "location": location.strip(),
         }
         return FunctionCall(
             name=call.name,
             args=(),
             kwargs=sanitized,
             metadata=call.metadata,
         )
 
+    def _validate_modify_resources_call(
+        self,
+        call: FunctionCall,
+    ) -> FunctionCall:
+        if call.args:
+            raise FunctionValidationError(
+                "modify_resources does not accept positional arguments",
+            )
+        kwargs = dict(call.kwargs)
+        amount_raw = kwargs.get("amount", kwargs.get("delta", 0))
+        try:
+            amount = int(amount_raw)
+        except (TypeError, ValueError) as exc:
+            raise FunctionValidationError("modify_resources requires integer amount") from exc
+        cause_raw = kwargs.get("cause", "safe_modify_resources")
+        cause = str(cause_raw).strip() or "safe_modify_resources"
+        sanitized = {"amount": amount, "cause": cause}
+        return FunctionCall(
+            name=call.name,
+            args=(),
+            kwargs=sanitized,
+            metadata=call.metadata,
+        )
+
+    def _validate_adjust_metric_call(
+        self,
+        call: FunctionCall,
+    ) -> FunctionCall:
+        if call.args:
+            raise FunctionValidationError(
+                "adjust_metric does not accept positional arguments",
+            )
+        kwargs = dict(call.kwargs)
+        metric_raw = kwargs.get("metric")
+        if not isinstance(metric_raw, str) or not metric_raw.strip():
+            raise FunctionValidationError("adjust_metric requires a metric name")
+        metric = metric_raw.strip()
+        try:
+            delta = int(kwargs.get("delta", 0))
+        except (TypeError, ValueError) as exc:
+            raise FunctionValidationError("adjust_metric requires integer delta") from exc
+        cause_raw = kwargs.get("cause", f"adjust_metric:{metric}")
+        cause = str(cause_raw).strip() or f"adjust_metric:{metric}"
+        sanitized = {"metric": metric, "delta": delta, "cause": cause}
+        return FunctionCall(
+            name=call.name,
+            args=(),
+            kwargs=sanitized,
+            metadata=call.metadata,
+        )
+
     def _safe_change_weather(
         self,
         *,
         atmosphere: str,
         sensory_details: str,
     ) -> Dict[str, str]:
         state = self.state_store.snapshot()
         payload = state.setdefault("world_constraint_from_prev_turn", {})
         payload["atmosphere"] = atmosphere
         payload["sensory_details"] = sensory_details
         self.state_store.persist(state)
         return {
             "atmosphere": payload["atmosphere"],
             "sensory_details": payload["sensory_details"],
         }
 
     def _safe_spawn_item(
         self,
         *,
         item_id: str,
         target: str,
     ) -> Dict[str, Any]:
         state = self.state_store.snapshot()
         if target == "player":
             player = state.setdefault("player", {})
@@ -678,82 +800,114 @@ class Orchestrator:
             bucket = storage.setdefault(target, [])
             if item_id not in bucket:
                 bucket.append(item_id)
             result = {
                 "target": target,
                 "items": list(bucket),
             }
         self.state_store.persist(state)
         return result
 
     def _safe_move_npc(
         self,
         *,
         npc_id: str,
         location: str,
     ) -> Dict[str, str]:
         state = self.state_store.snapshot()
         registry = state.setdefault("npc_locations", {})
         registry[npc_id] = location
         self.state_store.persist(state)
         return {
             "npc_id": npc_id,
             "location": location,
         }
 
+    def _safe_modify_resources(
+        self,
+        *,
+        amount: int,
+        cause: str,
+    ) -> Dict[str, Any]:
+        state = self.state_store.snapshot()
+        manager = MetricManager(state, log_sink=self._metric_log_sink())
+        value = manager.modify_resources(amount, cause=cause)
+        self.state_store.persist(state)
+        return {"resources": value}
+
+    def _safe_adjust_metric(
+        self,
+        *,
+        metric: str,
+        delta: int,
+        cause: str,
+    ) -> Dict[str, Any]:
+        state = self.state_store.snapshot()
+        manager = MetricManager(state, log_sink=self._metric_log_sink())
+        value = manager.adjust_metric(metric, delta, cause=cause)
+        self.state_store.persist(state)
+        return {metric: value}
+
     def _safe_adjust_logic(self) -> Dict[str, Any]:
         return self._adjust_score("logic_score", 1)
 
     def _safe_adjust_emotion(self) -> Dict[str, Any]:
         return self._adjust_score("emotion_score", 1)
 
     def _safe_raise_corruption(self) -> Dict[str, Any]:
         return self._adjust_score("corruption", 1)
 
     def _safe_advance_turn(self) -> Dict[str, Any]:
         state = self.state_store.snapshot()
         previous_turn = state.get("current_turn")
         if not isinstance(previous_turn, int):
             previous_turn = int(state.get("turn", 0))
         next_turn = previous_turn + 1
         state["current_turn"] = next_turn
         state["turn"] = max(int(state.get("turn", next_turn)), next_turn)
         self.state_store.persist(state)
         return {"current_turn": state["current_turn"], "turn": state["turn"]}
 
     def _adjust_score(self, key: str, delta: int) -> Dict[str, Any]:
         state = self.state_store.snapshot()
         scores = state.setdefault("scores", {})
         current_value = scores.get(key, 0)
         try:
             current_value = int(current_value)
         except (TypeError, ValueError):
             current_value = 0
         scores[key] = current_value + delta
         self.state_store.persist(state)
         return {"scores": dict(scores)}
 
+    def _metric_log_sink(self) -> List[Dict[str, Any]]:
+        buffer = getattr(self, "_metric_log_buffer", None)
+        if buffer is None:
+            buffer = []
+            self._metric_log_buffer = buffer
+        return buffer
+
     def _execute_safe_function_queue(
         self,
         *,
         event_output: Dict[str, Any],
         character_output: List[Dict[str, Any]],
     ) -> List[Dict[str, Any]]:
         """Execute any safe function requests emitted by agents."""
 
         calls = self._collect_safe_function_calls(
             event_output=event_output,
             character_output=character_output,
         )
         results: List[Dict[str, Any]] = []
         for payload, metadata in calls:
             outcome = self.run_safe_function(payload, metadata=metadata)
             results.append(
                 {
                     "name": payload["name"],
                     "result": outcome,
                     "metadata": metadata,
                 }
             )
         return results
 
     def _collect_safe_function_calls(
@@ -1106,50 +1260,80 @@ class Orchestrator:
             ),
             f"Recent events: {self._format_recent_events(state)}",
             f"Recent motifs: {recent_motifs}",
             f"Recent major events: {recent_major}",
             (
                 "Relationship summary: {text}".format(
                     text=state.get(
                         "relationship_summary",
                         RELATIONSHIP_SUMMARY_DEFAULT,
                     )
                 )
             ),
             (
                 "Character summary: {text}".format(
                     text=state.get("character_summary", "").strip()
                 )
             ),
             (
                 "Metrics: {payload}".format(
                     payload=json.dumps(metrics, ensure_ascii=False)
                 )
             ),
         ]
         return "\n".join(part for part in sections if part)
 
+    def _compose_turn_narrative(
+        self,
+        *,
+        turn: int,
+        choice: Dict[str, Any],
+        character_output: List[Dict[str, Any]],
+        glitch_effects: List[str],
+    ) -> str:
+        """Generate a compact textual summary for the turn result."""
+
+        if not isinstance(choice, dict):
+            choice = {}
+        choice_text = str(choice.get("text", "")).strip()
+        reaction_text = ""
+        if character_output:
+            primary = character_output[0]
+            if isinstance(primary, dict):
+                reaction_text = str(primary.get("speech") or primary.get("action") or "").strip()
+        glitch_text = ""
+        if glitch_effects:
+            glitch_text = str(glitch_effects[0]).strip()
+        parts = [
+            f"Turn {turn}",
+            choice_text,
+            reaction_text,
+            glitch_text,
+        ]
+        narrative = " | ".join(part for part in parts if part)
+        return narrative[:240]
+
     @staticmethod
     def _format_recent_events(state: Dict[str, Any]) -> str:
         events = state.get("recent_events") or []
         if not events:
             return "none"
         trimmed = [
             event for event in events[-3:] if isinstance(event, str) and event.strip()
         ]
         return "; ".join(trimmed) if trimmed else "none"
 
     @staticmethod
     def _derive_major_event_flag(state: Dict[str, Any]) -> str:
         flags = state.get("flags") or []
         if "mystery_figure" in flags:
             return "major_mystery_investigation"
         return "major_wall_alert"
 
     @staticmethod
     def _format_major_event_summary(
         effect: Optional[Dict[str, Any]],
     ) -> Optional[str]:
         if not effect:
             return None
         status = effect.get("status_change", {})
         status_label = status.get("status", "unknown")
@@ -1157,25 +1341,76 @@ class Orchestrator:
         target = effect.get("applied_to", "unknown")
         flag = effect.get("applied_flag", "major_event")
 
         return f"{flag} -> {target} ({status_label}, {duration} turns)"
 
     @staticmethod
     def _infer_primary_npc_name(state: Dict[str, Any]) -> str:
         summary = state.get("character_summary", "")
         if summary:
             first_word = summary.split()[0].strip(",.;:")
             if first_word:
                 return first_word
         return "Rhea"
 
     @staticmethod
     def _stringify(payload: Any) -> str:
         """Render payloads for logging without raising serialization errors."""
 
         try:
             text = json.dumps(payload, ensure_ascii=False, sort_keys=True)
         except (TypeError, ValueError):
             text = str(payload)
         if len(text) > 600:
             return text[:597] + "..."
         return text
+
+
+def simulate(n_turns: int = 3, seed: int = 123) -> None:
+    """Run a deterministic mini-simulation and print each turn result."""
+
+    orchestrator = Orchestrator.build_default()
+    baseline = deepcopy(DEFAULT_WORLD_STATE)
+    baseline["rng_seed"] = seed
+    baseline["turn"] = 0
+    baseline["current_turn"] = 0
+    MetricManager(baseline, log_sink=[])
+    orchestrator.state_store.persist(baseline)
+
+    for turn_index in range(n_turns):
+        result = orchestrator.run_turn()
+        print(json.dumps(result, indent=2, ensure_ascii=False))
+        status = result.get("win_loss", {}).get("status", "ongoing")
+        if status != "ongoing":
+            break
+        if turn_index == 0:
+            orchestrator.run_safe_function(
+                {
+                    "name": "adjust_metric",
+                    "kwargs": {
+                        "metric": "order",
+                        "delta": 15,
+                        "cause": "demo_order_boost",
+                    },
+                }
+            )
+            orchestrator.run_safe_function(
+                {
+                    "name": "adjust_metric",
+                    "kwargs": {
+                        "metric": "morale",
+                        "delta": 18,
+                        "cause": "demo_morale_boost",
+                    },
+                }
+            )
+        if turn_index == 1:
+            orchestrator.run_safe_function(
+                {
+                    "name": "adjust_metric",
+                    "kwargs": {
+                        "metric": "glitch",
+                        "delta": -10,
+                        "cause": "demo_glitch_stabilisation",
+                    },
+                }
+            )
diff --git a/tests/test_safe_functions.py b/tests/test_safe_functions.py
index 5af8b826afa3e52eb23c48606c6a906704f8fba3..53759ff33af000068b109e417a39b9ae9d6f0d6c 100644
--- a/tests/test_safe_functions.py
+++ b/tests/test_safe_functions.py
@@ -88,50 +88,72 @@ def test_spawn_item_targets_location(tmp_path: Path) -> None:
     orchestrator.run_safe_function(
         {
             "name": "spawn_item",
             "kwargs": {"item_id": "ballista", "target": "tower_east"},
         }
     )
 
     state = orchestrator.state_store.snapshot()
     assert state["items"]["tower_east"] == ["ballista"]
 
 
 def test_move_npc_tracks_location(tmp_path: Path) -> None:
     orchestrator = _make_orchestrator(tmp_path)
 
     orchestrator.run_safe_function(
         {
             "name": "move_npc",
             "kwargs": {"npc_id": "rhea", "location": "wall_tower"},
         }
     )
 
     state = orchestrator.state_store.snapshot()
     assert state["npc_locations"]["rhea"] == "wall_tower"
 
 
+def test_modify_resources_and_adjust_metric(tmp_path: Path) -> None:
+    orchestrator = _make_orchestrator(tmp_path)
+
+    orchestrator.run_safe_function(
+        {
+            "name": "modify_resources",
+            "kwargs": {"amount": -5, "cause": "test_consumption"},
+        }
+    )
+    orchestrator.run_safe_function(
+        {
+            "name": "adjust_metric",
+            "kwargs": {"metric": "order", "delta": 7, "cause": "test_boost"},
+        }
+    )
+
+    state = orchestrator.state_store.snapshot()
+    metrics = state["metrics"]
+    assert metrics["resources"] == 35
+    assert metrics["order"] == 57
+
+
 def test_safe_function_failure_rolls_back_state(tmp_path: Path) -> None:
     orchestrator = _make_orchestrator(tmp_path)
 
     def _boom_validator(call: FunctionCall) -> FunctionCall:
         if call.args or call.kwargs:
             raise FunctionValidationError("boom expects no arguments")
         return call
 
     def _boom_function() -> Dict[str, Any]:
         state = orchestrator.state_store.snapshot()
         state.setdefault("metrics", {})["risk_applied_total"] = 999
         orchestrator.state_store.persist(state)
         raise RuntimeError("boom")
 
     orchestrator.register_safe_function(
         "boom",
         _boom_function,
         validator=_boom_validator,
     )
 
     before = orchestrator.state_store.snapshot()
 
     with pytest.raises(RuntimeError):
         orchestrator.run_safe_function({"name": "boom", "kwargs": {}})
 
@@ -220,31 +242,39 @@ def test_run_turn_executes_agent_safe_functions(tmp_path: Path) -> None:
     orchestrator.world_agent = StubWorldAgent()
     orchestrator.character_agent = StubCharacterAgent()
     orchestrator.judge_agent = None
     orchestrator.rules_engine = StubRulesEngine()
     orchestrator.function_registry = SafeFunctionRegistry()
     orchestrator.function_validator = FunctionCallValidator(
         orchestrator.function_registry,
         max_calls_per_function=5,
         max_total_calls=10,
     )
     orchestrator.rollback_system = RollbackSystem(
         snapshot_provider=store.snapshot,
         restore_callback=store.persist,
         max_checkpoints=5,
     )
     orchestrator._register_default_safe_functions()
 
     result = orchestrator.run_turn()
 
     safe_results = result.get("safe_function_results", [])
     assert {entry["name"] for entry in safe_results} == {
         "change_weather",
         "spawn_item",
     }
 
+    assert "metrics_after" in result
+    assert "glitch" in result
+    assert "logs" in result
+    assert "win_loss" in result
+    assert "narrative" in result
+    assert isinstance(result["metrics_after"]["order"], int)
+    assert result["glitch"]["effects"]
+
     state = orchestrator.state_store.snapshot()
     constraint = state["world_constraint_from_prev_turn"]
     assert constraint["atmosphere"] == "storm glare"
     assert constraint["sensory_details"] == "hail rattles the stones"
     assert "bolt_crate" in state["player"]["inventory"]
     assert not orchestrator.rollback_system.has_checkpoints()
diff --git a/utils/glitch_manager.py b/utils/glitch_manager.py
new file mode 100644
index 0000000000000000000000000000000000000000..bfa5ad22ad3756307ac850da43d618f5b034163f
--- /dev/null
+++ b/utils/glitch_manager.py
@@ -0,0 +1,70 @@
+"""Deterministic glitch propagation utilities."""
+
+from __future__ import annotations
+
+import hashlib
+from dataclasses import dataclass
+from typing import Dict, List
+
+from utils.metrics_manager import MetricManager
+
+
+@dataclass
+class GlitchManager:
+    """Compute glitch rolls and apply deterministic side-effects."""
+
+    seed: int = 0
+
+    def resolve_turn(
+        self,
+        *,
+        metrics: MetricManager,
+        turn: int,
+    ) -> Dict[str, object]:
+        """Roll glitch severity and mutate metrics accordingly."""
+
+        current_glitch = metrics.value("glitch")
+        roll = self._deterministic_roll(turn=turn, glitch=current_glitch)
+        effects: List[str] = []
+        triggered_loss = False
+
+        if roll <= 30:
+            effects.append("Minor static ripples along the parapets.")
+            metrics.adjust_metric("glitch", 1, cause="glitch:cosmetic_noise")
+        elif roll <= 60:
+            effects.append("Pathfinding errors unsettle the patrol routes.")
+            metrics.apply_bulk(
+                (
+                    ("order", -3, "glitch:medium_anomaly"),
+                    ("morale", -2, "glitch:medium_anomaly"),
+                    ("glitch", 4, "glitch:medium_anomaly"),
+                )
+            )
+        elif roll < 85:
+            effects.append("Major anomaly distorts the western wall segment.")
+            metrics.apply_bulk(
+                (
+                    ("resources", -6, "glitch:major_anomaly"),
+                    ("knowledge", -5, "glitch:major_anomaly"),
+                    ("glitch", 6, "glitch:major_anomaly"),
+                )
+            )
+        else:
+            effects.append("Glitch cascade overwhelms containment protocols.")
+            metrics.adjust_metric("glitch", 15, cause="glitch:overload")
+            triggered_loss = True
+
+        return {
+            "roll": roll,
+            "effects": effects,
+            "triggered_loss": triggered_loss,
+        }
+
+    # ------------------------------------------------------------------
+    # Internal helpers
+    # ------------------------------------------------------------------
+    def _deterministic_roll(self, *, turn: int, glitch: int) -> int:
+        payload = f"{self.seed}:{turn}:{glitch}".encode("utf-8")
+        digest = hashlib.sha256(payload).digest()
+        return int.from_bytes(digest[:4], "big") % 101
+
diff --git a/utils/metrics_manager.py b/utils/metrics_manager.py
new file mode 100644
index 0000000000000000000000000000000000000000..4ba8d2a2f7deb6f960328fdb42ec9c8a058836c1
--- /dev/null
+++ b/utils/metrics_manager.py
@@ -0,0 +1,131 @@
+"""Metric management utilities for deterministic turn processing."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from typing import Any, Dict, Iterable, List, MutableMapping, Optional
+
+
+MetricDict = MutableMapping[str, Any]
+
+
+@dataclass
+class MetricManager:
+    """Centralised helper responsible for metric mutation and logging."""
+
+    state: Dict[str, Any]
+    log_sink: Optional[List[Dict[str, Any]]] = None
+    _metrics: MetricDict = field(init=False, repr=False)
+
+    #: Core gameplay metrics with their default starting values.
+    CORE_DEFAULTS: Dict[str, int] = field(
+        default_factory=lambda: {
+            "order": 50,
+            "morale": 50,
+            "resources": 40,
+            "knowledge": 45,
+            "corruption": 10,
+            "glitch": 12,
+        }
+    )
+
+    #: Legacy counters preserved for backwards compatibility.
+    LEGACY_DEFAULTS: Dict[str, int] = field(
+        default_factory=lambda: {
+            "risk_applied_total": 0,
+            "major_flag_set": False,
+            "major_events_triggered": 0,
+            "major_event_last_turn": None,
+        }
+    )
+
+    #: Clamp boundaries for each mutable metric.
+    LIMITS: Dict[str, tuple[int, int]] = field(
+        default_factory=lambda: {
+            "order": (0, 100),
+            "morale": (0, 100),
+            "resources": (0, 120),
+            "knowledge": (0, 100),
+            "corruption": (0, 100),
+            "glitch": (0, 100),
+        }
+    )
+
+    def __post_init__(self) -> None:
+        metrics = self.state.setdefault("metrics", {})
+        for key, value in self.CORE_DEFAULTS.items():
+            metrics.setdefault(key, value)
+        for key, value in self.LEGACY_DEFAULTS.items():
+            metrics.setdefault(key, value)
+        self._metrics = metrics
+        if self.log_sink is None:
+            # Stand-alone operations fall back to per-state rolling log list.
+            self.log_sink = metrics.setdefault("_log_buffer", [])
+
+    # ------------------------------------------------------------------
+    # Public helpers
+    # ------------------------------------------------------------------
+    def snapshot(self, *, include_legacy: bool = True) -> Dict[str, Any]:
+        """Return a shallow copy of the managed metrics."""
+
+        if include_legacy:
+            keys: Iterable[str] = self._metrics.keys()
+        else:
+            keys = self.CORE_DEFAULTS.keys()
+        snapshot: Dict[str, Any] = {}
+        for key in keys:
+            if isinstance(key, str) and key.startswith("_"):
+                continue
+            snapshot[key] = self._metrics.get(key)
+        return snapshot
+
+    def value(self, metric: str) -> int:
+        """Fetch the current value for *metric* (defaults to zero)."""
+
+        raw = self._metrics.get(metric, 0)
+        try:
+            return int(raw)
+        except (TypeError, ValueError):
+            return 0
+
+    def adjust_metric(self, metric: str, delta: int, *, cause: str) -> int:
+        """Apply *delta* to *metric* and return the clamped result."""
+
+        if not metric:
+            raise ValueError("metric name is required")
+
+        current = self.value(metric)
+        limit = self.LIMITS.get(metric, (0, 9999))
+        updated = self._clamp(current + int(delta), limit)
+        self._metrics[metric] = updated
+        self._log_change(metric, updated - current, updated, cause)
+        return updated
+
+    def modify_resources(self, amount: int, *, cause: str) -> int:
+        """Adjust resources by *amount* (alias for :meth:`adjust_metric`)."""
+
+        return self.adjust_metric("resources", int(amount), cause=cause)
+
+    def apply_bulk(self, changes: Iterable[tuple[str, int, str]]) -> None:
+        """Apply a batch of metric updates."""
+
+        for metric, delta, cause in changes:
+            self.adjust_metric(metric, delta, cause=cause)
+
+    # ------------------------------------------------------------------
+    # Internal utilities
+    # ------------------------------------------------------------------
+    def _clamp(self, value: int, limit: tuple[int, int]) -> int:
+        lower, upper = limit
+        return max(lower, min(upper, value))
+
+    def _log_change(self, metric: str, delta: int, value: int, cause: str) -> None:
+        entry = {
+            "metric": metric,
+            "delta": delta,
+            "value": value,
+            "cause": cause,
+        }
+        if isinstance(self.log_sink, list):
+            self.log_sink.append(entry)
+
diff --git a/utils/output_validator.py b/utils/output_validator.py
index cfe68c2c02bee9fdfb839a880c97dd9d7d1a52aa..0ec4d04b45f56cb8e5056d164087a28d7f3488d4 100644
--- a/utils/output_validator.py
+++ b/utils/output_validator.py
@@ -48,51 +48,61 @@ def _validate_character_reactions(reactions: List[Dict[str, Any]]) -> None:
         _require_keys(
             reaction,
             keys=("name", "intent", "action", "speech"),
             context=context,
         )
         for key in ("name", "intent", "action", "speech"):
             if not isinstance(reaction.get(key), str):
                 message = f"{context} field '{key}' must be a string"
                 raise OutputValidationError(message)
         effects = reaction.get("effects", {})
         if effects is None:
             continue
         if not isinstance(effects, dict):
             message = f"{context} effects must be an object if present"
             raise OutputValidationError(message)
 
 
 def validate_turn_output(payload: Dict[str, Any]) -> None:
     """Validate the structure of the orchestrator turn output."""
 
     if not isinstance(payload, dict):
         raise OutputValidationError("Turn output must be a JSON object")
 
     _require_keys(
         payload,
-        keys=("world", "event", "player_choice", "character_reactions"),
+        keys=(
+            "world",
+            "event",
+            "player_choice",
+            "character_reactions",
+            "metrics_after",
+            "glitch",
+            "logs",
+            "win_loss",
+            "narrative",
+        ),
         context="root payload",
     )
 
     world = payload["world"]
     _assert_type(world, dict, context="world")
     _require_keys(
         world,
         keys=("atmosphere", "sensory_details"),
         context="world",
     )
     world_strings = all(
         isinstance(world[key], str) for key in ("atmosphere", "sensory_details")
     )
     if not world_strings:
         raise OutputValidationError("World fields must be strings")
 
     event = payload["event"]
     _assert_type(event, dict, context="event")
     _require_keys(
         event,
         keys=("scene", "options", "major_event"),
         context="event",
     )
     if not isinstance(event["scene"], str):
         raise OutputValidationError("Event scene must be a string")
@@ -112,25 +122,80 @@ def validate_turn_output(payload: Dict[str, Any]) -> None:
 
     player_choice = payload["player_choice"]
     _assert_type(player_choice, dict, context="player_choice")
     _require_keys(
         player_choice,
         keys=("id", "text", "action_type"),
         context="player_choice",
     )
     choice_strings = all(
         isinstance(player_choice[key], str) and player_choice[key].strip()
         for key in ("id", "text", "action_type")
     )
     if not choice_strings:
         raise OutputValidationError("Player choice fields must be non-empty strings")
 
     reactions = payload["character_reactions"]
     _assert_type(reactions, list, context="character_reactions")
     _validate_character_reactions(reactions)
 
     warnings = payload.get("warnings")
     if warnings is not None:
         _assert_type(warnings, list, context="warnings")
         for warning in warnings:
             if not isinstance(warning, str):
                 raise OutputValidationError("Warnings must be strings")
+
+    metrics_after = payload["metrics_after"]
+    _assert_type(metrics_after, dict, context="metrics_after")
+    required_metrics = (
+        "order",
+        "morale",
+        "resources",
+        "knowledge",
+        "corruption",
+        "glitch",
+    )
+    for metric in required_metrics:
+        if metric not in metrics_after:
+            raise OutputValidationError(f"metrics_after missing '{metric}'")
+        value = metrics_after[metric]
+        if not isinstance(value, int):
+            raise OutputValidationError(
+                f"metrics_after['{metric}'] must be an integer"
+            )
+
+    glitch = payload["glitch"]
+    _assert_type(glitch, dict, context="glitch")
+    _require_keys(glitch, keys=("roll", "effects"), context="glitch")
+    if not isinstance(glitch["roll"], int):
+        raise OutputValidationError("glitch.roll must be an integer")
+    effects = glitch["effects"]
+    _assert_type(effects, list, context="glitch effects")
+    for effect in effects:
+        if not isinstance(effect, str):
+            raise OutputValidationError("glitch effects must be strings")
+
+    logs = payload["logs"]
+    _assert_type(logs, list, context="logs")
+    for entry in logs:
+        if not isinstance(entry, dict):
+            raise OutputValidationError("log entries must be objects")
+        _require_keys(
+            entry,
+            keys=("metric", "delta", "value", "cause"),
+            context="log entry",
+        )
+
+    win_loss = payload["win_loss"]
+    _assert_type(win_loss, dict, context="win_loss")
+    _require_keys(win_loss, keys=("status", "reason"), context="win_loss")
+    status = win_loss["status"]
+    if status not in {"ongoing", "win", "loss"}:
+        raise OutputValidationError("win_loss.status must be ongoing, win, or loss")
+    for key in ("status", "reason"):
+        if not isinstance(win_loss[key], str):
+            raise OutputValidationError(f"win_loss.{key} must be a string")
+
+    narrative = payload["narrative"]
+    if not isinstance(narrative, str):
+        raise OutputValidationError("narrative must be a string")
 
EOF
)
