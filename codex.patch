 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/agents/judge_agent.py b/agents/judge_agent.py
index 741e29e9d3f7306801c08179d74f84cd14493ae5..0abc3e37997a1b979fc603a0dccbbbbc902ef388 100644
--- a/agents/judge_agent.py
+++ b/agents/judge_agent.py
@@ -1,94 +1,5 @@
-from __future__ import annotations
-import logging
+"""Compatibility wrapper for the Fortress Director judge agent."""
 
-"""Judge Agent implementation providing lore consistency checks."""
-from typing import Any, Dict, Optional
+from fortress_director.agents.judge_agent import JudgeAgent, check_win_loss
 
-from agents.base_agent import (
-    AgentOutputError,
-    BaseAgent,
-    PromptTemplate,
-    build_prompt_path,
-    default_ollama_client,
-    get_model_config,
-)
-from llm.ollama_client import OllamaClient
-
-
-class JudgeAgent(BaseAgent):
-    LOGGER = logging.getLogger(__name__)
-    """Validates narrative content against established lore."""
-
-    def __init__(
-        self, *, client: Optional[OllamaClient] = None, tolerance: int = 0
-    ) -> None:
-        self.tolerance = tolerance
-        template = PromptTemplate(build_prompt_path("judge_prompt.txt"))
-        super().__init__(
-            name="Judge",
-            prompt_template=template,
-            model_config=get_model_config("judge"),
-            client=client or default_ollama_client("judge"),
-        )
-
-    def evaluate(self, variables: Dict[str, Any]) -> Dict[str, Any]:
-        """Return lore consistency verdict for supplied content. Logs every step."""
-        variables = dict(variables)
-        variables["tolerance"] = self.tolerance
-        self.LOGGER.info("JudgeAgent.evaluate called with variables: %s", variables)
-        try:
-            result = self.run(variables=variables)
-            self.LOGGER.debug("Model returned: %s", result)
-            if not isinstance(result, dict):
-                self.LOGGER.error(
-                    "Judge agent must return a JSON object, got: %s", result
-                )
-                raise AgentOutputError("Judge agent must return a JSON object")
-            self.LOGGER.info("Judge verdict: %s", result)
-            return result
-        except Exception as exc:
-            self.LOGGER.error(
-                "Exception in JudgeAgent.evaluate: %s", exc, exc_info=True
-            )
-            raise
-
-
-def check_win_loss(
-    metrics: Dict[str, Any],
-    *,
-    turn: int,
-    turn_limit: int,
-) -> Dict[str, str]:
-    """Evaluate win/loss state using supplied metrics."""
-
-    def _as_int(value: Any, default: int = 0) -> int:
-        try:
-            return int(value)
-        except (TypeError, ValueError):
-            return default
-
-    order = _as_int(metrics.get("order"), 0)
-    morale = _as_int(metrics.get("morale"), 0)
-    resources = _as_int(metrics.get("resources"), 0)
-    glitch = _as_int(metrics.get("glitch"), 0)
-
-    status = "ongoing"
-    reason = "thresholds_not_met"
-
-    if order >= 70 and morale >= 70 and glitch <= 30:
-        status = "win"
-        reason = "fortress_stabilized"
-    elif order <= 20:
-        status = "loss"
-        reason = "order_collapse"
-    elif resources <= 0:
-        status = "loss"
-        reason = "resources_depleted"
-    elif glitch >= 85:
-        status = "loss"
-        reason = "glitch_overload"
-    elif turn >= max(1, turn_limit):
-        status = "loss"
-        reason = "turn_limit_reached"
-
-    return {"status": status, "reason": reason}
+__all__ = ["JudgeAgent", "check_win_loss"]
diff --git a/cli.py b/cli.py
index 115f81d320712a43960ddb67ea43c4c6770000f6..4ebad0128c12f7b7c8ab383267d1d8aa0a9575e7 100644
--- a/cli.py
+++ b/cli.py
@@ -1,37 +1,39 @@
 """Command-line entry point for running Fortress Director locally."""
 
 from __future__ import annotations
 
 import argparse
 import json
 import logging
+import shutil
 import sys
 from datetime import datetime
 from pathlib import Path
-from typing import Any, Callable, Dict, cast
+from typing import Any, Callable, Dict, List, cast
 
+from fortress_director.utils.logging_config import configure_logging
 from orchestrator.orchestrator import (
     DEFAULT_WORLD_STATE,
     Orchestrator,
     StateStore,
 )
 from settings import SETTINGS
 
 
 def _print_json(data: Dict[str, Any]) -> None:
     """Pretty-print JSON to stdout."""
 
     text = json.dumps(data, indent=2, ensure_ascii=False)
     sys.stdout.write(f"{text}\n")
 
 
 def _parse_json_argument(raw: str | None, expected: type, label: str) -> Any:
     if raw is None:
         return None
     try:
         data = json.loads(raw)
     except json.JSONDecodeError as exc:
         raise ValueError(f"{label} must be valid JSON: {exc}") from exc
     if not isinstance(data, expected):
         raise ValueError(f"{label} must decode to {expected.__name__}")
     return data
@@ -71,61 +73,76 @@ def _handle_safe_call(args: argparse.Namespace) -> None:
             "--metadata",
         )
     except ValueError as exc:
         sys.stderr.write(f"{exc}\n")
         sys.exit(2)
 
     payload: Dict[str, Any] = {"name": args.name}
     if args_payload is not None:
         payload["args"] = args_payload
     if kwargs_payload is not None:
         payload["kwargs"] = kwargs_payload
     if metadata is not None:
         payload["metadata"] = metadata
 
     try:
         result = orchestrator.run_safe_function(payload, metadata=metadata)
     except Exception as exc:  # pragma: no cover - surface to CLI user
         sys.stderr.write(f"Safe function call failed: {exc}\n")
         sys.exit(1)
 
     formatted = result if isinstance(result, dict) else {"result": result}
     _print_json(formatted)
 
 
 def _handle_run(args: argparse.Namespace) -> None:
-    result = _run_turn(args.choice_id)
-    reactions = result.get("character_reactions", [])
-    for reaction in reactions:
-        effects = reaction.get("effects") or {}
-        if effects:
-            label = reaction.get("name", "unknown")
-            sys.stdout.write(f"Effect summary [{label}]: {effects}\n")
-    major_summary = result.get("major_event_effect_summary")
-    if major_summary:
-        sys.stdout.write(f"Major event impact: {major_summary}\n")
-    _print_json(result)
+    turns = max(1, getattr(args, "turns", 1))
+    run_dir = SETTINGS.project_root / "runs" / "latest_run"
+    if run_dir.exists():
+        shutil.rmtree(run_dir)
+    run_dir.mkdir(parents=True, exist_ok=True)
+
+    results: List[Dict[str, Any]] = []
+    for turn_index in range(turns):
+        result = _run_turn(args.choice_id)
+        results.append(result)
+        reactions = result.get("character_reactions", [])
+        for reaction in reactions:
+            effects = reaction.get("effects") or {}
+            if effects:
+                label = reaction.get("name", "unknown")
+                sys.stdout.write(f"Effect summary [{label}]: {effects}\n")
+        major_summary = result.get("major_event_effect_summary")
+        if major_summary:
+            sys.stdout.write(f"Major event impact: {major_summary}\n")
+        _print_json(result)
+        output_path = run_dir / f"turn_{turn_index + 1:03d}.json"
+        output_path.write_text(json.dumps(result, indent=2), encoding="utf-8")
+
+    log_path = SETTINGS.log_dir / "fortress_run.log"
+    if log_path.exists():
+        shutil.copy2(log_path, run_dir / "fortress_run.log")
 
 
 def _handle_debug(_args: argparse.Namespace) -> None:
     summary = _debug_state()
     _print_json(summary)
 
 
 def _handle_reset(_args: argparse.Namespace) -> None:
     _reset_state()
     sys.stdout.write("World state reset to defaults.\n")
 
 
 def _normalise_log_level(level_name: str) -> int:
     candidate = (level_name or "INFO").upper()
     level = getattr(logging, candidate, None)
     if isinstance(level, int):
         return level
     return logging.INFO
 
 
 def _prepare_log_file(filename: str | None) -> Path:
     SETTINGS.log_dir.mkdir(parents=True, exist_ok=True)
     if filename:
         path = Path(filename)
         if not path.is_absolute():
@@ -138,110 +155,104 @@ def _prepare_log_file(filename: str | None) -> Path:
 
 def build_parser() -> argparse.ArgumentParser:
     parser = argparse.ArgumentParser(
         description="Fortress Director CLI",
     )
     parser.add_argument(
         "--log-level",
         default="INFO",
         help="Console log level (default: INFO)",
     )
     parser.add_argument(
         "--log-file",
         help="Optional log filename stored under the logs directory",
     )
     subparsers = parser.add_subparsers(dest="command", required=True)
 
     run_parser = subparsers.add_parser(
         "run_turn",
         help="Execute one deterministic game turn",
     )
     run_parser.add_argument(
         "--choice-id",
         dest="choice_id",
         help="ID of the player option to commit (defaults to first option)",
     )
+    run_parser.add_argument(
+        "--turns",
+        type=int,
+        default=1,
+        help="Number of sequential turns to execute (default: 1)",
+    )
     run_parser.set_defaults(handler=_handle_run)
 
     debug_parser = subparsers.add_parser(
         "debug_state",
         help="Print a summary of the persisted world state",
     )
     debug_parser.set_defaults(handler=_handle_debug)
 
     reset_parser = subparsers.add_parser(
         "reset",
         help="Reset world_state.json to its default payload",
     )
     reset_parser.set_defaults(handler=_handle_reset)
 
     safe_parser = subparsers.add_parser(
         "safe_call",
         help="Execute a registered safe function",
     )
     safe_parser.add_argument(
         "name",
         help="Name of the safe function to invoke",
     )
     safe_parser.add_argument(
         "--args",
         dest="args_json",
         help="Optional JSON array of positional arguments",
     )
     safe_parser.add_argument(
         "--kwargs",
         dest="kwargs_json",
         help="Optional JSON object of keyword arguments",
     )
     safe_parser.add_argument(
         "--metadata",
         dest="metadata_json",
         help="Optional JSON object stored alongside the checkpoint",
     )
     safe_parser.set_defaults(handler=_handle_safe_call)
 
     return parser
 
 
 def _configure_logging(level_name: str, log_file: str | None) -> Path:
     log_path = _prepare_log_file(log_file)
-    root = logging.getLogger()
-    for handler in list(root.handlers):
-        root.removeHandler(handler)
-        handler.close()
-
-    root.setLevel(logging.DEBUG)
-    formatter = logging.Formatter("%(asctime)s [%(levelname)s] %(name)s: %(message)s")
-
     console_level = _normalise_log_level(level_name)
-    console_handler = logging.StreamHandler()
-    console_handler.setLevel(console_level)
-    console_handler.setFormatter(formatter)
-    root.addHandler(console_handler)
-
-    file_handler = logging.FileHandler(log_path, encoding="utf-8")
-    file_handler.setLevel(logging.DEBUG)
-    file_handler.setFormatter(formatter)
-    root.addHandler(file_handler)
-
-    root.debug(
-        "Logging configured (console level=%s, file=%s)",
+    configure_logging(
+        console_level=console_level,
+        file_level=logging.DEBUG,
+        log_path=log_path,
+        force=True,
+    )
+    logging.getLogger(__name__).debug(
+        "Logging configured via CLI (console level=%s, path=%s)",
         logging.getLevelName(console_level),
         log_path,
     )
     return log_path
 
 
 def main(argv: list[str] | None = None) -> None:
     parser = build_parser()
     args = parser.parse_args(argv)
     log_path = _configure_logging(args.log_level, args.log_file)
     logging.getLogger(__name__).info("Detailed logs written to %s", log_path)
     handler = cast(
         Callable[[argparse.Namespace], None],
         getattr(args, "handler"),
     )
     handler(args)
 
 
 if __name__ == "__main__":
     main()
diff --git a/fortress_director/agents/judge_agent.py b/fortress_director/agents/judge_agent.py
index 860d163ac09b6c8b5f836fc51fedef2648848f71..f0e088900bda2222f4b0c8906ac589a59e8927b3 100644
--- a/fortress_director/agents/judge_agent.py
+++ b/fortress_director/agents/judge_agent.py
@@ -1,95 +1,107 @@
 from __future__ import annotations
 
 import logging
 
 """Judge Agent implementation providing lore consistency checks."""
 from typing import Any, Dict, Optional
 
 from fortress_director.agents.base_agent import (
     AgentOutputError,
     BaseAgent,
     PromptTemplate,
     build_prompt_path,
     default_ollama_client,
     get_model_config,
 )
 from fortress_director.llm.ollama_client import OllamaClient
 
 
+LOGGER = logging.getLogger(__name__)
+
+
 class JudgeAgent(BaseAgent):
-    LOGGER = logging.getLogger(__name__)
+    LOGGER = LOGGER
     """Validates narrative content against established lore."""
 
     def __init__(
         self, *, client: Optional[OllamaClient] = None, tolerance: int = 0
     ) -> None:
         self.tolerance = tolerance
         template = PromptTemplate(build_prompt_path("judge_prompt.txt"))
         super().__init__(
             name="Judge",
             prompt_template=template,
             model_config=get_model_config("judge"),
             client=client or default_ollama_client("judge"),
         )
 
     def evaluate(self, variables: Dict[str, Any]) -> Dict[str, Any]:
         """Return lore consistency verdict for supplied content. Logs every step."""
         variables = dict(variables)
         variables["tolerance"] = self.tolerance
         self.LOGGER.info("JudgeAgent.evaluate called with variables: %s", variables)
         try:
             result = self.run(variables=variables)
             self.LOGGER.debug("Model returned: %s", result)
             if not isinstance(result, dict):
                 self.LOGGER.error(
                     "Judge agent must return a JSON object, got: %s", result
                 )
                 raise AgentOutputError("Judge agent must return a JSON object")
             self.LOGGER.info("Judge verdict: %s", result)
             return result
         except Exception as exc:
             self.LOGGER.error(
                 "Exception in JudgeAgent.evaluate: %s", exc, exc_info=True
             )
             raise
 
 
 def check_win_loss(
     metrics: Dict[str, Any],
     *,
     turn: int,
     turn_limit: int,
 ) -> Dict[str, str]:
     """Evaluate win/loss state using supplied metrics."""
 
+    LOGGER.debug(
+        "Evaluating win/loss (turn=%s/%s) with metrics=%s",
+        turn,
+        turn_limit,
+        metrics,
+    )
+
     def _as_int(value: Any, default: int = 0) -> int:
         try:
             return int(value)
         except (TypeError, ValueError):
             return default
 
     order = _as_int(metrics.get("order"), 0)
     morale = _as_int(metrics.get("morale"), 0)
     resources = _as_int(metrics.get("resources"), 0)
     glitch = _as_int(metrics.get("glitch"), 0)
 
     status = "ongoing"
     reason = "thresholds_not_met"
 
     if order >= 70 and morale >= 70 and glitch <= 30:
         status = "win"
         reason = "fortress_stabilized"
     elif order <= 20:
         status = "loss"
         reason = "order_collapse"
     elif resources <= 0:
         status = "loss"
         reason = "resources_depleted"
     elif glitch >= 85:
         status = "loss"
         reason = "glitch_overload"
     elif turn >= max(1, turn_limit):
         status = "loss"
         reason = "turn_limit_reached"
 
-    return {"status": status, "reason": reason}
+    outcome = {"status": status, "reason": reason}
+    LOGGER.info("Win/loss evaluation result: %s", outcome)
+    return outcome
diff --git a/fortress_director/cli.py b/fortress_director/cli.py
index 4373be3278927bd2522d7084077c7d1bf16acae2..b248faa63acb92d63166f075b9b7477181dccddf 100644
--- a/fortress_director/cli.py
+++ b/fortress_director/cli.py
@@ -1,37 +1,39 @@
 """Command-line entry point for running Fortress Director locally."""
 
 from __future__ import annotations
 
 import argparse
 import json
 import logging
+import shutil
 import sys
 from datetime import datetime
 from pathlib import Path
-from typing import Any, Callable, Dict, cast
+from typing import Any, Callable, Dict, List, cast
 
+from fortress_director.utils.logging_config import configure_logging
 from fortress_director.orchestrator.orchestrator import (
     DEFAULT_WORLD_STATE,
     Orchestrator,
     StateStore,
 )
 from fortress_director.settings import SETTINGS
 
 
 def _print_json(data: Dict[str, Any]) -> None:
     """Pretty-print JSON to stdout."""
 
     text = json.dumps(data, indent=2, ensure_ascii=False)
     sys.stdout.write(f"{text}\n")
 
 
 def _parse_json_argument(raw: str | None, expected: type, label: str) -> Any:
     if raw is None:
         return None
     try:
         data = json.loads(raw)
     except json.JSONDecodeError as exc:
         raise ValueError(f"{label} must be valid JSON: {exc}") from exc
     if not isinstance(data, expected):
         raise ValueError(f"{label} must decode to {expected.__name__}")
     return data
@@ -71,61 +73,76 @@ def _handle_safe_call(args: argparse.Namespace) -> None:
             "--metadata",
         )
     except ValueError as exc:
         sys.stderr.write(f"{exc}\n")
         sys.exit(2)
 
     payload: Dict[str, Any] = {"name": args.name}
     if args_payload is not None:
         payload["args"] = args_payload
     if kwargs_payload is not None:
         payload["kwargs"] = kwargs_payload
     if metadata is not None:
         payload["metadata"] = metadata
 
     try:
         result = orchestrator.run_safe_function(payload, metadata=metadata)
     except Exception as exc:  # pragma: no cover - surface to CLI user
         sys.stderr.write(f"Safe function call failed: {exc}\n")
         sys.exit(1)
 
     formatted = result if isinstance(result, dict) else {"result": result}
     _print_json(formatted)
 
 
 def _handle_run(args: argparse.Namespace) -> None:
-    result = _run_turn(args.choice_id)
-    reactions = result.get("character_reactions", [])
-    for reaction in reactions:
-        effects = reaction.get("effects") or {}
-        if effects:
-            label = reaction.get("name", "unknown")
-            sys.stdout.write(f"Effect summary [{label}]: {effects}\n")
-    major_summary = result.get("major_event_effect_summary")
-    if major_summary:
-        sys.stdout.write(f"Major event impact: {major_summary}\n")
-    _print_json(result)
+    turns = max(1, getattr(args, "turns", 1))
+    run_dir = SETTINGS.project_root / "runs" / "latest_run"
+    if run_dir.exists():
+        shutil.rmtree(run_dir)
+    run_dir.mkdir(parents=True, exist_ok=True)
+
+    results: List[Dict[str, Any]] = []
+    for turn_index in range(turns):
+        result = _run_turn(args.choice_id)
+        results.append(result)
+        reactions = result.get("character_reactions", [])
+        for reaction in reactions:
+            effects = reaction.get("effects") or {}
+            if effects:
+                label = reaction.get("name", "unknown")
+                sys.stdout.write(f"Effect summary [{label}]: {effects}\n")
+        major_summary = result.get("major_event_effect_summary")
+        if major_summary:
+            sys.stdout.write(f"Major event impact: {major_summary}\n")
+        _print_json(result)
+        output_path = run_dir / f"turn_{turn_index + 1:03d}.json"
+        output_path.write_text(json.dumps(result, indent=2), encoding="utf-8")
+
+    log_path = SETTINGS.log_dir / "fortress_run.log"
+    if log_path.exists():
+        shutil.copy2(log_path, run_dir / "fortress_run.log")
 
 
 def _handle_debug(_args: argparse.Namespace) -> None:
     summary = _debug_state()
     _print_json(summary)
 
 
 def _handle_reset(_args: argparse.Namespace) -> None:
     _reset_state()
     sys.stdout.write("World state reset to defaults.\n")
 
 
 def _normalise_log_level(level_name: str) -> int:
     candidate = (level_name or "INFO").upper()
     level = getattr(logging, candidate, None)
     if isinstance(level, int):
         return level
     return logging.INFO
 
 
 def _prepare_log_file(filename: str | None) -> Path:
     SETTINGS.log_dir.mkdir(parents=True, exist_ok=True)
     if filename:
         path = Path(filename)
         if not path.is_absolute():
@@ -138,110 +155,104 @@ def _prepare_log_file(filename: str | None) -> Path:
 
 def build_parser() -> argparse.ArgumentParser:
     parser = argparse.ArgumentParser(
         description="Fortress Director CLI",
     )
     parser.add_argument(
         "--log-level",
         default="INFO",
         help="Console log level (default: INFO)",
     )
     parser.add_argument(
         "--log-file",
         help="Optional log filename stored under the logs directory",
     )
     subparsers = parser.add_subparsers(dest="command", required=True)
 
     run_parser = subparsers.add_parser(
         "run_turn",
         help="Execute one deterministic game turn",
     )
     run_parser.add_argument(
         "--choice-id",
         dest="choice_id",
         help="ID of the player option to commit (defaults to first option)",
     )
+    run_parser.add_argument(
+        "--turns",
+        type=int,
+        default=1,
+        help="Number of sequential turns to execute (default: 1)",
+    )
     run_parser.set_defaults(handler=_handle_run)
 
     debug_parser = subparsers.add_parser(
         "debug_state",
         help="Print a summary of the persisted world state",
     )
     debug_parser.set_defaults(handler=_handle_debug)
 
     reset_parser = subparsers.add_parser(
         "reset",
         help="Reset world_state.json to its default payload",
     )
     reset_parser.set_defaults(handler=_handle_reset)
 
     safe_parser = subparsers.add_parser(
         "safe_call",
         help="Execute a registered safe function",
     )
     safe_parser.add_argument(
         "name",
         help="Name of the safe function to invoke",
     )
     safe_parser.add_argument(
         "--args",
         dest="args_json",
         help="Optional JSON array of positional arguments",
     )
     safe_parser.add_argument(
         "--kwargs",
         dest="kwargs_json",
         help="Optional JSON object of keyword arguments",
     )
     safe_parser.add_argument(
         "--metadata",
         dest="metadata_json",
         help="Optional JSON object stored alongside the checkpoint",
     )
     safe_parser.set_defaults(handler=_handle_safe_call)
 
     return parser
 
 
 def _configure_logging(level_name: str, log_file: str | None) -> Path:
     log_path = _prepare_log_file(log_file)
-    root = logging.getLogger()
-    for handler in list(root.handlers):
-        root.removeHandler(handler)
-        handler.close()
-
-    root.setLevel(logging.DEBUG)
-    formatter = logging.Formatter("%(asctime)s [%(levelname)s] %(name)s: %(message)s")
-
     console_level = _normalise_log_level(level_name)
-    console_handler = logging.StreamHandler()
-    console_handler.setLevel(console_level)
-    console_handler.setFormatter(formatter)
-    root.addHandler(console_handler)
-
-    file_handler = logging.FileHandler(log_path, encoding="utf-8")
-    file_handler.setLevel(logging.DEBUG)
-    file_handler.setFormatter(formatter)
-    root.addHandler(file_handler)
-
-    root.debug(
-        "Logging configured (console level=%s, file=%s)",
+    configure_logging(
+        console_level=console_level,
+        file_level=logging.DEBUG,
+        log_path=log_path,
+        force=True,
+    )
+    logging.getLogger(__name__).debug(
+        "Logging configured via CLI (console level=%s, path=%s)",
         logging.getLevelName(console_level),
         log_path,
     )
     return log_path
 
 
 def main(argv: list[str] | None = None) -> None:
     parser = build_parser()
     args = parser.parse_args(argv)
     log_path = _configure_logging(args.log_level, args.log_file)
     logging.getLogger(__name__).info("Detailed logs written to %s", log_path)
     handler = cast(
         Callable[[argparse.Namespace], None],
         getattr(args, "handler"),
     )
     handler(args)
 
 
 if __name__ == "__main__":
     main()
diff --git a/fortress_director/orchestrator/orchestrator.py b/fortress_director/orchestrator/orchestrator.py
index fc9aafa971d65c1729ecd601dee9452f7da6b8dc..bcbed353824754570f16aa57eaf8dc7a2ce12bd2 100644
--- a/fortress_director/orchestrator/orchestrator.py
+++ b/fortress_director/orchestrator/orchestrator.py
@@ -7,52 +7,55 @@ from copy import deepcopy
 from dataclasses import dataclass
 from pathlib import Path
 from typing import Any, Callable, Dict, List, Optional, Tuple
 
 from fortress_director.codeaware.function_validator import FunctionCallValidator
 from fortress_director.codeaware.rollback_system import RollbackSystem
 from fortress_director.utils.output_validator import validate_turn_output
 from fortress_director.settings import DEFAULT_WORLD_STATE
 from fortress_director.agents.character_agent import CharacterAgent
 from fortress_director.agents.event_agent import EventAgent
 from fortress_director.agents.judge_agent import JudgeAgent, check_win_loss
 from fortress_director.agents.world_agent import WorldAgent
 from fortress_director.settings import SETTINGS
 from fortress_director.rules.rules_engine import (
     RulesEngine,
     TierTwoValidationError,
 )
 from fortress_director.codeaware.function_registry import (
     FunctionCall,
     FunctionNotRegisteredError,
     FunctionValidationError,
     SafeFunctionRegistry,
     Validator,
 )
 from fortress_director.utils.glitch_manager import GlitchManager
+from fortress_director.utils.logging_config import configure_logging
 from fortress_director.utils.metrics_manager import MetricManager
 
+configure_logging()
+
 LOGGER = logging.getLogger(__name__)
 
 RELATIONSHIP_SUMMARY_DEFAULT = "No relationship summary available."
 
 
 class StateStore:
     """Lightweight JSON-backed state store."""
 
     def __init__(self, path: Path) -> None:
         self._path = path
         self._state = self._load()
 
     def snapshot(self) -> Dict[str, Any]:
         """Return a deep copy of the current state for safe mutation."""
 
         snapshot = deepcopy(self._state)
         LOGGER.debug(
             "State snapshot loaded from %s (turn=%s)",
             self._path,
             snapshot.get("turn"),
         )
         return snapshot
 
     def persist(self, state: Dict[str, Any]) -> None:
         """Replace current state with provided snapshot and flush to disk."""
@@ -268,79 +271,92 @@ class Orchestrator:
 
         self._metric_log_buffer = []
         glitch_info: Dict[str, Any] = {"roll": 0, "effects": [], "triggered_loss": False}
 
         checkpoint_metadata = {"phase": "turn_start"}
         if player_choice_id:
             checkpoint_metadata["player_choice_id"] = player_choice_id
         LOGGER.debug(
             "Resetting function validator and creating checkpoint: %s",
             checkpoint_metadata,
         )
         self.function_validator.reset()
         self.rollback_system.create_checkpoint(metadata=checkpoint_metadata)
 
         try:
             LOGGER.info("Turn execution started.")
             state_snapshot = self.state_store.snapshot()
             LOGGER.debug(
                 "Pre-turn state snapshot: %s",
                 self._stringify(state_snapshot),
             )
             metric_manager = MetricManager(
                 state_snapshot,
                 log_sink=self._metric_log_sink(),
             )
+            LOGGER.debug(
+                "Metrics at turn start: %s",
+                metric_manager.snapshot(),
+            )
             rng_seed = state_snapshot.get("rng_seed", 0)
             if not isinstance(rng_seed, int):
                 try:
                     rng_seed = int(rng_seed)
                 except (TypeError, ValueError):
                     rng_seed = 0
             state_snapshot["rng_seed"] = rng_seed
             glitch_manager = GlitchManager(seed=rng_seed)
 
             turn_limit = state_snapshot.get("turn_limit", 30)
             current_turn = state_snapshot.get(
                 "current_turn", state_snapshot.get("turn", 0)
             )
             if not isinstance(current_turn, int):
                 try:
                     current_turn = int(current_turn)
                 except (TypeError, ValueError):
                     current_turn = 0
             if not isinstance(turn_limit, int):
                 try:
                     turn_limit = int(turn_limit)
                 except (TypeError, ValueError):
                     turn_limit = 30
             turn_limit = min(turn_limit, 30)
 
             glitch_info = glitch_manager.resolve_turn(
                 metrics=metric_manager,
                 turn=current_turn + 1,
             )
+            LOGGER.info(
+                "Glitch resolution outcome: roll=%s, triggered_loss=%s",
+                glitch_info.get("roll"),
+                glitch_info.get("triggered_loss"),
+            )
+            LOGGER.debug(
+                "Metrics after glitch resolution: %s",
+                metric_manager.snapshot(),
+            )
 
             is_final_turn = current_turn >= turn_limit
             world_context = self._build_world_context(state_snapshot)
             LOGGER.info("World context built.")
             LOGGER.debug("World context payload: %s", world_context)
             LOGGER.info(
                 "Starting turn %s in room %s",
                 state_snapshot.get("turn", 0),
                 state_snapshot.get("current_room", "unknown"),
             )
 
             world_request = {
                 "WORLD_CONTEXT": world_context,
                 "room": state_snapshot.get("current_room", "unknown"),
             }
             LOGGER.debug(
                 "World agent input: %s",
                 self._stringify(world_request),
             )
             LOGGER.info("Calling world_agent.describe...")
             world_output = self.world_agent.describe(world_request)
             LOGGER.info("World agent returned output.")
             LOGGER.debug(
                 "World agent output: %s",
                 self._stringify(world_output),
@@ -492,57 +508,59 @@ class Orchestrator:
             LOGGER.info("Updating state and persisting...")
             self._update_state(
                 state,
                 world_output,
                 event_output,
                 chosen_option,
             )
             LOGGER.debug(
                 "State after update: %s",
                 self._stringify(state),
             )
             self.state_store.persist(state)
             LOGGER.info("Executing safe function queue...")
             safe_function_results = self._execute_safe_function_queue(
                 event_output=event_output,
                 character_output=character_output,
             )
             LOGGER.info("Safe function queue executed.")
 
             final_state = self.state_store.snapshot()
             final_metrics = MetricManager(
                 final_state,
                 log_sink=self._metric_log_sink(),
             )
             metrics_after = final_metrics.snapshot()
+            LOGGER.debug("Final metrics snapshot: %s", metrics_after)
             win_loss = check_win_loss(
                 metrics_after,
                 turn=final_state.get("turn", 0),
                 turn_limit=final_state.get("turn_limit", turn_limit),
             )
             if glitch_info.get("triggered_loss") and win_loss["status"] == "ongoing":
                 win_loss = {"status": "loss", "reason": "glitch_overload"}
+            LOGGER.info("Win/loss status after turn: %s", win_loss)
             narrative = self._compose_turn_narrative(
                 turn=final_state.get("turn", 0),
                 choice=chosen_option,
                 character_output=character_output,
                 glitch_effects=glitch_info.get("effects", []),
             )
 
             result = {
                 "WORLD_CONTEXT": world_context,
                 "scene": event_output.get("scene", ""),
                 "options": event_output.get("options", []),
                 "world": world_output,
                 "event": event_output,
                 "player_choice": chosen_option,
                 "character_reactions": character_output,
             }
             LOGGER.info("Turn result built.")
             if major_event_effect:
                 result["major_event_effect"] = major_event_effect
             if major_event_summary:
                 result["major_event_effect_summary"] = major_event_summary
             if warnings:
                 result["warnings"] = warnings
             if safe_function_results:
                 result["safe_function_results"] = safe_function_results
diff --git a/fortress_director/utils/glitch_manager.py b/fortress_director/utils/glitch_manager.py
index da74506583b6d840a473792ec7dbbf067e4945bd..939bd3329e969385d51888776f287df202b79e30 100644
--- a/fortress_director/utils/glitch_manager.py
+++ b/fortress_director/utils/glitch_manager.py
@@ -1,64 +1,82 @@
 """Deterministic glitch propagation utilities for Fortress Director."""
 
 from __future__ import annotations
 
 import hashlib
+import logging
 from dataclasses import dataclass
 from typing import Dict, List
 
 from fortress_director.utils.metrics_manager import MetricManager
 
+LOGGER = logging.getLogger(__name__)
+
 
 @dataclass
 class GlitchManager:
     """Compute glitch rolls and apply deterministic side-effects."""
 
     seed: int = 0
 
     def resolve_turn(
         self,
         *,
         metrics: MetricManager,
         turn: int,
     ) -> Dict[str, object]:
         current_glitch = metrics.value("glitch")
+        LOGGER.info(
+            "Resolving glitch (turn=%s, seed=%s, current_glitch=%s)",
+            turn,
+            self.seed,
+            current_glitch,
+        )
+        LOGGER.debug("Metrics before glitch resolution: %s", metrics.snapshot())
         roll = self._deterministic_roll(turn=turn, glitch=current_glitch)
         effects: List[str] = []
         triggered_loss = False
 
         if roll <= 30:
             effects.append("Minor static ripples along the parapets.")
             metrics.adjust_metric("glitch", 1, cause="glitch:cosmetic_noise")
         elif roll <= 60:
             effects.append("Pathfinding errors unsettle the patrol routes.")
             metrics.apply_bulk(
                 (
                     ("order", -3, "glitch:medium_anomaly"),
                     ("morale", -2, "glitch:medium_anomaly"),
                     ("glitch", 4, "glitch:medium_anomaly"),
                 )
             )
         elif roll < 85:
             effects.append("Major anomaly distorts the western wall segment.")
             metrics.apply_bulk(
                 (
                     ("resources", -6, "glitch:major_anomaly"),
                     ("knowledge", -5, "glitch:major_anomaly"),
                     ("glitch", 6, "glitch:major_anomaly"),
                 )
             )
         else:
             effects.append("Glitch cascade overwhelms containment protocols.")
             metrics.adjust_metric("glitch", 15, cause="glitch:overload")
             triggered_loss = True
 
+        LOGGER.info(
+            "Glitch roll complete: roll=%s, triggered_loss=%s",
+            roll,
+            triggered_loss,
+        )
+        LOGGER.debug("Metrics after glitch resolution: %s", metrics.snapshot())
+        LOGGER.debug("Glitch effects applied: %s", effects)
+
         return {
             "roll": roll,
             "effects": effects,
             "triggered_loss": triggered_loss,
         }
 
     def _deterministic_roll(self, *, turn: int, glitch: int) -> int:
         payload = f"{self.seed}:{turn}:{glitch}".encode("utf-8")
         digest = hashlib.sha256(payload).digest()
         return int.from_bytes(digest[:4], "big") % 101
diff --git a/fortress_director/utils/logging_config.py b/fortress_director/utils/logging_config.py
new file mode 100644
index 0000000000000000000000000000000000000000..121335f406cca354a8f1b015ecc1d824a5c8a885
--- /dev/null
+++ b/fortress_director/utils/logging_config.py
@@ -0,0 +1,102 @@
+"""Centralised logging configuration for Fortress Director."""
+
+from __future__ import annotations
+
+import logging
+import os
+from logging.handlers import RotatingFileHandler
+from pathlib import Path
+from typing import Optional, Union
+
+LOG_FORMAT = "%(asctime)s [%(levelname)s] %(name)s: %(message)s"
+
+
+def _normalise_level(level: Union[str, int, None], *, default: int) -> int:
+    if isinstance(level, int):
+        return level
+    if isinstance(level, str):
+        candidate = getattr(logging, level.upper(), None)
+        if isinstance(candidate, int):
+            return candidate
+        try:
+            return int(level)
+        except ValueError:
+            return default
+    return default
+
+
+def configure_logging(
+    *,
+    console_level: Union[str, int, None] = None,
+    file_level: Union[str, int, None] = None,
+    log_path: Optional[Union[str, Path]] = None,
+    force: bool = False,
+) -> Path:
+    """Configure root logging handlers once and return the active log path."""
+
+    if getattr(configure_logging, "_configured", False) and not force:
+        return Path(getattr(configure_logging, "_log_path"))
+
+    console_env = os.getenv("FORTRESS_LOG_CONSOLE_LEVEL")
+    file_env = os.getenv("FORTRESS_LOG_FILE_LEVEL")
+
+    console_level_value = _normalise_level(console_level or console_env, default=logging.INFO)
+    file_level_value = _normalise_level(file_level or file_env, default=logging.DEBUG)
+
+    if log_path is not None:
+        log_file_path = Path(log_path)
+    else:
+        path_override = os.getenv("FORTRESS_LOG_PATH")
+        if path_override:
+            log_file_path = Path(path_override)
+        else:
+            log_dir = os.getenv("FORTRESS_LOG_DIR")
+            if log_dir:
+                log_directory = Path(log_dir)
+            else:
+                log_directory = Path(__file__).resolve().parents[2] / "logs"
+            log_directory.mkdir(parents=True, exist_ok=True)
+            log_file_path = log_directory / "fortress_run.log"
+    log_file_path.parent.mkdir(parents=True, exist_ok=True)
+
+    root_logger = logging.getLogger()
+    if force:
+        for handler in list(root_logger.handlers):
+            root_logger.removeHandler(handler)
+            try:
+                handler.close()
+            except Exception:  # pragma: no cover - defensive cleanup
+                pass
+    root_logger.setLevel(logging.DEBUG)
+
+    formatter = logging.Formatter(LOG_FORMAT)
+
+    console_handler = logging.StreamHandler()
+    console_handler.setLevel(console_level_value)
+    console_handler.setFormatter(formatter)
+
+    file_handler = RotatingFileHandler(
+        log_file_path,
+        maxBytes=2_097_152,
+        backupCount=5,
+        encoding="utf-8",
+    )
+    file_handler.setLevel(file_level_value)
+    file_handler.setFormatter(formatter)
+
+    root_logger.addHandler(console_handler)
+    root_logger.addHandler(file_handler)
+
+    root_logger.debug(
+        "Logging configured (console=%s, file=%s, path=%s)",
+        logging.getLevelName(console_level_value),
+        logging.getLevelName(file_level_value),
+        log_file_path,
+    )
+
+    configure_logging._configured = True  # type: ignore[attr-defined]
+    configure_logging._log_path = str(log_file_path)  # type: ignore[attr-defined]
+    return log_file_path
+
+
+__all__ = ["configure_logging"]
diff --git a/fortress_director/utils/metrics_manager.py b/fortress_director/utils/metrics_manager.py
index 51f1a770259f4e7567e5777e7dabce5a922831ba..95f442eed41833988715735b1aa19546aa43e417 100644
--- a/fortress_director/utils/metrics_manager.py
+++ b/fortress_director/utils/metrics_manager.py
@@ -1,32 +1,35 @@
 """Metric management utilities for the packaged orchestrator."""
 
 from __future__ import annotations
 
+import logging
 from dataclasses import dataclass, field
 from typing import Any, Dict, Iterable, List, MutableMapping, Optional
 
+LOGGER = logging.getLogger(__name__)
+
 
 MetricDict = MutableMapping[str, Any]
 
 
 @dataclass
 class MetricManager:
     """Centralised helper responsible for metric mutation and logging."""
 
     state: Dict[str, Any]
     log_sink: Optional[List[Dict[str, Any]]] = None
     _metrics: MetricDict = field(init=False, repr=False)
 
     CORE_DEFAULTS: Dict[str, int] = field(
         default_factory=lambda: {
             "order": 50,
             "morale": 50,
             "resources": 40,
             "knowledge": 45,
             "corruption": 10,
             "glitch": 12,
         }
     )
 
     LEGACY_DEFAULTS: Dict[str, int] = field(
         default_factory=lambda: {
@@ -35,75 +38,106 @@ class MetricManager:
             "major_events_triggered": 0,
             "major_event_last_turn": None,
         }
     )
 
     LIMITS: Dict[str, tuple[int, int]] = field(
         default_factory=lambda: {
             "order": (0, 100),
             "morale": (0, 100),
             "resources": (0, 120),
             "knowledge": (0, 100),
             "corruption": (0, 100),
             "glitch": (0, 100),
         }
     )
 
     def __post_init__(self) -> None:
         metrics = self.state.setdefault("metrics", {})
         for key, value in self.CORE_DEFAULTS.items():
             metrics.setdefault(key, value)
         for key, value in self.LEGACY_DEFAULTS.items():
             metrics.setdefault(key, value)
         self._metrics = metrics
         if self.log_sink is None:
             self.log_sink = metrics.setdefault("_log_buffer", [])
+        LOGGER.debug("MetricManager initialised with metrics: %s", self.snapshot())
 
     def snapshot(self, *, include_legacy: bool = True) -> Dict[str, Any]:
         if include_legacy:
             keys: Iterable[str] = self._metrics.keys()
         else:
             keys = self.CORE_DEFAULTS.keys()
         snapshot: Dict[str, Any] = {}
         for key in keys:
             if isinstance(key, str) and key.startswith("_"):
                 continue
             snapshot[key] = self._metrics.get(key)
         return snapshot
 
     def value(self, metric: str) -> int:
         raw = self._metrics.get(metric, 0)
         try:
             return int(raw)
         except (TypeError, ValueError):
             return 0
 
     def adjust_metric(self, metric: str, delta: int, *, cause: str) -> int:
         if not metric:
             raise ValueError("metric name is required")
         current = self.value(metric)
         limit = self.LIMITS.get(metric, (0, 9999))
+        LOGGER.debug(
+            "Adjusting metric '%s': current=%s, delta=%s, limits=%s (cause=%s)",
+            metric,
+            current,
+            delta,
+            limit,
+            cause,
+        )
         updated = self._clamp(current + int(delta), limit)
         self._metrics[metric] = updated
         self._log_change(metric, updated - current, updated, cause)
+        LOGGER.info(
+            "Metric '%s' updated from %s to %s (cause=%s)",
+            metric,
+            current,
+            updated,
+            cause,
+        )
         return updated
 
     def modify_resources(self, amount: int, *, cause: str) -> int:
         return self.adjust_metric("resources", int(amount), cause=cause)
 
     def apply_bulk(self, changes: Iterable[tuple[str, int, str]]) -> None:
         for metric, delta, cause in changes:
+            LOGGER.debug(
+                "Applying bulk metric change: metric=%s, delta=%s, cause=%s",
+                metric,
+                delta,
+                cause,
+            )
             self.adjust_metric(metric, delta, cause=cause)
 
     def _clamp(self, value: int, limit: tuple[int, int]) -> int:
         lower, upper = limit
-        return max(lower, min(upper, value))
+        clamped = max(lower, min(upper, value))
+        if clamped != value:
+            LOGGER.debug(
+                "Clamped metric value from %s to %s within bounds %s",
+                value,
+                clamped,
+                limit,
+            )
+        return clamped
 
     def _log_change(self, metric: str, delta: int, value: int, cause: str) -> None:
         entry = {
             "metric": metric,
             "delta": delta,
             "value": value,
             "cause": cause,
         }
         if isinstance(self.log_sink, list):
             self.log_sink.append(entry)
+        LOGGER.debug("Metric change logged: %s", entry)
diff --git a/orchestrator/orchestrator.py b/orchestrator/orchestrator.py
index 728d6cc2e77147feccac78eda51a2c7824ae0d20..8c879431dd3607d3b88479adcff145fa77da2746 100644
--- a/orchestrator/orchestrator.py
+++ b/orchestrator/orchestrator.py
@@ -1,1416 +1,19 @@
-"""Deterministic orchestrator coordinating Fortress Director agents."""
+"""Compatibility wrapper re-exporting the Fortress Director orchestrator."""
 
 from __future__ import annotations
 
-import ast
-import json
-import logging
-from copy import deepcopy
-from dataclasses import dataclass
-from pathlib import Path
-from typing import Any, Callable, Dict, List, Optional, Tuple
-
-from agents.character_agent import CharacterAgent
-from agents.event_agent import EventAgent
-from agents.judge_agent import JudgeAgent, check_win_loss
-from agents.world_agent import WorldAgent
-from settings import SETTINGS
-from rules.rules_engine import (
-    RulesEngine,
-    TierTwoValidationError,
-)
-from codeaware.function_registry import (
-    FunctionCall,
-    FunctionNotRegisteredError,
-    FunctionValidationError,
-    SafeFunctionRegistry,
-    Validator,
+from fortress_director.orchestrator.orchestrator import (
+    DEFAULT_WORLD_STATE,
+    Orchestrator,
+    RELATIONSHIP_SUMMARY_DEFAULT,
+    StateStore,
+    simulate,
 )
-from codeaware.function_validator import (
-    FunctionCallValidator,
-)
-from codeaware.rollback_system import RollbackSystem
-from utils.output_validator import validate_turn_output
-from utils.glitch_manager import GlitchManager
-from utils.metrics_manager import MetricManager
-
-
-LOGGER = logging.getLogger(__name__)
-
-
-SENSORY_DETAILS_DEFAULT = "Drums thud beyond the walls while the wind carries grit."
-
-RELATIONSHIP_SUMMARY_DEFAULT = "Rhea trusts the player; Boris weighs every trade."
-
-
-DEFAULT_WORLD_STATE: Dict[str, Any] = {
-    "turn": 0,
-    "day": 1,
-    "time": "dawn",
-    "turn_limit": 30,
-    "rng_seed": 12345,
-    "current_room": "lornhaven_wall",
-    "recent_events": [],
-    "recent_motifs": [],
-    "recent_major_events": [],
-    "world_constraint_from_prev_turn": {
-        "atmosphere": "low clouds hug the battlements",
-        "sensory_details": SENSORY_DETAILS_DEFAULT,
-    },
-    "player": {
-        "name": "The Shieldbearer",
-        "inventory": ["oil lamp", "patched shield"],
-        "stats": {"resolve": 3, "empathy": 2},
-        "summary": "A weary defender holding the western wall.",
-    },
-    "character_summary": (
-        "Rhea is loyal but impulsive; Boris is cautious and calculating."
-    ),
-    "relationship_summary": RELATIONSHIP_SUMMARY_DEFAULT,
-    "metrics": {
-        "order": 50,
-        "morale": 50,
-        "resources": 40,
-        "knowledge": 45,
-        "corruption": 10,
-        "glitch": 12,
-        "risk_applied_total": 0,
-        "major_flag_set": False,
-        "major_events_triggered": 0,
-        "major_event_last_turn": None,
-    },
-}
-
-
-class StateStore:
-    """Lightweight JSON-backed state store."""
-
-    def __init__(self, path: Path) -> None:
-        self._path = path
-        self._state = self._load()
-
-    def snapshot(self) -> Dict[str, Any]:
-        """Return a deep copy of the current state for safe mutation."""
-
-        snapshot = deepcopy(self._state)
-        LOGGER.debug(
-            "State snapshot loaded from %s (turn=%s)",
-            self._path,
-            snapshot.get("turn"),
-        )
-        return snapshot
-
-    def persist(self, state: Dict[str, Any]) -> None:
-        """Replace current state with provided snapshot and flush to disk."""
-
-        self._state = deepcopy(state)
-        payload = json.dumps(self._state, indent=2)
-        self._path.write_text(payload, encoding="utf-8")
-        LOGGER.debug(
-            "State persisted to %s (turn=%s)",
-            self._path,
-            state.get("turn"),
-        )
-
-    def _load(self) -> Dict[str, Any]:
-        if not self._path.exists():
-            return self._fresh_default()
-        text = self._path.read_text(encoding="utf-8").strip()
-        if not text:
-            LOGGER.debug(
-                "World state file %s empty; loading defaults",
-                self._path,
-            )
-            return self._fresh_default()
-        try:
-            payload = json.loads(text) or {}
-        except json.JSONDecodeError:
-            LOGGER.warning(
-                "World state file %s corrupt; loading defaults",
-                self._path,
-            )
-            return self._fresh_default()
-        if not isinstance(payload, dict):
-            return self._fresh_default()
-        return self._merge_with_defaults(payload)
-
-    @staticmethod
-    def _fresh_default() -> Dict[str, Any]:
-        return deepcopy(DEFAULT_WORLD_STATE)
-
-    @classmethod
-    def _merge_with_defaults(cls, overrides: Dict[str, Any]) -> Dict[str, Any]:
-        base = deepcopy(DEFAULT_WORLD_STATE)
-        return cls._deep_merge(base, overrides)
-
-    @staticmethod
-    def _deep_merge(base: Dict[str, Any], overrides: Dict[str, Any]) -> Dict[str, Any]:
-        for key, value in overrides.items():
-            if isinstance(value, dict) and isinstance(base.get(key), dict):
-                base[key] = StateStore._deep_merge(base[key], value)
-            else:
-                base[key] = value
-        return base
-
-    def summary(self) -> Dict[str, Any]:
-        """Provide a user-facing snapshot for CLI debug output."""
-
-        state = self._state
-        return {
-            "turn": state.get("turn"),
-            "day": state.get("day"),
-            "time": state.get("time"),
-            "current_room": state.get("current_room"),
-            "recent_events": state.get("recent_events", [])[-3:],
-            "recent_motifs": state.get("recent_motifs", [])[-3:],
-        }
-
-
-@dataclass
-class Orchestrator:
-    """Coordinates the serialized flow of the entire game turn."""
-
-    state_store: StateStore
-    event_agent: EventAgent
-    world_agent: WorldAgent
-    character_agent: CharacterAgent
-    judge_agent: JudgeAgent
-    rules_engine: RulesEngine
-    function_registry: SafeFunctionRegistry
-    function_validator: FunctionCallValidator
-    rollback_system: RollbackSystem
-
-    def mutate_safe_function(
-        self,
-        name: str,
-        function: Optional[Callable[..., Any]] = None,
-        *,
-        remove: bool = False,
-        validator: Optional[Validator] = None,
-    ) -> None:
-        """Add or remove a safe function from the registry."""
-
-        if remove:
-            try:
-                self.function_registry.remove(name)
-            except FunctionNotRegisteredError:
-                LOGGER.info("Safe function '%s' not registered; nothing to remove", name)
-            else:
-                LOGGER.info("Safe function removed: %s", name)
-            return
-
-        if function is None:
-            LOGGER.warning(
-                "Safe function '%s' registration requested without a callable; skipping",
-                name,
-            )
-            return
-
-        self.register_safe_function(name, function, validator=validator)
-        LOGGER.info("Safe function registered: %s", name)
-
-    @classmethod
-    def build_default(cls) -> "Orchestrator":
-        """Factory that wires default dependencies."""
-        state_store = StateStore(SETTINGS.world_state_path)
-        judge_agent = JudgeAgent()
-        tolerance = 1  # Default: allow small reintroductions of existing mysteries
-        registry = SafeFunctionRegistry()
-        validator = FunctionCallValidator(
-            registry,
-            max_calls_per_function=5,
-            max_total_calls=20,
-        )
-        rollback_system = RollbackSystem(
-            snapshot_provider=state_store.snapshot,
-            restore_callback=state_store.persist,
-            max_checkpoints=3,
-            logger=LOGGER,
-        )
-        orchestrator = cls(
-            state_store=state_store,
-            event_agent=EventAgent(),
-            world_agent=WorldAgent(),
-            character_agent=CharacterAgent(),
-            judge_agent=judge_agent,
-            rules_engine=RulesEngine(judge_agent=judge_agent, tolerance=tolerance),
-            function_registry=registry,
-            function_validator=validator,
-            rollback_system=rollback_system,
-        )
-        orchestrator._register_default_safe_functions()
-        return orchestrator
-
-    def run_turn(
-        self,
-        *,
-        player_choice_id: Optional[str] = None,
-    ) -> Dict[str, Any]:
-        """Execute a full deterministic turn and persist the new state. Logs every step in detail."""
-        LOGGER.info("run_turn called (player_choice_id=%s)", player_choice_id)
-
-        self._metric_log_buffer = []
-        glitch_info: Dict[str, Any] = {"roll": 0, "effects": [], "triggered_loss": False}
-
-        checkpoint_metadata = {"phase": "turn_start"}
-        if player_choice_id:
-            checkpoint_metadata["player_choice_id"] = player_choice_id
-        LOGGER.debug(
-            "Resetting function validator and creating checkpoint: %s",
-            checkpoint_metadata,
-        )
-        self.function_validator.reset()
-        self.rollback_system.create_checkpoint(metadata=checkpoint_metadata)
-
-        try:
-            LOGGER.info("Turn execution started.")
-            state_snapshot = self.state_store.snapshot()
-            LOGGER.debug(
-                "Pre-turn state snapshot: %s",
-                self._stringify(state_snapshot),
-            )
-            metric_manager = MetricManager(
-                state_snapshot,
-                log_sink=self._metric_log_sink(),
-            )
-            rng_seed = state_snapshot.get("rng_seed", 0)
-            if not isinstance(rng_seed, int):
-                try:
-                    rng_seed = int(rng_seed)
-                except (TypeError, ValueError):
-                    rng_seed = 0
-            state_snapshot["rng_seed"] = rng_seed
-            glitch_manager = GlitchManager(seed=rng_seed)
-
-            turn_limit = state_snapshot.get("turn_limit", 30)
-            current_turn = state_snapshot.get(
-                "current_turn", state_snapshot.get("turn", 0)
-            )
-            if not isinstance(current_turn, int):
-                try:
-                    current_turn = int(current_turn)
-                except (TypeError, ValueError):
-                    current_turn = 0
-            if not isinstance(turn_limit, int):
-                try:
-                    turn_limit = int(turn_limit)
-                except (TypeError, ValueError):
-                    turn_limit = 30
-            turn_limit = min(turn_limit, 30)
-
-            glitch_info = glitch_manager.resolve_turn(
-                metrics=metric_manager,
-                turn=current_turn + 1,
-            )
-
-            is_final_turn = current_turn >= turn_limit
-            world_context = self._build_world_context(state_snapshot)
-            LOGGER.info("World context built.")
-            LOGGER.debug("World context payload: %s", world_context)
-            LOGGER.info(
-                "Starting turn %s in room %s",
-                state_snapshot.get("turn", 0),
-                state_snapshot.get("current_room", "unknown"),
-            )
-
-            world_request = {
-                "WORLD_CONTEXT": world_context,
-                "room": state_snapshot.get("current_room", "unknown"),
-            }
-            LOGGER.debug(
-                "World agent input: %s",
-                self._stringify(world_request),
-            )
-            LOGGER.info("Calling world_agent.describe...")
-            world_output = self.world_agent.describe(world_request)
-            LOGGER.info("World agent returned output.")
-            LOGGER.debug(
-                "World agent output: %s",
-                self._stringify(world_output),
-            )
-
-            recent_motifs_text = (
-                ", ".join(state_snapshot.get("recent_motifs", [])) or "none"
-            )
-            event_request = {
-                "WORLD_CONTEXT": world_context,
-                "day": state_snapshot.get("day", 1),
-                "time": state_snapshot.get("time", "dawn"),
-                "room": state_snapshot.get("current_room", "unknown"),
-                "recent_events": self._format_recent_events(state_snapshot),
-                "world_constraint_from_prev_turn": json.dumps(
-                    state_snapshot.get("world_constraint_from_prev_turn", {})
-                ),
-                "recent_motifs": recent_motifs_text,
-                # lore_continuity_weight: Ka byk olay tetiklendi?
-                "lore_continuity_weight": state_snapshot.get("metrics", {}).get(
-                    "major_events_triggered", 0
-                ),
-            }
-            LOGGER.debug(
-                "Event agent input: %s",
-                self._stringify(event_request),
-            )
-            LOGGER.info("Calling event_agent.generate...")
-            event_output = self.event_agent.generate(event_request)
-            LOGGER.info("Event agent returned output.")
-            LOGGER.debug(
-                "Event agent output: %s",
-                self._stringify(event_output),
-            )
-
-            LOGGER.info("Resolving player choice...")
-            if is_final_turn:
-                event_output["options"] = []
-                chosen_option = {
-                    "id": "end",
-                    "text": "The campaign concludes.",
-                    "action_type": "end",
-                }
-            else:
-                chosen_option = self._resolve_player_choice(
-                    event_output,
-                    player_choice_id,
-                )
-            LOGGER.info("Player choice resolved: %s", chosen_option)
-            LOGGER.debug(
-                "Player choice resolved: %s",
-                self._stringify(chosen_option),
-            )
-
-            player_record = state_snapshot.get("player") or {}
-            player_inventory = player_record.get("inventory")
-            if not isinstance(player_inventory, list):
-                player_inventory = []
-            character_request = {
-                "WORLD_CONTEXT": world_context,
-                "scene_short": event_output.get("scene", ""),
-                "player_choice": chosen_option.get("text", ""),
-                "atmosphere": world_output.get("atmosphere", ""),
-                "sensory_details": world_output.get("sensory_details", ""),
-                "char_brief": state_snapshot.get("character_summary", ""),
-                "relationship_summary_from_state": state_snapshot.get(
-                    "relationship_summary", ""
-                ),
-                "player_inventory_brief": ", ".join(
-                    item for item in player_inventory if isinstance(item, str)
-                ),
-            }
-            LOGGER.debug(
-                "Character agent input: %s",
-                self._stringify(character_request),
-            )
-            LOGGER.info("Calling character_agent.react...")
-            character_output = self.character_agent.react(character_request)
-            LOGGER.info("Character agent returned output.")
-            LOGGER.debug(
-                "Character agent output: %s",
-                self._stringify(character_output),
-            )
-
-            LOGGER.info("Injecting major event effect...")
-            major_event_effect = self._inject_major_event_effect(
-                state_snapshot,
-                event_output,
-                character_output,
-            )
-            LOGGER.info("Major event effect injected.")
-            if major_event_effect:
-                LOGGER.debug(
-                    "Major event effect applied: %s",
-                    self._stringify(major_event_effect),
-                )
-            major_event_summary = (
-                self._format_major_event_summary(major_event_effect)
-                if major_event_effect
-                else None
-            )
-
-            warnings: List[str] = []
-            try:
-                LOGGER.info("Submitting reactions to rules engine...")
-                LOGGER.debug(
-                    "Submitting reactions to rules engine: %s",
-                    self._stringify(character_output),
-                )
-                state = self.rules_engine.process(
-                    state=state_snapshot,
-                    character_events=character_output,
-                    world_context=world_context,
-                    scene=event_output.get("scene", ""),
-                    player_choice=chosen_option,
-                )
-                LOGGER.info(
-                    "Rules engine accepted updates (turn=%s)",
-                    state_snapshot.get("turn", 0) + 1,
-                )
-            except TierTwoValidationError as exc:
-                LOGGER.warning("Judge vetoed character updates: %s", exc)
-                warnings.append(str(exc))
-                fallback = self._build_fallback_reaction(
-                    state_snapshot,
-                    chosen_option,
-                )
-                character_output = [fallback]
-                fallback_note = "Applied fallback defensive stance for primary NPC."
-                warnings.append(fallback_note)
-                LOGGER.info(fallback_note)
-                state = state_snapshot
-                major_event_effect = self._inject_major_event_effect(
-                    state_snapshot,
-                    event_output,
-                    character_output,
-                )
-                if major_event_effect:
-                    LOGGER.debug(
-                        "Major event effect after fallback: %s",
-                        self._stringify(major_event_effect),
-                    )
-                major_event_summary = (
-                    self._format_major_event_summary(major_event_effect)
-                    if major_event_effect
-                    else None
-                )
-
-            LOGGER.info("Updating state and persisting...")
-            self._update_state(
-                state,
-                world_output,
-                event_output,
-                chosen_option,
-            )
-            LOGGER.debug(
-                "State after update: %s",
-                self._stringify(state),
-            )
-            self.state_store.persist(state)
-            LOGGER.info("Executing safe function queue...")
-            safe_function_results = self._execute_safe_function_queue(
-                event_output=event_output,
-                character_output=character_output,
-            )
-            LOGGER.info("Safe function queue executed.")
-
-            final_state = self.state_store.snapshot()
-            final_metrics = MetricManager(
-                final_state,
-                log_sink=self._metric_log_sink(),
-            )
-            metrics_after = final_metrics.snapshot()
-            win_loss = check_win_loss(
-                metrics_after,
-                turn=final_state.get("turn", 0),
-                turn_limit=final_state.get("turn_limit", turn_limit),
-            )
-            if glitch_info.get("triggered_loss") and win_loss["status"] == "ongoing":
-                win_loss = {"status": "loss", "reason": "glitch_overload"}
-            narrative = self._compose_turn_narrative(
-                turn=final_state.get("turn", 0),
-                choice=chosen_option,
-                character_output=character_output,
-                glitch_effects=glitch_info.get("effects", []),
-            )
-
-            result = {
-                "WORLD_CONTEXT": world_context,
-                "scene": event_output.get("scene", ""),
-                "options": event_output.get("options", []),
-                "world": world_output,
-                "event": event_output,
-                "player_choice": chosen_option,
-                "character_reactions": character_output,
-            }
-            LOGGER.info("Turn result built.")
-            if major_event_effect:
-                result["major_event_effect"] = major_event_effect
-            if major_event_summary:
-                result["major_event_effect_summary"] = major_event_summary
-            if warnings:
-                result["warnings"] = warnings
-            if safe_function_results:
-                result["safe_function_results"] = safe_function_results
-            result["metrics_after"] = metrics_after
-            result["glitch"] = {
-                "roll": int(glitch_info.get("roll", 0)),
-                "effects": list(glitch_info.get("effects", [])),
-            }
-            result["logs"] = list(self._metric_log_buffer)
-            result["win_loss"] = win_loss
-            result["narrative"] = narrative
-            if win_loss["status"] != "ongoing":
-                result["options"] = []
-            LOGGER.debug(
-                "Turn result before validation: %s",
-                self._stringify(result),
-            )
-            validate_turn_output(result)
-            LOGGER.info("Turn output validated successfully.")
-        except Exception as exc:
-            class_name = exc.__class__.__name__
-            rollback_reason = f"Turn execution failed: {class_name}"
-            LOGGER.error("Exception during turn: %s", exc, exc_info=True)
-            try:
-                self.rollback_system.rollback(reason=rollback_reason)
-                LOGGER.info("Rollback performed after exception.")
-            except Exception as rollback_error:  # pragma: no cover - defensive
-                LOGGER.error(
-                    "Rollback failed after %s: %s",
-                    exc.__class__.__name__,
-                    rollback_error,
-                )
-            raise
-        else:
-            self.rollback_system.clear()
-            LOGGER.info("Turn completed successfully.")
-            return result
-
-    def register_safe_function(
-        self,
-        name: str,
-        function: Callable[..., Any],
-        *,
-        validator: Validator | None = None,
-    ) -> None:
-        """Register a safe function available to deterministic agents."""
-
-        self.function_registry.register(name, function, validator=validator)
-
-    def run_safe_function(
-        self,
-        payload: Dict[str, Any],
-        *,
-        metadata: Optional[Dict[str, Any]] = None,
-    ) -> Any:
-        """Execute a safe function with validation and rollback support."""
-
-        return self.rollback_system.run_validated_call(
-            self.function_validator,
-            payload,
-            metadata=metadata,
-        )
-
-    def _register_default_safe_functions(self) -> None:
-        """Register baseline safe functions used by the scenario."""
-
-        self.register_safe_function(
-            "change_weather",
-            self._safe_change_weather,
-            validator=self._validate_change_weather_call,
-        )
-        self.register_safe_function(
-            "spawn_item",
-            self._safe_spawn_item,
-            validator=self._validate_spawn_item_call,
-        )
-        self.register_safe_function(
-            "move_npc",
-            self._safe_move_npc,
-            validator=self._validate_move_npc_call,
-        )
-        self.register_safe_function("adjust_logic", self._safe_adjust_logic)
-        self.register_safe_function("adjust_emotion", self._safe_adjust_emotion)
-        self.register_safe_function("raise_corruption", self._safe_raise_corruption)
-        self.register_safe_function("advance_turn", self._safe_advance_turn)
-        self.register_safe_function(
-            "modify_resources",
-            self._safe_modify_resources,
-            validator=self._validate_modify_resources_call,
-        )
-        self.register_safe_function(
-            "adjust_metric",
-            self._safe_adjust_metric,
-            validator=self._validate_adjust_metric_call,
-        )
-
-    def _validate_change_weather_call(
-        self,
-        call: FunctionCall,
-    ) -> FunctionCall:
-        if call.args:
-            raise FunctionValidationError(
-                "change_weather does not accept positional arguments",
-            )
-        kwargs = dict(call.kwargs)
-        atmosphere = kwargs.get("atmosphere")
-        details = kwargs.get("sensory_details")
-        if not isinstance(atmosphere, str) or not atmosphere.strip():
-            raise FunctionValidationError(
-                "change_weather requires a non-empty 'atmosphere' string",
-            )
-        if not isinstance(details, str) or not details.strip():
-            raise FunctionValidationError(
-                "change_weather requires non-empty 'sensory_details'",
-            )
-        sanitized = {
-            "atmosphere": atmosphere.strip(),
-            "sensory_details": details.strip(),
-        }
-        return FunctionCall(
-            name=call.name,
-            args=(),
-            kwargs=sanitized,
-            metadata=call.metadata,
-        )
-
-    def _validate_spawn_item_call(
-        self,
-        call: FunctionCall,
-    ) -> FunctionCall:
-        if call.args:
-            raise FunctionValidationError(
-                "spawn_item does not accept positional arguments",
-            )
-        kwargs = dict(call.kwargs)
-        item_id = kwargs.get("item_id")
-        target = kwargs.get("target", "player")
-        if not isinstance(item_id, str) or not item_id.strip():
-            raise FunctionValidationError(
-                "spawn_item requires a non-empty 'item_id' string",
-            )
-        if not isinstance(target, str) or not target.strip():
-            raise FunctionValidationError(
-                "spawn_item requires a non-empty 'target' string",
-            )
-        sanitized = {
-            "item_id": item_id.strip(),
-            "target": target.strip(),
-        }
-        return FunctionCall(
-            name=call.name,
-            args=(),
-            kwargs=sanitized,
-            metadata=call.metadata,
-        )
-
-    def _validate_move_npc_call(
-        self,
-        call: FunctionCall,
-    ) -> FunctionCall:
-        if call.args:
-            raise FunctionValidationError(
-                "move_npc does not accept positional arguments",
-            )
-        kwargs = dict(call.kwargs)
-        npc_id = kwargs.get("npc_id")
-        location = kwargs.get("location")
-        if not isinstance(npc_id, str) or not npc_id.strip():
-            raise FunctionValidationError(
-                "move_npc requires a non-empty 'npc_id' string",
-            )
-        if not isinstance(location, str) or not location.strip():
-            raise FunctionValidationError(
-                "move_npc requires a non-empty 'location' string",
-            )
-        sanitized = {
-            "npc_id": npc_id.strip(),
-            "location": location.strip(),
-        }
-        return FunctionCall(
-            name=call.name,
-            args=(),
-            kwargs=sanitized,
-            metadata=call.metadata,
-        )
-
-    def _validate_modify_resources_call(
-        self,
-        call: FunctionCall,
-    ) -> FunctionCall:
-        if call.args:
-            raise FunctionValidationError(
-                "modify_resources does not accept positional arguments",
-            )
-        kwargs = dict(call.kwargs)
-        amount_raw = kwargs.get("amount", kwargs.get("delta", 0))
-        try:
-            amount = int(amount_raw)
-        except (TypeError, ValueError) as exc:
-            raise FunctionValidationError("modify_resources requires integer amount") from exc
-        cause_raw = kwargs.get("cause", "safe_modify_resources")
-        cause = str(cause_raw).strip() or "safe_modify_resources"
-        sanitized = {"amount": amount, "cause": cause}
-        return FunctionCall(
-            name=call.name,
-            args=(),
-            kwargs=sanitized,
-            metadata=call.metadata,
-        )
-
-    def _validate_adjust_metric_call(
-        self,
-        call: FunctionCall,
-    ) -> FunctionCall:
-        if call.args:
-            raise FunctionValidationError(
-                "adjust_metric does not accept positional arguments",
-            )
-        kwargs = dict(call.kwargs)
-        metric_raw = kwargs.get("metric")
-        if not isinstance(metric_raw, str) or not metric_raw.strip():
-            raise FunctionValidationError("adjust_metric requires a metric name")
-        metric = metric_raw.strip()
-        try:
-            delta = int(kwargs.get("delta", 0))
-        except (TypeError, ValueError) as exc:
-            raise FunctionValidationError("adjust_metric requires integer delta") from exc
-        cause_raw = kwargs.get("cause", f"adjust_metric:{metric}")
-        cause = str(cause_raw).strip() or f"adjust_metric:{metric}"
-        sanitized = {"metric": metric, "delta": delta, "cause": cause}
-        return FunctionCall(
-            name=call.name,
-            args=(),
-            kwargs=sanitized,
-            metadata=call.metadata,
-        )
-
-    def _safe_change_weather(
-        self,
-        *,
-        atmosphere: str,
-        sensory_details: str,
-    ) -> Dict[str, str]:
-        state = self.state_store.snapshot()
-        payload = state.setdefault("world_constraint_from_prev_turn", {})
-        payload["atmosphere"] = atmosphere
-        payload["sensory_details"] = sensory_details
-        self.state_store.persist(state)
-        return {
-            "atmosphere": payload["atmosphere"],
-            "sensory_details": payload["sensory_details"],
-        }
-
-    def _safe_spawn_item(
-        self,
-        *,
-        item_id: str,
-        target: str,
-    ) -> Dict[str, Any]:
-        state = self.state_store.snapshot()
-        if target == "player":
-            player = state.setdefault("player", {})
-            inventory = player.setdefault("inventory", [])
-            if item_id not in inventory:
-                inventory.append(item_id)
-            result = {
-                "target": "player",
-                "inventory": list(inventory),
-            }
-        else:
-            storage = state.setdefault("items", {})
-            bucket = storage.setdefault(target, [])
-            if item_id not in bucket:
-                bucket.append(item_id)
-            result = {
-                "target": target,
-                "items": list(bucket),
-            }
-        self.state_store.persist(state)
-        return result
-
-    def _safe_move_npc(
-        self,
-        *,
-        npc_id: str,
-        location: str,
-    ) -> Dict[str, str]:
-        state = self.state_store.snapshot()
-        registry = state.setdefault("npc_locations", {})
-        registry[npc_id] = location
-        self.state_store.persist(state)
-        return {
-            "npc_id": npc_id,
-            "location": location,
-        }
-
-    def _safe_modify_resources(
-        self,
-        *,
-        amount: int,
-        cause: str,
-    ) -> Dict[str, Any]:
-        state = self.state_store.snapshot()
-        manager = MetricManager(state, log_sink=self._metric_log_sink())
-        value = manager.modify_resources(amount, cause=cause)
-        self.state_store.persist(state)
-        return {"resources": value}
-
-    def _safe_adjust_metric(
-        self,
-        *,
-        metric: str,
-        delta: int,
-        cause: str,
-    ) -> Dict[str, Any]:
-        state = self.state_store.snapshot()
-        manager = MetricManager(state, log_sink=self._metric_log_sink())
-        value = manager.adjust_metric(metric, delta, cause=cause)
-        self.state_store.persist(state)
-        return {metric: value}
-
-    def _safe_adjust_logic(self) -> Dict[str, Any]:
-        return self._adjust_score("logic_score", 1)
-
-    def _safe_adjust_emotion(self) -> Dict[str, Any]:
-        return self._adjust_score("emotion_score", 1)
-
-    def _safe_raise_corruption(self) -> Dict[str, Any]:
-        return self._adjust_score("corruption", 1)
-
-    def _safe_advance_turn(self) -> Dict[str, Any]:
-        state = self.state_store.snapshot()
-        previous_turn = state.get("current_turn")
-        if not isinstance(previous_turn, int):
-            previous_turn = int(state.get("turn", 0))
-        next_turn = previous_turn + 1
-        state["current_turn"] = next_turn
-        state["turn"] = max(int(state.get("turn", next_turn)), next_turn)
-        self.state_store.persist(state)
-        return {"current_turn": state["current_turn"], "turn": state["turn"]}
-
-    def _adjust_score(self, key: str, delta: int) -> Dict[str, Any]:
-        state = self.state_store.snapshot()
-        scores = state.setdefault("scores", {})
-        current_value = scores.get(key, 0)
-        try:
-            current_value = int(current_value)
-        except (TypeError, ValueError):
-            current_value = 0
-        scores[key] = current_value + delta
-        self.state_store.persist(state)
-        return {"scores": dict(scores)}
-
-    def _metric_log_sink(self) -> List[Dict[str, Any]]:
-        buffer = getattr(self, "_metric_log_buffer", None)
-        if buffer is None:
-            buffer = []
-            self._metric_log_buffer = buffer
-        return buffer
-
-    def _execute_safe_function_queue(
-        self,
-        *,
-        event_output: Dict[str, Any],
-        character_output: List[Dict[str, Any]],
-    ) -> List[Dict[str, Any]]:
-        """Execute any safe function requests emitted by agents."""
-
-        calls = self._collect_safe_function_calls(
-            event_output=event_output,
-            character_output=character_output,
-        )
-        results: List[Dict[str, Any]] = []
-        for payload, metadata in calls:
-            outcome = self.run_safe_function(payload, metadata=metadata)
-            results.append(
-                {
-                    "name": payload["name"],
-                    "result": outcome,
-                    "metadata": metadata,
-                }
-            )
-        return results
-
-    def _collect_safe_function_calls(
-        self,
-        *,
-        event_output: Dict[str, Any],
-        character_output: List[Dict[str, Any]],
-    ) -> List[Tuple[Dict[str, Any], Dict[str, Any]]]:
-        queue: List[Tuple[Dict[str, Any], Dict[str, Any]]] = []
-        queue.extend(
-            self._normalize_safe_function_entries(
-                event_output.get("safe_functions"),
-                source="event_agent",
-            )
-        )
-        for reaction in character_output:
-            if not isinstance(reaction, dict):
-                continue
-            reaction_name = reaction.get("name", "unknown")
-            if isinstance(reaction_name, str) and reaction_name.strip():
-                source_label = f"character:{reaction_name.strip()}"
-            else:
-                source_label = "character:unknown"
-            queue.extend(
-                self._normalize_safe_function_entries(
-                    reaction.get("safe_functions"),
-                    source=source_label,
-                )
-            )
-        return queue
-
-    def _normalize_safe_function_entries(
-        self,
-        entries: Any,
-        *,
-        source: str,
-    ) -> List[Tuple[Dict[str, Any], Dict[str, Any]]]:
-        if not isinstance(entries, list):
-            return []
-        normalized: List[Tuple[Dict[str, Any], Dict[str, Any]]] = []
-        for entry in entries:
-            if isinstance(entry, str):
-                try:
-                    node = ast.parse(entry, mode="eval").body
-                    if not isinstance(node, ast.Call) or not isinstance(node.func, ast.Name):
-                        raise ValueError("Unsupported safe function expression")
-                    func_name = node.func.id
-                    args = [ast.literal_eval(arg) for arg in node.args]
-                    kwargs = {
-                        kw.arg: ast.literal_eval(kw.value)
-                        for kw in node.keywords
-                        if kw.arg is not None
-                    }
-                    payload: Dict[str, Any] = {"name": func_name}
-                    normalized_kwargs = self._normalize_safe_function_kwargs(
-                        func_name,
-                        args,
-                        kwargs,
-                    )
-                    if normalized_kwargs:
-                        payload["kwargs"] = normalized_kwargs
-                    remaining_args = [value for value in args if value is not None]
-                    if remaining_args and func_name not in {"change_weather", "spawn_item", "move_npc"}:
-                        payload["args"] = remaining_args
-                    metadata: Dict[str, Any] = {"source": source}
-                    normalized.append((payload, metadata))
-                except Exception as exc:
-                    LOGGER.warning(
-                        "Failed to parse safe function call '%s': %s",
-                        entry,
-                        exc,
-                    )
-                    continue
-            elif isinstance(entry, dict):
-                # Existing dict format
-                raw_name = entry.get("name")
-                if not isinstance(raw_name, str) or not raw_name.strip():
-                    continue
-                payload: Dict[str, Any] = {"name": raw_name.strip()}
-                if "args" in entry:
-                    payload["args"] = entry.get("args")
-                if "kwargs" in entry:
-                    payload["kwargs"] = entry.get("kwargs")
-                entry_metadata = entry.get("metadata")
-                payload_metadata: Dict[str, Any] = {}
-                if isinstance(entry_metadata, dict):
-                    payload_metadata = dict(entry_metadata)
-                    payload["metadata"] = payload_metadata
-                metadata: Dict[str, Any] = {"source": source}
-                metadata.update(payload_metadata)
-                normalized.append((payload, metadata))
-            else:
-                continue
-        return normalized
-
-    @staticmethod
-    def _normalize_safe_function_kwargs(
-        name: str,
-        args: List[Any],
-        kwargs: Dict[str, Any],
-    ) -> Dict[str, Any]:
-        def _as_text(value: Any) -> str:
-            text = str(value) if value is not None else ""
-            return text.strip()
-
-        if name == "change_weather":
-            atmosphere = kwargs.get("atmosphere")
-            details = kwargs.get("sensory_details")
-            if args:
-                atmosphere = args[0]
-                if len(args) > 1:
-                    details = args[1]
-            atmosphere_text = _as_text(atmosphere)
-            if not atmosphere_text:
-                raise ValueError("change_weather requires an atmosphere")
-            details_text = _as_text(details) or "The weather shifts subtly."
-            return {
-                "atmosphere": atmosphere_text,
-                "sensory_details": details_text,
-            }
-
-        if name == "spawn_item":
-            item_id = kwargs.get("item_id")
-            target = kwargs.get("target")
-            if args:
-                if len(args) > 0:
-                    item_id = args[0]
-                if len(args) > 1:
-                    target = args[1]
-            item_text = _as_text(item_id)
-            target_text = _as_text(target)
-            if not item_text or not target_text:
-                raise ValueError("spawn_item requires item_id and target")
-            return {
-                "item_id": item_text,
-                "target": target_text,
-            }
-
-        if name == "move_npc":
-            npc_id = kwargs.get("npc_id") or kwargs.get("npc_name")
-            location = kwargs.get("location") or kwargs.get("target")
-            if args:
-                if len(args) > 0:
-                    npc_id = args[0]
-                if len(args) > 1:
-                    location = args[1]
-            npc_text = _as_text(npc_id)
-            location_text = _as_text(location)
-            if not npc_text or not location_text:
-                raise ValueError("move_npc requires npc identifier and location")
-            return {
-                "npc_id": npc_text,
-                "location": location_text,
-            }
-
-        cleaned = {
-            key: value
-            for key, value in kwargs.items()
-            if key and value is not None
-        }
-        return cleaned
-
-    def _update_state(
-        self,
-        state: Dict[str, Any],
-        world_output: Dict[str, Any],
-        event_output: Dict[str, Any],
-        chosen_option: Dict[str, Any],
-    ) -> None:
-        previous_turn = state.get("current_turn")
-        if not isinstance(previous_turn, int):
-            previous_turn = int(state.get("turn", 0))
-        next_turn = previous_turn + 1
-        state["turn"] = next_turn
-        state["current_turn"] = next_turn
-        state["world_constraint_from_prev_turn"] = world_output
-        recent_events = state.setdefault("recent_events", [])
-        recent_events.append(event_output.get("scene", ""))
-        state["recent_events"] = recent_events[-5:]
-        recent_motifs = state.setdefault("recent_motifs", [])
-        motif = chosen_option.get("action_type")
-        if motif:
-            recent_motifs.append(motif)
-            state["recent_motifs"] = recent_motifs[-5:]
-        major_events = state.setdefault("recent_major_events", [])
-        major_events.append(bool(event_output.get("major_event")))
-        state["recent_major_events"] = major_events[-5:]
-
-    def _resolve_player_choice(
-        self,
-        event_output: Dict[str, Any],
-        player_choice_id: Optional[str],
-    ) -> Dict[str, Any]:
-        raw_options = event_output.get("options")
-        options: List[Dict[str, Any]] = []
-        if isinstance(raw_options, list):
-            options = [opt for opt in raw_options if isinstance(opt, dict)]
-        if not options:
-            fallback_option = {
-                "id": "opt_1",
-                "text": "Hold position and watch the storm.",
-                "action_type": "observe",
-            }
-            event_output["options"] = [fallback_option]
-            options = [fallback_option]
-
-        selected: Optional[Dict[str, Any]] = None
-        if player_choice_id:
-            for option in options:
-                if str(option.get("id")) == str(player_choice_id):
-                    selected = option
-                    break
-        if selected is None:
-            selected = options[0]
-
-        resolved = {}
-        for key in ("id", "text", "action_type"):
-            value = selected.get(key, "")
-            if not isinstance(value, str):
-                value = str(value)
-            resolved[key] = value.strip() or f"{key}_unknown"
-
-        return resolved
-
-    def _build_fallback_reaction(
-        self,
-        state: Dict[str, Any],
-        choice: Dict[str, Any],
-    ) -> Dict[str, Any]:
-        name = self._infer_primary_npc_name(state)
-        action_desc = ""
-        if isinstance(choice, dict):
-            candidate = choice.get("text", "")
-            if isinstance(candidate, str):
-                action_desc = candidate.strip()
-        speech = (action_desc or "Holding the line until the storm breaks.")[:200]
-        return {
-            "name": name,
-            "intent": "defend",
-            "action": "hold_position",
-            "speech": speech,
-            "effects": {},
-        }
-
-    def _inject_major_event_effect(
-        self,
-        state: Dict[str, Any],
-        event_output: Dict[str, Any],
-        character_output: List[Dict[str, Any]],
-    ) -> Optional[Dict[str, Any]]:
-        if not event_output.get("major_event"):
-            return None
-        if not character_output:
-            return None
-
-        primary = character_output[0]
-        effects = primary.get("effects")
-        if not isinstance(effects, dict):
-            effects = {}
-            primary["effects"] = effects
-
-        raw_flags = effects.get("flag_set")
-        if isinstance(raw_flags, list):
-            flag_set = [str(flag).strip() for flag in raw_flags if str(flag).strip()]
-        else:
-            flag_set = []
-        derived_flag = self._derive_major_event_flag(state)
-        if derived_flag not in flag_set:
-            flag_set.append(derived_flag)
-        effects["flag_set"] = flag_set
-
-        status_change = effects.get("status_change")
-        if not isinstance(status_change, dict):
-            status_change = {}
-        fallback_target = primary.get("name") or "Rhea"
-        target = status_change.get("target")
-        if (
-            not isinstance(target, str)
-            or not target.strip()
-            or target.strip().lower() in {"string", "unknown"}
-        ):
-            target = fallback_target
-        else:
-            target = target.strip()
-        status_change["target"] = target
-        status_label = status_change.get("status")
-        if (
-            not isinstance(status_label, str)
-            or not status_label.strip()
-            or status_label.strip().lower() in {"string", "unknown"}
-        ):
-            status_change["status"] = "tense_watch"
-        else:
-            status_change["status"] = status_label.strip()
-        duration_raw = status_change.get("duration")
-        if not isinstance(duration_raw, int) or duration_raw < 3:
-            status_change["duration"] = 3
-        effects["status_change"] = status_change
-
-        trust_delta = effects.get("trust_delta")
-        if trust_delta not in (-1, 0, 1):
-            effects["trust_delta"] = 0
-
-        return {
-            "applied_flag": derived_flag,
-            "status_change": status_change,
-            "applied_to": status_change["target"],
-        }
-
-    def _build_world_context(self, state: Dict[str, Any]) -> str:
-        """Compose a textual snapshot of the world for prompt consumption."""
-
-        player = state.get("player", {})
-        inventory = ", ".join(player.get("inventory", [])) or "empty"
-        metrics = state.get("metrics", {})
-        world_constraint = state.get("world_constraint_from_prev_turn", {})
-        motifs = state.get("recent_motifs", [])[-3:]
-        recent_motifs = ", ".join(motifs) or "none"
-        recent_major = (
-            ", ".join(
-                "yes" if flag else "no"
-                for flag in state.get("recent_major_events", [])[-3:]
-            )
-            or "none"
-        )
-
-        sections = [
-            (
-                "Turn {turn} | Day {day} | Time {time}".format(
-                    turn=state.get("turn", 0),
-                    day=state.get("day", 1),
-                    time=state.get("time", "dawn"),
-                )
-            ),
-            f"Location: {state.get('current_room', 'unknown')}",
-            (
-                "Player: {name}  {summary}".format(
-                    name=player.get("name", "Unknown"),
-                    summary=player.get("summary", "").strip(),
-                )
-            ),
-            f"Inventory: {inventory}",
-            (
-                "World constraint: {payload}".format(
-                    payload=json.dumps(
-                        world_constraint,
-                        ensure_ascii=False,
-                    )
-                )
-            ),
-            f"Recent events: {self._format_recent_events(state)}",
-            f"Recent motifs: {recent_motifs}",
-            f"Recent major events: {recent_major}",
-            (
-                "Relationship summary: {text}".format(
-                    text=state.get(
-                        "relationship_summary",
-                        RELATIONSHIP_SUMMARY_DEFAULT,
-                    )
-                )
-            ),
-            (
-                "Character summary: {text}".format(
-                    text=state.get("character_summary", "").strip()
-                )
-            ),
-            (
-                "Metrics: {payload}".format(
-                    payload=json.dumps(metrics, ensure_ascii=False)
-                )
-            ),
-        ]
-        return "\n".join(part for part in sections if part)
-
-    def _compose_turn_narrative(
-        self,
-        *,
-        turn: int,
-        choice: Dict[str, Any],
-        character_output: List[Dict[str, Any]],
-        glitch_effects: List[str],
-    ) -> str:
-        """Generate a compact textual summary for the turn result."""
-
-        if not isinstance(choice, dict):
-            choice = {}
-        choice_text = str(choice.get("text", "")).strip()
-        reaction_text = ""
-        if character_output:
-            primary = character_output[0]
-            if isinstance(primary, dict):
-                reaction_text = str(primary.get("speech") or primary.get("action") or "").strip()
-        glitch_text = ""
-        if glitch_effects:
-            glitch_text = str(glitch_effects[0]).strip()
-        parts = [
-            f"Turn {turn}",
-            choice_text,
-            reaction_text,
-            glitch_text,
-        ]
-        narrative = " | ".join(part for part in parts if part)
-        return narrative[:240]
-
-    @staticmethod
-    def _format_recent_events(state: Dict[str, Any]) -> str:
-        events = state.get("recent_events") or []
-        if not events:
-            return "none"
-        trimmed = [
-            event for event in events[-3:] if isinstance(event, str) and event.strip()
-        ]
-        return "; ".join(trimmed) if trimmed else "none"
-
-    @staticmethod
-    def _derive_major_event_flag(state: Dict[str, Any]) -> str:
-        flags = state.get("flags") or []
-        if "mystery_figure" in flags:
-            return "major_mystery_investigation"
-        return "major_wall_alert"
-
-    @staticmethod
-    def _format_major_event_summary(
-        effect: Optional[Dict[str, Any]],
-    ) -> Optional[str]:
-        if not effect:
-            return None
-        status = effect.get("status_change", {})
-        status_label = status.get("status", "unknown")
-        duration = status.get("duration", 0)
-        target = effect.get("applied_to", "unknown")
-        flag = effect.get("applied_flag", "major_event")
-
-        return f"{flag} -> {target} ({status_label}, {duration} turns)"
-
-    @staticmethod
-    def _infer_primary_npc_name(state: Dict[str, Any]) -> str:
-        summary = state.get("character_summary", "")
-        if summary:
-            first_word = summary.split()[0].strip(",.;:")
-            if first_word:
-                return first_word
-        return "Rhea"
-
-    @staticmethod
-    def _stringify(payload: Any) -> str:
-        """Render payloads for logging without raising serialization errors."""
-
-        try:
-            text = json.dumps(payload, ensure_ascii=False, sort_keys=True)
-        except (TypeError, ValueError):
-            text = str(payload)
-        if len(text) > 600:
-            return text[:597] + "..."
-        return text
-
-
-def simulate(n_turns: int = 3, seed: int = 123) -> None:
-    """Run a deterministic mini-simulation and print each turn result."""
-
-    orchestrator = Orchestrator.build_default()
-    baseline = deepcopy(DEFAULT_WORLD_STATE)
-    baseline["rng_seed"] = seed
-    baseline["turn"] = 0
-    baseline["current_turn"] = 0
-    MetricManager(baseline, log_sink=[])
-    orchestrator.state_store.persist(baseline)
 
-    for turn_index in range(n_turns):
-        result = orchestrator.run_turn()
-        print(json.dumps(result, indent=2, ensure_ascii=False))
-        status = result.get("win_loss", {}).get("status", "ongoing")
-        if status != "ongoing":
-            break
-        if turn_index == 0:
-            orchestrator.run_safe_function(
-                {
-                    "name": "adjust_metric",
-                    "kwargs": {
-                        "metric": "order",
-                        "delta": 15,
-                        "cause": "demo_order_boost",
-                    },
-                }
-            )
-            orchestrator.run_safe_function(
-                {
-                    "name": "adjust_metric",
-                    "kwargs": {
-                        "metric": "morale",
-                        "delta": 18,
-                        "cause": "demo_morale_boost",
-                    },
-                }
-            )
-        if turn_index == 1:
-            orchestrator.run_safe_function(
-                {
-                    "name": "adjust_metric",
-                    "kwargs": {
-                        "metric": "glitch",
-                        "delta": -10,
-                        "cause": "demo_glitch_stabilisation",
-                    },
-                }
-            )
+__all__ = [
+    "DEFAULT_WORLD_STATE",
+    "Orchestrator",
+    "RELATIONSHIP_SUMMARY_DEFAULT",
+    "StateStore",
+    "simulate",
+]
diff --git a/pytest.ini b/pytest.ini
new file mode 100644
index 0000000000000000000000000000000000000000..9b944bdc0b590396d8e12af66c327904884f88d2
--- /dev/null
+++ b/pytest.ini
@@ -0,0 +1,3 @@
+[pytest]
+testpaths = tests
+log_cli = true
diff --git a/tests/test_logging_workflow.py b/tests/test_logging_workflow.py
new file mode 100644
index 0000000000000000000000000000000000000000..95ad12dc12e63ef24a18f12b7483ad77d18ac93f
--- /dev/null
+++ b/tests/test_logging_workflow.py
@@ -0,0 +1,133 @@
+from __future__ import annotations
+
+import hashlib
+import importlib
+import json
+import logging
+import shutil
+from pathlib import Path
+from typing import Dict
+
+import pytest
+
+from fortress_director.agents.judge_agent import check_win_loss
+from fortress_director.settings import Settings, ensure_runtime_paths
+from fortress_director.utils.metrics_manager import MetricManager
+from fortress_director.utils.glitch_manager import GlitchManager
+
+
+def test_metric_manager_clamps_and_logs(caplog: pytest.LogCaptureFixture) -> None:
+    state: Dict[str, object] = {"metrics": {"order": 95}}
+    manager = MetricManager(state, log_sink=[])
+
+    with caplog.at_level(logging.DEBUG):
+        result = manager.adjust_metric("order", 10, cause="test:order_clamp")
+
+    assert result == 100
+    assert manager.log_sink is not None
+    assert manager.log_sink[-1]["value"] == 100
+    messages = {record.getMessage() for record in caplog.records}
+    assert any("Metric 'order' updated" in message for message in messages)
+    assert any("Clamped metric value" in message for message in messages)
+
+
+def test_glitch_manager_deterministic_roll(caplog: pytest.LogCaptureFixture) -> None:
+    state: Dict[str, object] = {"metrics": {}}
+    metrics = MetricManager(state, log_sink=[])
+    glitch_manager = GlitchManager(seed=1234)
+
+    with caplog.at_level(logging.INFO):
+        result = glitch_manager.resolve_turn(metrics=metrics, turn=2)
+
+    expected_roll = int.from_bytes(
+        hashlib.sha256(f"{1234}:{2}:{12}".encode("utf-8")).digest()[:4], "big"
+    ) % 101
+    assert result["roll"] == expected_roll
+    assert any(
+        "Glitch roll complete" in record.getMessage() for record in caplog.records
+    )
+
+
+def test_check_win_loss_reasons(caplog: pytest.LogCaptureFixture) -> None:
+    scenarios = [
+        (
+            {"order": 80, "morale": 75, "glitch": 20, "resources": 40},
+            {"status": "win", "reason": "fortress_stabilized"},
+        ),
+        (
+            {"order": 10, "morale": 50, "glitch": 10, "resources": 20},
+            {"status": "loss", "reason": "order_collapse"},
+        ),
+        (
+            {"order": 40, "morale": 40, "glitch": 90, "resources": 30},
+            {"status": "loss", "reason": "glitch_overload"},
+        ),
+    ]
+
+    for metrics, expected in scenarios:
+        caplog.clear()
+        with caplog.at_level(logging.INFO):
+            outcome = check_win_loss(metrics, turn=1, turn_limit=10)
+        assert outcome == expected
+        assert any(
+            "Win/loss evaluation result" in record.getMessage()
+            for record in caplog.records
+        )
+
+
+def test_orchestrator_end_to_end_logging(
+    tmp_path: Path,
+    monkeypatch: pytest.MonkeyPatch,
+    caplog: pytest.LogCaptureFixture,
+) -> None:
+    settings_mod = importlib.import_module("fortress_director.settings")
+    orchestrator_mod = importlib.import_module(
+        "fortress_director.orchestrator.orchestrator"
+    )
+    base_agent_mod = importlib.import_module("fortress_director.agents.base_agent")
+
+    base_settings = settings_mod.SETTINGS
+    sandbox = Settings(
+        project_root=tmp_path,
+        db_path=tmp_path / "db" / "game_state.sqlite",
+        world_state_path=tmp_path / "data" / "world_state.json",
+        cache_dir=tmp_path / "cache",
+        log_dir=tmp_path / "logs",
+        ollama_base_url=base_settings.ollama_base_url,
+        ollama_timeout=base_settings.ollama_timeout,
+        max_active_models=base_settings.max_active_models,
+        semantic_cache_ttl=base_settings.semantic_cache_ttl,
+        models=dict(base_settings.models),
+    )
+    ensure_runtime_paths(sandbox)
+    shutil.copytree(
+        settings_mod.PROJECT_ROOT / "prompts",
+        sandbox.project_root / "prompts",
+    )
+    (sandbox.world_state_path).write_text(
+        json.dumps(settings_mod.DEFAULT_WORLD_STATE, indent=2),
+        encoding="utf-8",
+    )
+
+    monkeypatch.setattr(settings_mod, "SETTINGS", sandbox, raising=False)
+    monkeypatch.setattr(orchestrator_mod, "SETTINGS", sandbox, raising=False)
+    monkeypatch.setattr(base_agent_mod, "SETTINGS", sandbox, raising=False)
+
+    orchestrator = orchestrator_mod.Orchestrator.build_default()
+
+    with caplog.at_level(logging.INFO):
+        result = orchestrator.run_turn()
+
+    assert "glitch" in result
+    assert "win_loss" in result
+    assert any(
+        "Turn execution started." in record.getMessage() for record in caplog.records
+    )
+    assert any(
+        "Glitch resolution outcome" in record.getMessage()
+        for record in caplog.records
+    )
+    assert any(
+        "Win/loss status after turn" in record.getMessage()
+        for record in caplog.records
+    )
diff --git a/utils/glitch_manager.py b/utils/glitch_manager.py
index bfa5ad22ad3756307ac850da43d618f5b034163f..3940f6f2ae66d80a0efb10dd61ce3b075f76c3ae 100644
--- a/utils/glitch_manager.py
+++ b/utils/glitch_manager.py
@@ -1,70 +1,5 @@
-"""Deterministic glitch propagation utilities."""
+"""Compatibility wrapper for the Fortress Director glitch manager."""
 
-from __future__ import annotations
-
-import hashlib
-from dataclasses import dataclass
-from typing import Dict, List
-
-from utils.metrics_manager import MetricManager
-
-
-@dataclass
-class GlitchManager:
-    """Compute glitch rolls and apply deterministic side-effects."""
-
-    seed: int = 0
-
-    def resolve_turn(
-        self,
-        *,
-        metrics: MetricManager,
-        turn: int,
-    ) -> Dict[str, object]:
-        """Roll glitch severity and mutate metrics accordingly."""
-
-        current_glitch = metrics.value("glitch")
-        roll = self._deterministic_roll(turn=turn, glitch=current_glitch)
-        effects: List[str] = []
-        triggered_loss = False
-
-        if roll <= 30:
-            effects.append("Minor static ripples along the parapets.")
-            metrics.adjust_metric("glitch", 1, cause="glitch:cosmetic_noise")
-        elif roll <= 60:
-            effects.append("Pathfinding errors unsettle the patrol routes.")
-            metrics.apply_bulk(
-                (
-                    ("order", -3, "glitch:medium_anomaly"),
-                    ("morale", -2, "glitch:medium_anomaly"),
-                    ("glitch", 4, "glitch:medium_anomaly"),
-                )
-            )
-        elif roll < 85:
-            effects.append("Major anomaly distorts the western wall segment.")
-            metrics.apply_bulk(
-                (
-                    ("resources", -6, "glitch:major_anomaly"),
-                    ("knowledge", -5, "glitch:major_anomaly"),
-                    ("glitch", 6, "glitch:major_anomaly"),
-                )
-            )
-        else:
-            effects.append("Glitch cascade overwhelms containment protocols.")
-            metrics.adjust_metric("glitch", 15, cause="glitch:overload")
-            triggered_loss = True
-
-        return {
-            "roll": roll,
-            "effects": effects,
-            "triggered_loss": triggered_loss,
-        }
-
-    # ------------------------------------------------------------------
-    # Internal helpers
-    # ------------------------------------------------------------------
-    def _deterministic_roll(self, *, turn: int, glitch: int) -> int:
-        payload = f"{self.seed}:{turn}:{glitch}".encode("utf-8")
-        digest = hashlib.sha256(payload).digest()
-        return int.from_bytes(digest[:4], "big") % 101
+from fortress_director.utils.glitch_manager import GlitchManager
 
+__all__ = ["GlitchManager"]
diff --git a/utils/metrics_manager.py b/utils/metrics_manager.py
index 4ba8d2a2f7deb6f960328fdb42ec9c8a058836c1..275ab142853fc25067baee097daf3b7ceeaeaee2 100644
--- a/utils/metrics_manager.py
+++ b/utils/metrics_manager.py
@@ -1,131 +1,5 @@
-"""Metric management utilities for deterministic turn processing."""
+"""Compatibility wrapper for the Fortress Director metric manager."""
 
-from __future__ import annotations
-
-from dataclasses import dataclass, field
-from typing import Any, Dict, Iterable, List, MutableMapping, Optional
-
-
-MetricDict = MutableMapping[str, Any]
-
-
-@dataclass
-class MetricManager:
-    """Centralised helper responsible for metric mutation and logging."""
-
-    state: Dict[str, Any]
-    log_sink: Optional[List[Dict[str, Any]]] = None
-    _metrics: MetricDict = field(init=False, repr=False)
-
-    #: Core gameplay metrics with their default starting values.
-    CORE_DEFAULTS: Dict[str, int] = field(
-        default_factory=lambda: {
-            "order": 50,
-            "morale": 50,
-            "resources": 40,
-            "knowledge": 45,
-            "corruption": 10,
-            "glitch": 12,
-        }
-    )
-
-    #: Legacy counters preserved for backwards compatibility.
-    LEGACY_DEFAULTS: Dict[str, int] = field(
-        default_factory=lambda: {
-            "risk_applied_total": 0,
-            "major_flag_set": False,
-            "major_events_triggered": 0,
-            "major_event_last_turn": None,
-        }
-    )
-
-    #: Clamp boundaries for each mutable metric.
-    LIMITS: Dict[str, tuple[int, int]] = field(
-        default_factory=lambda: {
-            "order": (0, 100),
-            "morale": (0, 100),
-            "resources": (0, 120),
-            "knowledge": (0, 100),
-            "corruption": (0, 100),
-            "glitch": (0, 100),
-        }
-    )
-
-    def __post_init__(self) -> None:
-        metrics = self.state.setdefault("metrics", {})
-        for key, value in self.CORE_DEFAULTS.items():
-            metrics.setdefault(key, value)
-        for key, value in self.LEGACY_DEFAULTS.items():
-            metrics.setdefault(key, value)
-        self._metrics = metrics
-        if self.log_sink is None:
-            # Stand-alone operations fall back to per-state rolling log list.
-            self.log_sink = metrics.setdefault("_log_buffer", [])
-
-    # ------------------------------------------------------------------
-    # Public helpers
-    # ------------------------------------------------------------------
-    def snapshot(self, *, include_legacy: bool = True) -> Dict[str, Any]:
-        """Return a shallow copy of the managed metrics."""
-
-        if include_legacy:
-            keys: Iterable[str] = self._metrics.keys()
-        else:
-            keys = self.CORE_DEFAULTS.keys()
-        snapshot: Dict[str, Any] = {}
-        for key in keys:
-            if isinstance(key, str) and key.startswith("_"):
-                continue
-            snapshot[key] = self._metrics.get(key)
-        return snapshot
-
-    def value(self, metric: str) -> int:
-        """Fetch the current value for *metric* (defaults to zero)."""
-
-        raw = self._metrics.get(metric, 0)
-        try:
-            return int(raw)
-        except (TypeError, ValueError):
-            return 0
-
-    def adjust_metric(self, metric: str, delta: int, *, cause: str) -> int:
-        """Apply *delta* to *metric* and return the clamped result."""
-
-        if not metric:
-            raise ValueError("metric name is required")
-
-        current = self.value(metric)
-        limit = self.LIMITS.get(metric, (0, 9999))
-        updated = self._clamp(current + int(delta), limit)
-        self._metrics[metric] = updated
-        self._log_change(metric, updated - current, updated, cause)
-        return updated
-
-    def modify_resources(self, amount: int, *, cause: str) -> int:
-        """Adjust resources by *amount* (alias for :meth:`adjust_metric`)."""
-
-        return self.adjust_metric("resources", int(amount), cause=cause)
-
-    def apply_bulk(self, changes: Iterable[tuple[str, int, str]]) -> None:
-        """Apply a batch of metric updates."""
-
-        for metric, delta, cause in changes:
-            self.adjust_metric(metric, delta, cause=cause)
-
-    # ------------------------------------------------------------------
-    # Internal utilities
-    # ------------------------------------------------------------------
-    def _clamp(self, value: int, limit: tuple[int, int]) -> int:
-        lower, upper = limit
-        return max(lower, min(upper, value))
-
-    def _log_change(self, metric: str, delta: int, value: int, cause: str) -> None:
-        entry = {
-            "metric": metric,
-            "delta": delta,
-            "value": value,
-            "cause": cause,
-        }
-        if isinstance(self.log_sink, list):
-            self.log_sink.append(entry)
+from fortress_director.utils.metrics_manager import MetricManager
 
+__all__ = ["MetricManager"]
 
EOF
)
