<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Fortress Director - Control Room</title>
    <style>
      :root {
        color-scheme: dark;
        --bg: #0f172a;
        --card-bg: #111827;
        --card-border: #374151;
        --text: #e5e7eb;
        --text-muted: #9ca3af;
        --accent: #2563eb;
        --accent-muted: #1f2937;
        --contrast-bg: #010409;
        --contrast-card: #0b162f;
        --contrast-border: #5eead4;
      }
      body {
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial,
          sans-serif;
        margin: 20px;
        background: var(--bg);
        color: var(--text);
        font-size: 15px;
        line-height: 1.4;
        transition: background 0.2s ease, color 0.2s ease;
      }
      body.high-contrast {
        background: var(--contrast-bg);
        color: #f8fafc;
      }
      body.high-contrast .card {
        background: var(--contrast-card);
        border-color: var(--contrast-border);
        box-shadow: 0 0 0 1px var(--contrast-border);
      }
      body.large-text {
        font-size: 17px;
      }
      body.large-text .small {
        font-size: 14px;
      }
      h1 {
        font-size: 22px;
        margin-bottom: 12px;
      }
      .row {
        display: flex;
        gap: 16px;
        flex-wrap: wrap;
      }
      .card {
        background: var(--card-bg);
        border: 1px solid var(--card-border);
        border-radius: 8px;
        padding: 16px;
        flex: 1 1 360px;
        min-width: 320px;
        transition: border-color 0.2s ease, transform 0.2s ease;
      }
      .card:focus-within {
        border-color: var(--accent);
        transform: translateY(-1px);
      }
      button {
        background: var(--accent);
        color: white;
        border: 0;
        padding: 8px 12px;
        border-radius: 6px;
        cursor: pointer;
        transition: background 0.2s;
      }
      button.secondary {
        background: #374151;
      }
      button[aria-pressed="true"] {
        background: #1d4ed8;
        box-shadow: inset 0 0 0 1px #93c5fd;
      }
      button:disabled {
        background: #1f2937;
        cursor: not-allowed;
      }
      button:focus-visible {
        outline: 2px solid #fbbf24;
        outline-offset: 2px;
      }
      ul {
        margin: 8px 0;
        padding-left: 20px;
      }
      li {
        margin: 6px 0;
      }
      .options li {
        cursor: pointer;
        padding: 6px 8px;
        border-radius: 4px;
        border: 1px solid #374151;
      }
      .options li:hover {
        background: #1f2937;
      }
      code {
        background: #111827;
        color: #93c5fd;
        padding: 2px 4px;
        border-radius: 4px;
      }
      .small {
        font-size: 12px;
        color: var(--text-muted);
      }
      .metric-row {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-bottom: 6px;
      }
      .metric-bar {
        flex: 1;
        height: 8px;
        background: #1f2937;
        border-radius: 999px;
        overflow: hidden;
      }
      .metric-bar span {
        display: block;
        height: 100%;
        background: #2563eb;
      }
      .npc-card {
        border: 1px solid #374151;
        border-radius: 6px;
        padding: 8px;
        margin-bottom: 6px;
      }
      .feed {
        list-style: none;
        padding-left: 0;
        max-height: 200px;
        overflow-y: auto;
      }
      .feed li {
        margin-bottom: 6px;
        border-left: 3px solid #2563eb;
        padding-left: 8px;
      }
      .feed li.final-entry {
        font-size: 14px;
        border-left-color: #fbbf24;
        background: rgba(251, 191, 36, 0.08);
        animation: finalFade 6s ease forwards;
      }
      .feed li.final-entry strong.final-label {
        letter-spacing: 0.04em;
      }
      @keyframes finalFade {
        0% {
          opacity: 1;
        }
        80% {
          opacity: 1;
        }
        100% {
          opacity: 0.55;
        }
      }
      .grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
        gap: 12px;
      }
      .card.hud-card {
        flex: 2 1 520px;
        min-width: 420px;
      }
      .hud-summary {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-items: center;
        margin-bottom: 8px;
      }
      .hud-pill {
        background: #1d4ed8;
        border-radius: 999px;
        padding: 4px 10px;
        font-weight: 600;
        font-size: 12px;
      }
      .hud-resources {
        margin-bottom: 12px;
      }
      .hud-columns {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 12px;
      }
      .status-list {
        list-style: none;
        padding-left: 0;
        margin: 0;
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      .status-pill {
        border: 1px solid #4b5563;
        border-radius: 6px;
        padding: 6px 8px;
        font-size: 12px;
        background: #0b1120;
      }
      .status-pill strong {
        display: block;
        font-size: 13px;
      }
      .status-pill.met {
        border-color: #34d399;
      }
      .status-pill.tracking {
        border-color: #60a5fa;
      }
      .status-pill.setup {
        border-color: #9ca3af;
      }
      .status-pill.warning {
        border-color: #fbbf24;
      }
      .status-pill.critical,
      .status-pill.triggered {
        border-color: #f87171;
      }
      .status-pill.info {
        border-color: #93c5fd;
      }
      .status-pill.active {
        border-color: #34d399;
      }
      .status-pill.hidden {
        border-color: #6b7280;
      }
      .status-pill.disabled {
        border-color: #4b5563;
      }
      .status-pill.highlight {
        border-color: #f472b6;
      }
      .status-pill.danger {
        border-color: #fb7185;
      }
      .status-pill span {
        display: block;
        color: #9ca3af;
        margin-top: 2px;
      }
      .tutorial-card {
        min-width: 320px;
      }
      .chip-list {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        margin-top: 6px;
      }
      .chip {
        background: #1f2937;
        border: 1px solid #374151;
        border-radius: 999px;
        padding: 4px 10px;
        font-size: 12px;
      }
      .planner-list {
        list-style: none;
        padding-left: 0;
      }
      .planner-list li {
        list-style: none;
        border-left: 3px solid #2563eb;
        padding-left: 10px;
        margin-bottom: 8px;
        cursor: pointer;
      }
      .planner-list li.active {
        background: #1f2937;
        border-color: #fbbf24;
      }
      .planner-list li.warning {
        border-color: #fbbf24;
      }
      .planner-list li.critical {
        border-color: #f87171;
      }
      .scene-card {
        position: relative;
      }
      .scene-card #sceneContainer {
        width: 100%;
        height: 360px;
        border-radius: 8px;
        border: 1px solid #1f2937;
        background: radial-gradient(circle at top, #1e3a8a, #020617 65%);
        overflow: hidden;
        position: relative;
      }
      .mini-map {
        margin-top: 10px;
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      .mini-map canvas {
        width: 100%;
        max-width: 200px;
        height: auto;
        border: 1px solid rgba(59, 130, 246, 0.3);
        border-radius: 8px;
        background: #030712;
      }
      .mini-map span {
        font-size: 11px;
        color: var(--text-muted);
      }
      .camera-controls {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-top: 10px;
        align-items: center;
        justify-content: space-between;
      }
      .camera-controls span {
        display: flex;
        gap: 6px;
      }
      .camera-controls label {
        display: flex;
        gap: 6px;
        align-items: center;
        font-size: 12px;
        color: var(--text-muted);
      }
      .theme-selector {
        margin-top: 12px;
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      .theme-selector select {
        max-width: 240px;
      }
      .scene-meta {
        margin-top: 8px;
      }
      .planner-list li {
        list-style: none;
        border-left: 3px solid #2563eb;
        padding-left: 10px;
        margin-bottom: 8px;
      }
      .planner-list li.warning {
        border-color: #fbbf24;
      }
      .planner-list li.critical {
        border-color: #f87171;
      }
      .hud-alerts li {
        list-style: none;
        margin-bottom: 6px;
      }
      .inventory-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
        gap: 8px;
      }
      .inventory-slot {
        border: 1px solid #374151;
        border-radius: 6px;
        padding: 8px;
        background: #0b1120;
        min-height: 84px;
      }
      .inventory-slot .status {
        font-size: 12px;
        color: var(--text-muted);
      }
      .interaction-target {
        border: 1px dashed #374151;
        border-radius: 6px;
        padding: 8px;
        margin-bottom: 8px;
      }
      .interaction-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        margin-top: 6px;
      }
      .agent-pulses li {
        list-style: none;
      }
      .dominance-summary {
        margin-bottom: 8px;
      }
      .agent-dominance li {
        display: flex;
        flex-direction: column;
        gap: 2px;
      }
      .agent-dominance li strong {
        font-size: 13px;
      }
      .agent-dominance li span {
        font-size: 12px;
        color: var(--text-muted);
      }
      .dominance-history {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        margin-top: 10px;
      }
      .dominance-history .history-chip {
        border: 1px solid rgba(59, 130, 246, 0.3);
        background: rgba(15, 23, 42, 0.85);
        border-radius: 8px;
        padding: 6px 10px;
        min-width: 110px;
        display: flex;
        flex-direction: column;
        gap: 2px;
      }
      .dominance-history .history-chip strong {
        font-size: 11px;
        color: var(--text-muted);
        letter-spacing: 0.05em;
        text-transform: uppercase;
      }
      .dominance-history .history-chip span {
        font-size: 12px;
      }
      .dominance-history .history-chip.warning {
        border-color: rgba(251, 191, 36, 0.7);
      }
      .dominance-history .history-chip.critical {
        border-color: rgba(248, 113, 113, 0.8);
      }
      .inventory-slot.draggable {
        cursor: grab;
      }
      body.dragging-item .inventory-slot.drag-origin {
        opacity: 0.4;
      }
      .drag-ghost {
        position: fixed;
        pointer-events: none;
        min-width: 120px;
        padding: 6px 12px;
        border-radius: 999px;
        background: rgba(15, 23, 42, 0.95);
        border: 1px solid rgba(59, 130, 246, 0.6);
        color: #f8fafc;
        font-size: 13px;
        text-align: center;
        z-index: 2000;
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.95);
        transition: opacity 0.15s ease, transform 0.15s ease;
      }
      .drag-ghost.visible {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
      }
      .drag-ghost.invalid {
        border-color: rgba(248, 113, 113, 0.8);
        color: #fecaca;
      }
      .radial-menu {
        position: absolute;
        width: 220px;
        padding: 12px;
        border-radius: 999px;
        background: rgba(5, 15, 35, 0.92);
        border: 1px solid rgba(59, 130, 246, 0.4);
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.6);
        pointer-events: none;
        opacity: 0;
        transform: scale(0.95);
        transition: opacity 0.18s ease, transform 0.18s ease;
        z-index: 999;
      }
      .radial-menu.visible {
        opacity: 1;
        transform: scale(1);
        pointer-events: auto;
      }
      .radial-menu .radial-center {
        text-align: center;
        margin-bottom: 8px;
        font-size: 13px;
        color: var(--text-muted);
      }
      .radial-menu .radial-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        justify-content: center;
      }
      .radial-menu .radial-button {
        min-width: 90px;
        border-radius: 999px;
        padding: 6px 10px;
        border: 1px solid rgba(148, 163, 184, 0.4);
        background: rgba(30, 41, 59, 0.85);
        color: var(--text);
        font-size: 12px;
        text-align: center;
        cursor: pointer;
        transition: background 0.2s ease, border-color 0.2s ease;
      }
      .radial-menu .radial-button:hover {
        border-color: rgba(59, 130, 246, 0.8);
        background: rgba(37, 99, 235, 0.65);
      }
      .radial-menu .radial-button:disabled {
        opacity: 0.4;
        cursor: not-allowed;
      }
      .radial-menu .radial-context {
        padding: 10px 12px;
        border-bottom: 1px solid rgba(148, 163, 184, 0.12);
      }
      .radial-menu .radial-context strong {
        display: block;
        font-size: 14px;
        margin-bottom: 4px;
      }
      .radial-menu .radial-context .radial-meta {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        font-size: 12px;
        color: var(--text-muted);
      }
      .radial-menu[data-anchor="npc"] .radial-actions {
        padding-top: 12px;
      }
      .radial-anchor-panel {
        position: absolute;
        min-width: 180px;
        max-width: 240px;
        padding: 10px 14px;
        border-radius: 10px;
        background: rgba(4, 10, 25, 0.96);
        border: 1px solid rgba(148, 163, 184, 0.35);
        box-shadow: 0 18px 45px rgba(2, 6, 23, 0.8);
        color: var(--text);
        pointer-events: none;
        opacity: 0;
        transform: translate(-50%, -120%) scale(0.94);
        transition: opacity 0.18s ease, transform 0.18s ease;
        z-index: 998;
      }
      .radial-anchor-panel.visible {
        opacity: 1;
        transform: translate(-50%, -120%) scale(1);
      }
      .radial-anchor-panel::after {
        content: "";
        position: absolute;
        left: 50%;
        bottom: -8px;
        width: 14px;
        height: 14px;
        background: inherit;
        border-left: 1px solid rgba(148, 163, 184, 0.35);
        border-bottom: 1px solid rgba(148, 163, 184, 0.35);
        transform: translateX(-50%) rotate(45deg);
        box-shadow: none;
        z-index: -1;
      }
      .radial-anchor-panel .radial-anchor-name {
        font-size: 14px;
        font-weight: 600;
      }
      .radial-anchor-panel .radial-anchor-meta {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        margin-top: 4px;
      }
      .radial-anchor-panel .radial-anchor-meta span {
        font-size: 11px;
        background: rgba(15, 23, 42, 0.65);
        border: 1px solid rgba(59, 130, 246, 0.3);
        border-radius: 999px;
        padding: 2px 8px;
      }
      .radial-anchor-panel .radial-anchor-notes {
        margin-top: 6px;
        font-size: 12px;
        color: var(--text-muted);
      }
      .final-overlay {
        position: fixed;
        inset: 0;
        background: rgba(3, 7, 18, 0.9);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
      }
      .final-overlay.hidden {
        display: none;
      }
      .final-overlay-content {
        max-width: 720px;
        padding: 32px;
        border-radius: 12px;
        background: #0f172a;
        border: 1px solid #2563eb;
        box-shadow: 0 10px 40px rgba(15, 23, 42, 0.8);
      }
      .final-columns {
        display: flex;
        flex-wrap: wrap;
        gap: 16px;
        margin-top: 16px;
      }
      .final-columns ul {
        list-style: none;
        padding-left: 0;
      }
      .final-columns li {
        border-left: 3px solid #2563eb;
        padding-left: 8px;
        margin-bottom: 8px;
      }
      .objective-list {
        margin-left: 16px;
      }
      .filter-controls {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-items: center;
        margin-bottom: 8px;
      }
      .filter-controls label {
        font-size: 12px;
        color: #9ca3af;
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      select {
        background: #111827;
        color: #e5e7eb;
        border: 1px solid #374151;
        border-radius: 6px;
        padding: 4px 8px;
      }
      .accessibility-controls {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-top: 12px;
      }
      .map-activity {
        list-style: none;
        padding-left: 0;
        max-height: 220px;
        overflow-y: auto;
      }
      .map-activity li {
        border-left: 3px solid #f97316;
        padding-left: 8px;
        margin-bottom: 8px;
        font-size: 13px;
      }
      .pulse {
        animation: pulseGlow 1.3s ease;
      }
      @keyframes pulseGlow {
        0% {
          box-shadow: 0 0 0 0 rgba(248, 196, 113, 0.9);
        }
        60% {
          box-shadow: 0 0 0 6px rgba(248, 196, 113, 0);
        }
        100% {
          box-shadow: 0 0 0 0 rgba(248, 196, 113, 0);
        }
      }
      @media (prefers-reduced-motion: reduce) {
        * {
          transition: none !important;
          animation: none !important;
        }
      }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/pixi.js@7.4.4/dist/pixi.min.js"></script>
    <script>
      let telemetrySource = null;
      let safeFunctionSchemas = {};
      let layerFilter = "all";
      let markerFilter = "all";
      let lastPlayerView = null;
      let lastWinLoss = null;
      const plannerState = { activeIndex: 0, recommendations: [] };
      let availableThemes = [];
      let activeThemeMeta = null;
      let lastSceneSnapshot = null;
      let lastThemeSnapshot = null;
      let actionInFlight = false;
      let lastFinalCinematic = null;
      let pixiApp = null;
      const pixiLayers = {
        root: null,
        grid: null,
        overlays: null,
        particles: null,
        vision: null,
        highlights: null,
        npc: null,
        player: null,
        cinematic: null,
        dragTargets: null,
        pulse: null,
        dragPreview: null,
      };
      const scenePaletteColors = {
        grid: 0x243c5a,
        overlay: 0x1d4ed8,
        hazard: 0xfb7185,
        highlightInfo: 0x22d3ee,
        highlightWarn: 0xfbbf24,
        highlightCrit: 0xf87171,
        playerLine: 0x22d3ee,
        playerFill: 0x0ea5e9,
        npcPulse: 0xfcd34d,
        visionCone: 0xfcd34d,
      };
      const particleEmitters = new Map();
      const particleTextureCache = new Map();
      const cameraState = { zoom: 1, offsetX: 0, offsetY: 0, autoFollow: true };
      const cameraDragState = {
        active: false,
        pointerId: null,
        startX: 0,
        startY: 0,
        originX: 0,
        originY: 0,
      };
      const THEME_VAR_KEYS = [
        "--bg",
        "--card-bg",
        "--card-border",
        "--text",
        "--text-muted",
        "--accent",
        "--accent-muted",
      ];
      const themeBaseVars = {};
      let themeVarsCaptured = false;
      const accessibilityState = { contrast: false, largeText: false };
      let lastShareCardText = "";

      function applyAccessibilityState() {
        document.body.classList.toggle(
          "high-contrast",
          accessibilityState.contrast
        );
        document.body.classList.toggle(
          "large-text",
          accessibilityState.largeText
        );
        const contrastBtn = document.getElementById("btnHighContrast");
        if (contrastBtn) {
          contrastBtn.setAttribute(
            "aria-pressed",
            String(accessibilityState.contrast)
          );
        }
        const textBtn = document.getElementById("btnLargeText");
        if (textBtn) {
          textBtn.setAttribute(
            "aria-pressed",
            String(accessibilityState.largeText)
          );
        }
      }

      function captureBaseThemeVars() {
        if (themeVarsCaptured) return;
        const root = document.documentElement;
        if (!root) return;
        const styles = getComputedStyle(root);
        THEME_VAR_KEYS.forEach((key) => {
          themeBaseVars[key] = styles.getPropertyValue(key) || "";
        });
        themeVarsCaptured = true;
      }

      function applyThemePalette(theme) {
        captureBaseThemeVars();
        const root = document.documentElement;
        if (!root) return;
        const palette =
          (theme && theme.palette) ||
          (lastThemeSnapshot && lastThemeSnapshot.palette) ||
          {};
        const mapping = {
          "--bg": palette.background || palette.bg || "",
          "--card-bg": palette.panel || palette.surface || "",
          "--card-border": palette.border || palette.muted || "",
          "--text": palette.text || "",
          "--text-muted": palette.muted || "",
          "--accent": palette.accent || palette.primary || "",
          "--accent-muted": palette.shadow || "",
        };
        Object.entries(mapping).forEach(([cssVar, value]) => {
          const fallback = themeBaseVars[cssVar] || "";
          const nextValue = value || fallback;
          root.style.setProperty(cssVar, nextValue.trim());
        });
        const container = document.getElementById("sceneContainer");
        if (container) {
          const sky = palette.sky || palette.accent || "#1e3a8a";
          const floor = palette.shadow || palette.background || "#020617";
          container.style.background = `radial-gradient(circle at top, ${sky}, ${floor} 65%)`;
        }
      }

      function getThemePalette(themeOverride) {
        if (themeOverride && themeOverride.palette) {
          return themeOverride.palette;
        }
        if (lastThemeSnapshot && lastThemeSnapshot.palette) {
          return lastThemeSnapshot.palette;
        }
        return {};
      }

      function resolveThemeColor(key, fallback = "", themeOverride = null) {
        const palette = getThemePalette(themeOverride);
        return palette[key] || fallback;
      }

      function resolveThemeColorHex(key, fallback, themeOverride = null) {
        const palette = getThemePalette(themeOverride);
        if (palette[key]) {
          return parseColorHex(palette[key], fallback);
        }
        return fallback;
      }

      function toCssColor(value, fallback = "#ffffff") {
        if (typeof value === "string") {
          return value;
        }
        if (typeof value === "number") {
          const hex = value.toString(16).padStart(6, "0");
          return `#${hex}`;
        }
        return fallback;
      }

      function toggleContrast() {
        accessibilityState.contrast = !accessibilityState.contrast;
        applyAccessibilityState();
      }

      function toggleLargeText() {
        accessibilityState.largeText = !accessibilityState.largeText;
        applyAccessibilityState();
      }

      function cssEscape(value) {
        const str = String(value ?? "");
        if (window.CSS && CSS.escape) {
          return CSS.escape(str);
        }
        return str.replace(/"/g, '\\"');
      }

      function pulseElement(element) {
        if (!element) return;
        element.classList.remove("pulse");
        void element.offsetWidth;
        element.classList.add("pulse");
        setTimeout(() => element && element.classList.remove("pulse"), 1400);
      }

      function highlightMapItems(attr, ids) {
        if (!ids) return;
        ids.forEach((id) => {
          if (!id) return;
          const selector = `[${attr}="${cssEscape(id)}"]`;
          const el = document.querySelector(selector);
          if (el) {
            pulseElement(el);
          }
        });
      }

      function appendMapActivityEntry(content, options = {}) {
        const feed = document.getElementById("mapActivity");
        if (!feed) return;
        const entry = document.createElement("li");
        entry.innerHTML = content;
        if (options.variant === "final") {
          entry.classList.add("final-entry");
          entry.setAttribute("data-activity-variant", "final");
        }
        feed.prepend(entry);
        while (feed.children.length > 8) {
          feed.removeChild(feed.lastChild);
        }
      }

      function logFinalMapEntry(view, winLoss) {
        const summary = view?.final_summary;
        const status = (winLoss?.status || "final").toString().toUpperCase();
        const reason = winLoss?.reason || "";
        let summaryText = "";
        if (typeof summary === "string") {
          summaryText = summary;
        } else if (summary && typeof summary === "object") {
          summaryText = summary.text || summary.detail || summary.title || "";
        }
        if (!summaryText) {
          summaryText =
            winLoss?.reason ||
            "Final stage reached. Await concluding decisions.";
        }
        const signature = `${status}:${summaryText.slice(0, 120)}`;
        if (signature && signature === lastFinalLogSignature) {
          return;
        }
        lastFinalLogSignature = signature;
        appendMapActivityEntry(
          `<strong class="final-label">Finale Â· ${status}</strong><br>${summaryText}`,
          { variant: "final" }
        );
      }

      function describeChange(change) {
        if (!change) return "";
        const before =
          change.before === undefined || change.before === null
            ? "--"
            : JSON.stringify(change.before).slice(0, 48);
        const after =
          change.after === undefined || change.after === null
            ? "--"
            : JSON.stringify(change.after).slice(0, 48);
        return `${change.field}: ${before} -> ${after}`;
      }

      function applyMapDiff(diff) {
        if (!diff) return;
        const messages = [];
        const highlightTargets = [];

        const digest = (bucket, noun, verb, attr, includeChanges = false) => {
          (bucket || []).forEach((entry) => {
            const label =
              (entry.after &&
                (entry.after.label ||
                  entry.after.room ||
                  entry.after.npc_id)) ||
              (entry.before &&
                (entry.before.label ||
                  entry.before.room ||
                  entry.before.npc_id)) ||
              entry.id;
            let text = `${noun} <em>${label}</em> ${verb}`;
            if (includeChanges && entry.changes) {
              const changeText = entry.changes
                .slice(0, 3)
                .map(describeChange)
                .join(", ");
              if (changeText) {
                text += ` (${changeText})`;
              }
            }
            messages.push(text);
            if (entry.id) {
              highlightMapItems(attr, [entry.id]);
              highlightTargets.push(entry.id);
            }
          });
        };

        digest(diff.layers?.added, "Layer", "added", "data-layer-id");
        digest(diff.layers?.updated, "Layer", "updated", "data-layer-id", true);
        digest(diff.layers?.removed, "Layer", "removed", "data-layer-id");

        digest(
          diff.event_markers?.added,
          "Marker",
          "spawned",
          "data-marker-id"
        );
        digest(
          diff.event_markers?.updated,
          "Marker",
          "updated",
          "data-marker-id",
          true
        );
        digest(
          diff.event_markers?.removed,
          "Marker",
          "cleared",
          "data-marker-id"
        );

        digest(diff.npc_roles?.added, "NPC role", "assigned", "data-role-id");
        digest(
          diff.npc_roles?.updated,
          "NPC role",
          "updated",
          "data-role-id",
          true
        );
        digest(diff.npc_roles?.removed, "NPC role", "removed", "data-role-id");

        (diff.safe_function_events || []).forEach((event) => {
          const tip = event.summary ? ` - ${event.summary}` : "";
          messages.push(`Safe function <em>${event.name}</em>${tip}`);
        });

        if (!messages.length) return;
        const turnLabel = typeof diff.turn === "number" ? diff.turn : "?";
        const timestamp = new Date().toLocaleTimeString();
        appendMapActivityEntry(
          `<strong>Turn ${turnLabel}</strong> <span class="small">${timestamp}</span><br>${messages.join(
            " | "
          )}`
        );
        if (highlightTargets.length) {
          pulseSceneMarkers(highlightTargets);
        }
      }

      function hashToCoord(seed, cols, rows) {
        const text = String(seed ?? "seed");
        let hash = 0;
        for (let i = 0; i < text.length; i += 1) {
          hash = (hash * 31 + text.charCodeAt(i)) >>> 0;
        }
        const width = Math.max(1, cols);
        const height = Math.max(1, rows);
        const x = hash % width;
        const y = Math.floor(hash / width) % height;
        return { x, y };
      }

      function clamp(value, min, max) {
        return Math.min(max, Math.max(min, value));
      }

      function seededRandom(seed, iteration = 0) {
        const text = `${seed || "seed"}:${iteration}`;
        let hash = 0;
        for (let i = 0; i < text.length; i += 1) {
          hash = (hash * 1664525 + text.charCodeAt(i) + 1013904223) >>> 0;
        }
        return hash / 0xffffffff;
      }

      function getRendererCoordinates(clientX, clientY) {
        if (!pixiApp || !pixiApp.view) return null;
        const rect = pixiApp.view.getBoundingClientRect();
        if (!rect.width || !rect.height) return null;
        const xRatio = pixiApp.renderer.width / rect.width;
        const yRatio = pixiApp.renderer.height / rect.height;
        return {
          x: (clientX - rect.left) * xRatio,
          y: (clientY - rect.top) * yRatio,
        };
      }

      function clampCameraOffsets() {
        if (!pixiApp) return;
        const width = pixiApp.renderer.width;
        const height = pixiApp.renderer.height;
        const maxX = 0;
        const minX = width - width * cameraState.zoom;
        const maxY = 0;
        const minY = height - height * cameraState.zoom;
        cameraState.offsetX = clamp(cameraState.offsetX, minX, maxX);
        cameraState.offsetY = clamp(cameraState.offsetY, minY, maxY);
      }

      function applyCameraState() {
        if (!pixiApp || !pixiLayers.root) return;
        clampCameraOffsets();
        pixiLayers.root.scale.set(cameraState.zoom);
        pixiLayers.root.position.set(cameraState.offsetX, cameraState.offsetY);
      }

      function resetCameraTransform(autoFollow = true) {
        cameraState.zoom = 1;
        cameraState.offsetX = 0;
        cameraState.offsetY = 0;
        cameraState.autoFollow = autoFollow;
        cameraDragState.active = false;
        applyCameraState();
        const toggle = document.getElementById("cameraAutoFollowToggle");
        if (toggle) {
          toggle.checked = autoFollow;
        }
      }

      function disableCameraAutoFollow() {
        if (!cameraState.autoFollow) {
          cameraState.autoFollow = false;
          return;
        }
        cameraState.autoFollow = false;
        const toggle = document.getElementById("cameraAutoFollowToggle");
        if (toggle) {
          toggle.checked = false;
        }
      }

      function setCameraAutoFollow(enabled) {
        cameraState.autoFollow = Boolean(enabled);
        const toggle = document.getElementById("cameraAutoFollowToggle");
        if (toggle) {
          toggle.checked = cameraState.autoFollow;
        }
        if (cameraState.autoFollow && lastSceneSnapshot) {
          syncCameraFromScene(
            lastSceneSnapshot,
            pixiApp?.renderer.width || 0,
            pixiApp?.renderer.height || 0,
            getSceneGridMeta()?.cols || 12,
            getSceneGridMeta()?.rows || 12
          );
        }
      }

      function setCameraZoom(value, pivotPoint = null) {
        const clamped = clamp(value, 0.7, 1.8);
        const previous = cameraState.zoom || 1;
        if (!pixiApp) {
          cameraState.zoom = clamped;
          return;
        }
        if (!pivotPoint) {
          pivotPoint = {
            x: pixiApp.renderer.width / 2,
            y: pixiApp.renderer.height / 2,
          };
        }
        if (!previous) {
          cameraState.zoom = clamped;
          applyCameraState();
          return;
        }
        const ratio = clamped / previous;
        cameraState.offsetX =
          pivotPoint.x - (pivotPoint.x - cameraState.offsetX) * ratio;
        cameraState.offsetY =
          pivotPoint.y - (pivotPoint.y - cameraState.offsetY) * ratio;
        cameraState.zoom = clamped;
        applyCameraState();
      }

      function adjustCameraZoom(delta, pivotPoint = null) {
        disableCameraAutoFollow();
        setCameraZoom(cameraState.zoom + delta, pivotPoint);
      }

      function handleSceneWheel(event) {
        if (!pixiApp) return;
        event.preventDefault();
        const step = event.deltaY > 0 ? -0.1 : 0.1;
        const rendererPoint = getRendererCoordinates(event.clientX, event.clientY);
        adjustCameraZoom(step, rendererPoint || undefined);
      }

      function startCameraDrag(event) {
        const global = event.data.global;
        cameraDragState.active = true;
        cameraDragState.pointerId = event.data.pointerId;
        cameraDragState.startX = global.x;
        cameraDragState.startY = global.y;
        cameraDragState.originX = cameraState.offsetX;
        cameraDragState.originY = cameraState.offsetY;
        disableCameraAutoFollow();
      }

      function updateCameraDrag(global) {
        if (!cameraDragState.active) return;
        const dx = global.x - cameraDragState.startX;
        const dy = global.y - cameraDragState.startY;
        cameraState.offsetX = cameraDragState.originX + dx;
        cameraState.offsetY = cameraDragState.originY + dy;
        applyCameraState();
      }

      function endCameraDrag() {
        cameraDragState.active = false;
        cameraDragState.pointerId = null;
      }

      function syncCameraFromScene(scene, width, height, cols, rows) {
        if (!scene || !scene.camera || !pixiApp || !cameraState.autoFollow) {
          return;
        }
        const target = resolveCameraTargetCoord(
          scene.camera,
          scene,
          cols,
          rows
        );
        if (typeof scene.camera.zoom === "number") {
          cameraState.zoom = clamp(scene.camera.zoom, 0.7, 1.8);
        }
        if (target) {
          const tileWidth = width / cols;
          const tileHeight = height / rows;
          const centerX = (target.x + 0.5) * tileWidth;
          const centerY = (target.y + 0.5) * tileHeight;
          cameraState.offsetX =
            width / 2 - centerX * cameraState.zoom;
          cameraState.offsetY =
            height / 2 - centerY * cameraState.zoom;
        }
        applyCameraState();
      }

      function parseColorHex(value, fallback) {
        if (typeof value === "number") {
          return value;
        }
        if (typeof value === "string") {
          const hex = value.replace("#", "");
          if (/^[0-9a-fA-F]+$/.test(hex)) {
            return Number.parseInt(hex, 16);
          }
        }
        return fallback;
      }

      function severityColor(severity, fallback) {
        const map = {
          critical: 0xf87171,
          warning: 0xfbbf24,
          medium: 0xfbbf24,
          info: 0x38bdf8,
          low: 0x38bdf8,
        };
        return map[severity] ?? fallback;
      }

      function resolveEffectColor(effect, severity, fallback) {
        const metaColor =
          (effect && effect.color) ||
          (effect && effect.metadata && effect.metadata.color);
        if (metaColor) {
          return parseColorHex(metaColor, fallback);
        }
        const type = (effect?.effect_type || "").toLowerCase();
        const typeMap = {
          glitch: 0xa855f7,
          storm: 0x38bdf8,
          rain: 0x38bdf8,
          sandstorm: 0xf97316,
          fog: 0xcbd5f5,
          hazard: 0xf87171,
          breach: 0xf87171,
        };
        if (typeMap[type]) {
          return typeMap[type];
        }
        return severityColor(severity, fallback);
      }

      function resolveEffectSeed(effect, idx) {
        const metadata = (effect && effect.metadata) || {};
        return (
          metadata.tile_id ||
          metadata.room ||
          metadata.location ||
          metadata.id ||
          effect.id ||
          effect.detail ||
          effect.effect_type ||
          `effect-${idx}`
        );
      }

      function normalizeAreaBounds(bounds, cols, rows) {
        if (!bounds) return null;
        const toNumber = (value, fallback = 0) => {
          const num = Number(value);
          return Number.isFinite(num) ? num : fallback;
        };
        const isNumericLike = (value) =>
          typeof value === "number" ||
          (typeof value === "string" &&
            value.trim() &&
            !Number.isNaN(Number(value)));
        const clampCol = (value) =>
          clamp(Math.floor(toNumber(value, 0)), 0, Math.max(0, cols - 1));
        const clampRow = (value) =>
          clamp(Math.floor(toNumber(value, 0)), 0, Math.max(0, rows - 1));
        let col = 0;
        let row = 0;
        let width = 1;
        let height = 1;
        if (Array.isArray(bounds)) {
          if (
            bounds.length >= 4 &&
            bounds.every((entry) => isNumericLike(entry))
          ) {
            col = toNumber(bounds[0], 0);
            row = toNumber(bounds[1], 0);
            width = toNumber(bounds[2], 1);
            height = toNumber(bounds[3], 1);
          } else if (
            bounds.length >= 2 &&
            Array.isArray(bounds[0]) &&
            Array.isArray(bounds[1])
          ) {
            const start = bounds[0];
            const end = bounds[1];
            col = toNumber(start[0], 0);
            row = toNumber(start[1], 0);
            width = toNumber(end[0], col) - col + 1;
            height = toNumber(end[1], row) - row + 1;
          } else {
            return null;
          }
        } else if (typeof bounds === "object") {
          col =
            bounds.col ??
            bounds.x ??
            bounds.start_col ??
            (bounds.start && bounds.start.col) ??
            0;
          row =
            bounds.row ??
            bounds.y ??
            bounds.start_row ??
            (bounds.start && bounds.start.row) ??
            0;
          if (bounds.end_col != null) {
            width = toNumber(bounds.end_col, col) - toNumber(col, 0) + 1;
          } else if (bounds.width != null) {
            width = bounds.width;
          } else if (bounds.cols != null) {
            width = bounds.cols;
          }
          if (bounds.end_row != null) {
            height = toNumber(bounds.end_row, row) - toNumber(row, 0) + 1;
          } else if (bounds.height != null) {
            height = bounds.height;
          } else if (bounds.rows != null) {
            height = bounds.rows;
          }
          const radius =
            bounds.radius ??
            bounds.area_radius ??
            (bounds.size != null ? (bounds.size - 1) / 2 : null);
          if (radius != null) {
            const span = radius * 2 + 1;
            width = span;
            height = span;
            col =
              (bounds.center_col ?? bounds.center?.col ?? col) - radius;
            row =
              (bounds.center_row ?? bounds.center?.row ?? row) - radius;
          }
        } else if (typeof bounds === "string") {
          const parts = bounds
            .split(/[^0-9\-]+/)
            .filter(Boolean)
            .map(Number);
          if (parts.length >= 4) {
            col = parts[0];
            row = parts[1];
            width = parts[2];
            height = parts[3];
          } else {
            return null;
          }
        } else {
          return null;
        }
        col = clampCol(col);
        row = clampRow(row);
        width = Math.max(
          1,
          Math.min(cols - col, Math.floor(toNumber(width, 1)) || 1)
        );
        height = Math.max(
          1,
          Math.min(rows - row, Math.floor(toNumber(height, 1)) || 1)
        );
        return { col, row, width, height };
      }


      function resolveTargetCoordinate(target, cols, rows) {
        if (!target) return null;
        const direct = parseTileReference(target.coordinates, cols, rows);
        if (direct) return direct;
        if (
          typeof target.col === "number" &&
          typeof target.row === "number"
        ) {
          return {
            x: clamp(target.col, 0, cols - 1),
            y: clamp(target.row, 0, rows - 1),
          };
        }
        if (
          typeof target.x === "number" &&
          typeof target.y === "number"
        ) {
          return {
            x: clamp(target.x, 0, cols - 1),
            y: clamp(target.y, 0, rows - 1),
          };
        }
        const metadata = target.metadata || {};
        const tag =
          target.location ||
          target.room ||
          metadata.location ||
          metadata.room ||
          target.target_id ||
          target.id ||
          target.name;
        if (tag) {
          return hashToCoord(tag, cols, rows);
        }
        return null;
      }

      function collectInteractionTargetsAt(col, row) {
        if (
          !lastInteractionTargets.length ||
          !lastSceneSnapshot ||
          typeof col !== "number" ||
          typeof row !== "number"
        ) {
          return [];
        }
        const cols = Math.max(
          4,
          Number(lastSceneSnapshot.grid_columns) || 12
        );
        const rows = Math.max(
          4,
          Number(lastSceneSnapshot.grid_rows) || 12
        );
        return lastInteractionTargets.filter((target) => {
          const coord = resolveTargetCoordinate(target, cols, rows);
          if (!coord) return false;
          return coord.x === col && coord.y === row;
        });
      }

      function openRadialForTarget(target) {
        if (!target) return;
        const meta = getSceneGridMeta();
        let position = null;
        if (meta) {
          const coord = resolveTargetCoordinate(target, meta.cols, meta.rows);
          if (coord) {
            position = { col: coord.x, row: coord.y };
          }
        }
        if (!position) {
          position = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
        }
        showRadialMenu(target, target.actions || [], position);
      }

      function buildDragAllowedTiles(slot) {
        const tiles = [];
        const meta = getSceneGridMeta();
        if (!meta) return tiles;
        const appendCoord = (coord) => {
          if (!coord) return;
          const areaSource =
            coord.bounds ||
            coord.area ||
            coord.region ||
            (Array.isArray(coord) && coord.length >= 4 ? coord : null);
          if (areaSource) {
            const normalized = normalizeAreaBounds(
              areaSource,
              meta.cols,
              meta.rows
            );
            if (normalized) {
              tiles.push({
                bounds: normalized,
                label: coord.label || coord.name,
                color: coord.color,
              });
            }
            return;
          }
          if (
            typeof coord.col === "number" &&
            typeof coord.row === "number"
          ) {
            tiles.push({
              col: clamp(coord.col, 0, meta.cols - 1),
              row: clamp(coord.row, 0, meta.rows - 1),
              label: coord.label || coord.name,
            });
            return;
          }
          const parsed = parseTileReference(coord, meta.cols, meta.rows);
          if (parsed) {
            tiles.push({
              col: parsed.x,
              row: parsed.y,
              label:
                (coord && typeof coord === "object" && coord.label) || undefined,
            });
          }
        };
        const appendAny = (value) => {
          if (!value) return;
          if (Array.isArray(value)) {
            const numericSequence =
              value.length >= 4 &&
              value.every(
                (entry) =>
                  typeof entry === "number" ||
                  (typeof entry === "string" &&
                    entry.trim() &&
                    !Number.isNaN(Number(entry)))
              );
            if (numericSequence) {
              appendCoord(value);
              return;
            }
            if (
              value.length &&
              (Array.isArray(value[0]) || typeof value[0] === "object")
            ) {
              value.forEach((item) => appendAny(item));
              return;
            }
          }
          appendCoord(value);
        };
        const candidateLists = [
          slot?.allowed_tiles,
          slot?.target_tiles,
          slot?.valid_tiles,
          slot?.allowed_areas,
          slot?.drop_bounds,
          slot?.valid_regions,
          slot?.target_area,
          slot?.drop_area,
        ];
        candidateLists.forEach((entry) => appendAny(entry));
        if (!tiles.length) {
          lastInteractionTargets.forEach((target) => {
            const coord = resolveTargetCoordinate(target, meta.cols, meta.rows);
            if (coord) {
              appendCoord({
                col: coord.x,
                row: coord.y,
                label: target.name || target.target_id,
              });
            }
            if (target && target.bounds) {
              appendCoord({
                bounds: target.bounds,
                label: target.name,
              });
            }
          });
        }
        return tiles;
      }

      function isTileAllowed(tile) {
        if (!dragState) return false;
        const meta = dragState.allowedMeta || getSceneGridMeta();
        if (!meta) return false;
        dragState.allowedMeta = meta;
        if (!dragState.allowedTiles || !dragState.allowedTiles.length) {
          return true;
        }
        return dragState.allowedTiles.some((coord) => {
          if (coord.bounds) {
            const area = normalizeAreaBounds(
              coord.bounds,
              meta.cols,
              meta.rows
            );
            if (!area) return false;
            return (
              tile.col >= area.col &&
              tile.row >= area.row &&
              tile.col < area.col + area.width &&
              tile.row < area.row + area.height
            );
          }
          return tilesEqual(
            { col: coord.col ?? coord.x, row: coord.row ?? coord.y },
            tile
          );
        });
      }

      function getSceneGridMeta() {
        if (!lastSceneSnapshot) return null;
        const cols = Math.max(
          4,
          Number(lastSceneSnapshot.grid_columns) || 12
        );
        const rows = Math.max(
          4,
          Number(lastSceneSnapshot.grid_rows) || 12
        );
        return { cols, rows };
      }

      function clientPointToTile(clientX, clientY) {
        if (!pixiApp || !pixiApp.view) {
          return null;
        }
        const meta = getSceneGridMeta();
        if (!meta) return null;
        const rect = pixiApp.view.getBoundingClientRect();
        if (
          clientX < rect.left ||
          clientX > rect.right ||
          clientY < rect.top ||
          clientY > rect.bottom
        ) {
          return null;
        }
        const rendererPoint = getRendererCoordinates(clientX, clientY);
        if (!rendererPoint) return null;
        const rootX =
          (rendererPoint.x - cameraState.offsetX) / cameraState.zoom;
        const rootY =
          (rendererPoint.y - cameraState.offsetY) / cameraState.zoom;
        const col = clamp(
          Math.floor((rootX / pixiApp.renderer.width) * meta.cols),
          0,
          meta.cols - 1
        );
        const row = clamp(
          Math.floor((rootY / pixiApp.renderer.height) * meta.rows),
          0,
          meta.rows - 1
        );
        return { col, row };
      }

      function tileToScreenPosition(col, row) {
        if (!pixiApp || !pixiApp.view) {
          return null;
        }
        const meta = getSceneGridMeta();
        if (!meta) return null;
        const rect = pixiApp.view.getBoundingClientRect();
        const width = pixiApp.renderer.width;
        const height = pixiApp.renderer.height;
        const tileWidth = width / meta.cols;
        const tileHeight = height / meta.rows;
        const rootX = col * tileWidth + tileWidth / 2;
        const rootY = row * tileHeight + tileHeight / 2;
        const scaledX = rootX * cameraState.zoom + cameraState.offsetX;
        const scaledY = rootY * cameraState.zoom + cameraState.offsetY;
        const ratioX = rect.width / width;
        const ratioY = rect.height / height;
        return {
          x: rect.left + scaledX * ratioX,
          y: rect.top + scaledY * ratioY,
          tileWidth: (tileWidth * cameraState.zoom) * ratioX,
          tileHeight: (tileHeight * cameraState.zoom) * ratioY,
        };
      }

      function clearDragPreview() {
        if (pixiLayers.dragPreview && pixiLayers.dragPreview.clear) {
          pixiLayers.dragPreview.clear();
        }
      }

      function clearDragTargets() {
        if (pixiLayers.dragTargets && pixiLayers.dragTargets.clear) {
          pixiLayers.dragTargets.clear();
          if (pixiLayers.dragTargets.removeChildren) {
            pixiLayers.dragTargets.removeChildren();
          }
        }
      }

      function renderDragTargetHints(tiles) {
        if (!pixiLayers.dragTargets || !pixiApp || !lastSceneSnapshot) return;
        const layer = pixiLayers.dragTargets;
        layer.clear();
        if (!tiles || !tiles.length) return;
        const meta = getSceneGridMeta();
        if (!meta) return;
        const width = pixiApp.renderer.width;
        const height = pixiApp.renderer.height;
        const tileWidth = width / meta.cols;
        const tileHeight = height / meta.rows;
        tiles.forEach((coord, idx) => {
          if (coord.bounds) {
            const area = normalizeAreaBounds(coord.bounds, meta.cols, meta.rows);
            if (!area) {
              return;
            }
            const color = coord.color ?? 0x22d3ee;
            layer.lineStyle(1, color, 0.18);
            layer.beginFill(color, 0.1);
            layer.drawRoundedRect(
              area.col * tileWidth + 4,
              area.row * tileHeight + 4,
              Math.max(6, area.width * tileWidth - 8),
              Math.max(6, area.height * tileHeight - 8),
              8
            );
            layer.endFill();
            if (coord.label) {
              const text = new PIXI.Text(coord.label, {
                fontFamily: "monospace",
                fontSize: 11,
                fill: color,
              });
              text.anchor.set(0.5);
              text.x = area.col * tileWidth + (area.width * tileWidth) / 2;
              text.y = area.row * tileHeight + (area.height * tileHeight) / 2;
              layer.addChild(text);
            }
            return;
          }
          if (
            coord.col == null ||
            coord.row == null
          ) {
            return;
          }
          const color = coord.color ?? (idx % 2 ? 0x38bdf8 : 0x93c5fd);
          layer.lineStyle(1.5, color, 0.35);
          layer.drawRoundedRect(
            coord.col * tileWidth + 6,
            coord.row * tileHeight + 6,
            tileWidth - 12,
            tileHeight - 12,
            5
          );
          if (coord.label) {
            const text = new PIXI.Text(coord.label, {
              fontFamily: "monospace",
              fontSize: 11,
              fill: color,
            });
            text.anchor.set(0.5);
            text.x = coord.col * tileWidth + tileWidth / 2;
            text.y = coord.row * tileHeight + tileHeight / 2;
            layer.addChild(text);
          }
        });
      }

      function renderDragPreview(col, row, isValid) {
        if (!pixiApp || !pixiLayers.dragPreview || !lastSceneSnapshot) return;
        const preview = pixiLayers.dragPreview;
        preview.clear();
        const cols = Math.max(
          4,
          Number(lastSceneSnapshot.grid_columns) || 12
        );
        const rows = Math.max(
          4,
          Number(lastSceneSnapshot.grid_rows) || 12
        );
        const width = pixiApp.renderer.width;
        const height = pixiApp.renderer.height;
        const tileWidth = width / cols;
        const tileHeight = height / rows;
        preview.lineStyle(3, isValid ? 0x38bdf8 : 0xf87171, 0.9);
        preview.drawRoundedRect(
          col * tileWidth + 4,
          row * tileHeight + 4,
          tileWidth - 8,
          tileHeight - 8,
          6
        );
        preview.endFill();
      }

      function tilesEqual(a, b) {
        if (!a || !b) return false;
        return a.col === b.col && a.row === b.row;
      }

      function cancelInventoryDrag() {
        if (!dragState) return;
        dragState.sourceElement?.classList.remove("drag-origin");
        dragState = null;
        document.body.classList.remove("dragging-item");
        hideRadialMenu(true);
        hideDragGhost();
        clearDragPreview();
        clearDragTargets();
      }

      function startInventoryDrag(slot, event) {
        if (!slot || !slot.safe_function || actionInFlight) return;
        hideRadialMenu(true);
        dragState = {
          slot,
          safe_function: slot.safe_function,
          slot_id: slot.slot_id || slot.item_id,
          sourceElement: event.currentTarget,
          hoverCol: null,
          hoverRow: null,
          pending: true,
          startX: event.clientX,
          startY: event.clientY,
          allowedTiles: buildDragAllowedTiles(slot),
          allowedMeta: getSceneGridMeta(),
        };
      }

      function activateInventoryDrag(event) {
        if (!dragState || !dragState.pending) return;
        dragState.pending = false;
        document.body.classList.add("dragging-item");
        dragState.sourceElement?.classList.add("drag-origin");
        updateDragGhost(dragState.slot, event.clientX, event.clientY, false);
        renderDragTargetHints(dragState.allowedTiles);
        event.preventDefault();
      }

      function handleGlobalPointerMove(event) {
        if (!dragState) return;
        if (dragState.pending) {
          const dx = Math.abs(event.clientX - dragState.startX);
          const dy = Math.abs(event.clientY - dragState.startY);
          if (dx + dy < 6) {
            return;
          }
          activateInventoryDrag(event);
        }
        if (dragState.pending) {
          return;
        }
        updateDragGhost(dragState.slot, event.clientX, event.clientY, true);
        const tile = clientPointToTile(event.clientX, event.clientY);
        if (!tile) {
          dragState.hoverCol = null;
          dragState.hoverRow = null;
          clearDragPreview();
          ensureDragGhost().classList.add("invalid");
          return;
        }
        const allowed = isTileAllowed(tile);
        const ghost = ensureDragGhost();
        ghost.classList.toggle("invalid", !allowed);
        dragState.hoverCol = tile.col;
        dragState.hoverRow = tile.row;
        renderDragPreview(tile.col, tile.row, allowed);
      }

      function handleGlobalPointerUp(event) {
        if (!dragState) return;
        if (dragState.pending) {
          dragState = null;
          return;
        }
        const tile = clientPointToTile(event.clientX, event.clientY);
        const slot = dragState.slot;
        const safeName = dragState.safe_function;
        const slotId = dragState.slot_id;
        dragState.sourceElement?.classList.remove("drag-origin");
        document.body.classList.remove("dragging-item");
        const allowed = tile && isTileAllowed(tile);
        const shouldFire = Boolean(allowed && safeName);
        hideDragGhost();
        clearDragPreview();
        clearDragTargets();
        dragState = null;
        if (shouldFire) {
          runSafeAction(safeName, {
            slot_id: slotId,
            target_col: tile.col,
            target_row: tile.row,
          });
        }
      }

      function parseTileReference(ref, cols, rows) {
        if (!ref) return null;
        if (Array.isArray(ref) && ref.length >= 2) {
          const [cx, cy] = ref;
          if (typeof cx === "number" && typeof cy === "number") {
            return {
              x: clamp(cx, 0, cols - 1),
              y: clamp(cy, 0, rows - 1),
            };
          }
        }
        if (typeof ref === "object") {
          if (
            typeof ref.x === "number" &&
            typeof ref.y === "number"
          ) {
            return {
              x: clamp(ref.x, 0, cols - 1),
              y: clamp(ref.y, 0, rows - 1),
            };
          }
          if (
            typeof ref.col === "number" &&
            typeof ref.row === "number"
          ) {
            return {
              x: clamp(ref.col, 0, cols - 1),
              y: clamp(ref.row, 0, rows - 1),
            };
          }
        }
        if (typeof ref === "string") {
          const parts = ref.split(/[^0-9\-]+/).filter(Boolean);
          if (parts.length >= 2) {
            const cx = Number(parts[0]);
            const cy = Number(parts[1]);
            if (!Number.isNaN(cx) && !Number.isNaN(cy)) {
              return {
                x: clamp(cx, 0, cols - 1),
                y: clamp(cy, 0, rows - 1),
              };
            }
          }
        }
        return null;
      }

      function resolveCameraTargetCoord(camera, scene, cols, rows) {
        if (!camera) return null;
        const direct =
          parseTileReference(camera.focus_tile, cols, rows) ||
          parseTileReference(camera.target_tile, cols, rows) ||
          parseTileReference(camera.target, cols, rows);
        if (direct) {
          return direct;
        }
        if (
          typeof camera.target_col === "number" &&
          typeof camera.target_row === "number"
        ) {
          return {
            x: clamp(camera.target_col, 0, cols - 1),
            y: clamp(camera.target_row, 0, rows - 1),
          };
        }
        if (
          typeof camera.col === "number" &&
          typeof camera.row === "number"
        ) {
          return {
            x: clamp(camera.col, 0, cols - 1),
            y: clamp(camera.row, 0, rows - 1),
          };
        }
        const focus = (camera.focus || camera.follow || "").toString().toLowerCase();
        if (focus === "player" || focus === "avatar") {
          const coord = getPlayerCoord((scene && scene.player) || {}, cols, rows);
          return {
            x: clamp(coord.x, 0, cols - 1),
            y: clamp(coord.y, 0, rows - 1),
          };
        }
        if (typeof camera.seed === "string") {
          return hashToCoord(camera.seed, cols, rows);
        }
        return null;
      }

      function drawCameraFocusOverlay(
        camera,
        cinematic,
        width,
        height,
        cols,
        rows,
        scene
      ) {
        if (!camera || !cinematic) return;
        const coord = resolveCameraTargetCoord(camera, scene, cols, rows);
        if (!coord) return;
        const tileWidth = width / cols;
        const tileHeight = height / rows;
        const px = coord.x * tileWidth + tileWidth / 2;
        const py = coord.y * tileHeight + tileHeight / 2;
        const zoom = clamp(Number(camera.zoom) || 1, 0.7, 1.8);
        const radius =
          Math.max(tileWidth, tileHeight) * (1.05 + (zoom - 1) * 1.2);
        const tint = parseColorHex(camera.tint || camera.color, 0xf472b6);
        const shake = clamp(Number(camera.shake) || 0, 0, 3);
        const jitterSeed =
          (camera.focus || camera.seed || camera.target || "camera") +
          ":" +
          (scene && scene.turn ? scene.turn : 0);
        const jitterX = shake
          ? (seededRandom(jitterSeed, 1) - 0.5) * shake * 4
          : 0;
        const jitterY = shake
          ? (seededRandom(jitterSeed, 2) - 0.5) * shake * 4
          : 0;
        cinematic.lineStyle(2, tint, 0.65);
        cinematic.drawCircle(px + jitterX, py + jitterY, radius);
        const fillAlpha = 0.12 + (zoom - 1) * 0.12;
        cinematic.beginFill(tint, Math.min(0.4, Math.max(0.08, fillAlpha)));
        cinematic.drawCircle(px + jitterX, py + jitterY, radius * 0.7);
        cinematic.endFill();
        const cross = radius * 0.9;
        cinematic.lineStyle(1, tint, 0.35);
        cinematic.moveTo(px + jitterX - cross, py + jitterY);
        cinematic.lineTo(px + jitterX + cross, py + jitterY);
        cinematic.moveTo(px + jitterX, py + jitterY - cross);
        cinematic.lineTo(px + jitterX, py + jitterY + cross);
      }

      function drawWeatherEffect(
        effect,
        cinematic,
        width,
        height,
        seed,
        severity
      ) {
        const color = resolveEffectColor(effect, severity, 0x38bdf8);
        const alpha =
          severity === "critical" ? 0.55 : severity === "warning" ? 0.4 : 0.25;
        const dropCount = 24;
        cinematic.lineStyle(1.2, color, alpha);
        for (let i = 0; i < dropCount; i += 1) {
          const randX = seededRandom(seed, i) * width;
          const randY = seededRandom(seed, i + 51) * height;
          const drift = 12 + seededRandom(seed, i + 200) * 18;
          cinematic.moveTo(randX, randY);
          cinematic.lineTo(randX - drift * 0.4, randY + drift);
        }
      }

      function drawFogEffect(effect, cinematic, width, height, seed, severity) {
        const color = resolveEffectColor(effect, severity, 0xcbd5f5);
        const layers = 6;
        for (let i = 0; i < layers; i += 1) {
          const alpha = 0.05 + seededRandom(seed, i) * 0.12;
          const radiusX = (width * (0.15 + seededRandom(seed, i + 10) * 0.2));
          const radiusY = (height * (0.08 + seededRandom(seed, i + 30) * 0.15));
          const cx = seededRandom(seed, i + 60) * width;
          const cy = seededRandom(seed, i + 90) * height;
          cinematic.beginFill(color, alpha);
          cinematic.drawEllipse(cx, cy, radiusX, radiusY);
          cinematic.endFill();
        }
      }

      function drawGlitchEffect(effect, cinematic, width, height, seed, severity) {
        const color = resolveEffectColor(effect, severity, 0xa855f7);
        const blocks = 9;
        for (let i = 0; i < blocks; i += 1) {
          const randWidth = 20 + seededRandom(seed, i) * 60;
          const randHeight = 6 + seededRandom(seed, i + 20) * 24;
          const x = seededRandom(seed, i + 40) * (width - randWidth);
          const y = seededRandom(seed, i + 80) * (height - randHeight);
          const alpha = 0.2 + seededRandom(seed, i + 100) * 0.4;
          cinematic.beginFill(color, alpha);
          cinematic.drawRect(x, y, randWidth, randHeight);
          cinematic.endFill();
        }
      }

      function drawTileEffect(
        effect,
        cinematic,
        width,
        height,
        cols,
        rows,
        seed,
        severity
      ) {
        const color = resolveEffectColor(effect, severity, 0x60a5fa);
        const rect = getTileRect(seed, cols, rows, width, height);
        const alpha =
          severity === "critical" ? 0.45 : severity === "warning" ? 0.32 : 0.2;
        cinematic.beginFill(color, alpha);
        cinematic.drawRoundedRect(
          rect.x + 4,
          rect.y + 4,
          Math.max(4, rect.w - 8),
          Math.max(4, rect.h - 8),
          6
        );
        cinematic.endFill();
      }

      function renderCinematicEffects(
        effects,
        cinematic,
        width,
        height,
        cols,
        rows,
        scene
      ) {
        if (!cinematic) return;
        cinematic.clear();
        (effects || []).slice(0, 12).forEach((effect, idx) => {
          if (!effect) return;
          const type = (effect.effect_type || effect.type || "").toLowerCase();
          const severity = (
            effect.intensity ||
            effect.severity ||
            "info"
          )
            .toString()
            .toLowerCase();
          const seed = resolveEffectSeed(effect, idx);
          if (
            type === "storm" ||
            type === "rain" ||
            type === "sandstorm" ||
            type === "snow"
          ) {
            drawWeatherEffect(effect, cinematic, width, height, seed, severity);
            return;
          }
          if (type.includes("glitch")) {
            drawGlitchEffect(effect, cinematic, width, height, seed, severity);
            return;
          }
          if (type === "fog" || type === "mist") {
            drawFogEffect(effect, cinematic, width, height, seed, severity);
            return;
          }
          drawTileEffect(
            effect,
            cinematic,
            width,
            height,
            cols,
            rows,
            seed,
            severity
          );
        });
        if (scene && scene.camera) {
          drawCameraFocusOverlay(
            scene.camera,
            cinematic,
            width,
            height,
            cols,
            rows,
            scene
          );
        }
      }

      function shouldUseParticleEmitter(type) {
        if (!type) return false;
        return (
          type.includes("rain") ||
          type.includes("storm") ||
          type.includes("snow") ||
          type.includes("ember") ||
          type.includes("spark") ||
          type.includes("glitch")
        );
      }

      function resolveEffectAreaRect(effect, cols, rows, width, height) {
        if (!effect) return null;
        const metadata = effect.metadata || {};
        const areaCand =
          metadata.bounds ||
          metadata.area ||
          metadata.region ||
          effect.bounds ||
          effect.area ||
          effect.region;
        if (areaCand) {
          const normalized = normalizeAreaBounds(areaCand, cols, rows);
          if (normalized) {
            return areaToPixelRect(normalized, cols, rows, width, height);
          }
        }
        const tileRef =
          metadata.tile ||
          metadata.target_tile ||
          effect.tile ||
          effect.target_tile;
        if (tileRef) {
          const normalized = normalizeAreaBounds(
            Array.isArray(tileRef)
              ? tileRef.length >= 4
                ? tileRef
                : [tileRef[0], tileRef[1], 1, 1]
              : tileRef,
            cols,
            rows
          );
          if (normalized) {
            return areaToPixelRect(normalized, cols, rows, width, height);
          }
        }
        const coord =
          parseTileReference(tileRef, cols, rows) ||
          parseTileReference(metadata.location, cols, rows);
        if (coord) {
          return areaToPixelRect(
            { col: coord.x, row: coord.y, width: 1, height: 1 },
            cols,
            rows,
            width,
            height
          );
        }
        return null;
      }

      function syncParticleEmitters(effects, width, height, cols, rows) {
        const layer = pixiLayers.particles;
        if (!layer || !pixiApp) return;
        const activeIds = new Set();
        (effects || []).forEach((effect, idx) => {
          if (!effect) return;
          const type = (effect.effect_type || effect.type || "").toLowerCase();
          if (!shouldUseParticleEmitter(type)) {
            return;
          }
          const id = effect.id || effect.name || `effect-${idx}`;
          activeIds.add(id);
          const boundsRect =
            resolveEffectAreaRect(effect, cols, rows, width, height) || {
              x: 0,
              y: 0,
              w: width,
              h: height,
            };
          const existing = particleEmitters.get(id);
          if (existing) {
            existing.bounds = boundsRect;
            existing.maxParticles = determineParticleBudget(type, boundsRect);
            existing.config = buildParticleConfig(type, effect);
            return;
          }
          const emitter = createParticleEmitter(
            id,
            type,
            effect,
            boundsRect,
            width,
            height
          );
          layer.addChild(emitter.container);
          particleEmitters.set(id, emitter);
        });
        particleEmitters.forEach((emitter, id) => {
          if (!activeIds.has(id)) {
            destroyParticleEmitter(emitter);
            particleEmitters.delete(id);
          }
        });
        if (particleEmitters.size) {
          ensureAnimationTicker();
        }
      }

      function determineParticleBudget(type, bounds) {
        const areaFactor = Math.max(1, (bounds.w * bounds.h) / 50000);
        if (type.includes("rain") || type.includes("storm")) {
          return Math.min(180, Math.floor(60 * areaFactor));
        }
        if (type.includes("snow")) {
          return Math.min(140, Math.floor(40 * areaFactor));
        }
        if (type.includes("glitch")) {
          return Math.min(80, Math.floor(30 * areaFactor));
        }
        return Math.min(100, Math.floor(35 * areaFactor));
      }

      function buildParticleConfig(type, effect) {
        const baseColor = resolveEffectColor(effect, "info", 0x60a5fa);
        if (type.includes("snow")) {
          return {
            color: baseColor,
            alpha: 0.75,
            speedY: [0.2, 0.6],
            speedX: [-0.15, 0.15],
            life: [2600, 4200],
            size: [0.6, 1.2],
          };
        }
        if (type.includes("rain") || type.includes("storm")) {
          return {
            color: baseColor,
            alpha: 0.85,
            speedY: [1.8, 3.6],
            speedX: [-0.4, 0.4],
            life: [1200, 2000],
            size: [1.4, 1.9],
          };
        }
        if (type.includes("glitch")) {
          return {
            color: baseColor,
            alpha: 0.9,
            speedY: [-0.4, 0.4],
            speedX: [-0.4, 0.4],
            life: [900, 1600],
            size: [0.8, 1.4],
          };
        }
        return {
          color: baseColor,
          alpha: 0.8,
          speedY: [-0.1, -0.6],
          speedX: [-0.3, 0.3],
          life: [1400, 2600],
          size: [0.7, 1.3],
        };
      }

      function createParticleEmitter(
        id,
        type,
        effect,
        bounds,
        width,
        height
      ) {
        const container = new PIXI.Container();
        container.sortableChildren = false;
        const config = buildParticleConfig(type, effect);
        const emitter = {
          id,
          type,
          container,
          bounds,
          particles: [],
          spawnTimer: 0,
          spawnInterval: type.includes("rain") ? 30 : 70,
          maxParticles: determineParticleBudget(type, bounds),
          config,
          width,
          height,
          texture: getParticleTexture(type, config.color),
        };
        for (let i = 0; i < Math.min(12, emitter.maxParticles / 3); i += 1) {
          spawnParticle(emitter, true);
        }
        return emitter;
      }

      function destroyParticleEmitter(emitter) {
        if (!emitter) return;
        try {
          emitter.particles.forEach((particle) => {
            if (particle.sprite?.parent) {
              particle.sprite.parent.removeChild(particle.sprite);
            }
            particle.sprite?.destroy();
          });
          emitter.container?.destroy({ children: true });
        } catch (err) {
          console.warn("Failed to destroy particle emitter", err);
        }
      }

      function getParticleTexture(type, color) {
        const key = `${type}:${color}`;
        if (particleTextureCache.has(key)) {
          return particleTextureCache.get(key);
        }
        const gfx = new PIXI.Graphics();
        const baseColor = parseColorHex(color, 0x60a5fa);
        if (type.includes("rain") || type.includes("storm")) {
          gfx.lineStyle(2, baseColor, 0.9);
          gfx.moveTo(0, 0);
          gfx.lineTo(0, 12);
        } else if (type.includes("snow")) {
          gfx.beginFill(baseColor, 0.9);
          gfx.drawCircle(0, 0, 3);
          gfx.endFill();
        } else if (type.includes("glitch")) {
          gfx.beginFill(baseColor, 0.8);
          gfx.drawRect(0, 0, 4, 4);
          gfx.endFill();
        } else {
          gfx.beginFill(baseColor, 0.9);
          gfx.drawCircle(0, 0, 2);
          gfx.endFill();
        }
        const texture = pixiApp.renderer.generateTexture(gfx);
        particleTextureCache.set(key, texture);
        return texture;
      }

      function spawnParticle(emitter, randomizeStart = false) {
        if (!emitter || !emitter.texture) return;
        const sprite = new PIXI.Sprite(emitter.texture);
        sprite.alpha = emitter.config.alpha;
        const scale =
          emitter.config.size[0] +
          Math.random() * (emitter.config.size[1] - emitter.config.size[0]);
        sprite.scale.set(scale);
        const startX =
          emitter.bounds.x + Math.random() * emitter.bounds.w;
        const startY = randomizeStart
          ? emitter.bounds.y + Math.random() * emitter.bounds.h
          : emitter.bounds.y;
        sprite.x = startX;
        sprite.y = startY;
        emitter.container.addChild(sprite);
        const speedY =
          emitter.config.speedY[0] +
          Math.random() * (emitter.config.speedY[1] - emitter.config.speedY[0]);
        const speedX =
          emitter.config.speedX[0] +
          Math.random() * (emitter.config.speedX[1] - emitter.config.speedX[0]);
        const maxLife =
          emitter.config.life[0] +
          Math.random() * (emitter.config.life[1] - emitter.config.life[0]);
        emitter.particles.push({
          sprite,
          vx: speedX,
          vy: speedY,
          life: randomizeStart ? Math.random() * maxLife : 0,
          maxLife,
        });
      }

      function stepParticleEmitters(delta = 1) {
        if (!particleEmitters.size || !pixiLayers.particles) return;
        const deltaMs = delta * 16.6;
        particleEmitters.forEach((emitter) => {
          emitter.spawnTimer += deltaMs;
          while (
            emitter.spawnTimer >= emitter.spawnInterval &&
            emitter.particles.length < emitter.maxParticles
          ) {
            spawnParticle(emitter);
            emitter.spawnTimer -= emitter.spawnInterval;
          }
          const boundsBottom = emitter.bounds.y + emitter.bounds.h;
          emitter.particles = emitter.particles.filter((particle) => {
            particle.life += deltaMs;
            particle.sprite.x += particle.vx * deltaMs;
            particle.sprite.y += particle.vy * deltaMs;
            if (particle.sprite.y > boundsBottom + 40) {
              particle.sprite.y = emitter.bounds.y - 10;
            }
            if (particle.sprite.y < emitter.bounds.y - 100) {
              particle.sprite.y = boundsBottom;
            }
            const expired = particle.life >= particle.maxLife;
            if (expired) {
              if (particle.sprite.parent) {
                particle.sprite.parent.removeChild(particle.sprite);
              }
              particle.sprite.destroy();
            }
            return !expired;
          });
        });
      }

      function easeOutCubic(t) {
        return 1 - Math.pow(1 - t, 3);
      }

      function ensureAnimationTicker() {
        if (!pixiApp || animationTickerAttached) return;
        pixiApp.ticker.add(stepSceneAnimations);
        animationTickerAttached = true;
      }

      function stepSceneAnimations(delta) {
        stepNpcAnimation();
        stepPlayerAnimation();
        stepParticleEmitters(delta || 1);
      }

      function stepNpcAnimation() {
        if (
          !npcAnimation ||
          !npcAnimation.nodes ||
          !pixiLayers.npc ||
          !npcAnimation.width
        ) {
          return;
        }
        const now = performance.now();
        const duration = npcAnimation.duration || 350;
        const progress = easeOutCubic(
          Math.min(1, (now - npcAnimation.startTime) / duration)
        );
        drawNpcLayer(progress);
        if (progress >= 1) {
          npcAnimation.nodes.forEach((node) => {
            node.startX = node.targetX;
            node.startY = node.targetY;
            node.currentX = node.targetX;
            node.currentY = node.targetY;
          });
          npcAnimation.startTime = now;
        }
      }

      function drawNpcLayer(progress) {
        const layer = pixiLayers.npc;
        if (!layer || !npcAnimation) return;
        layer.clear();
        npcAnimation.nodes.forEach((node) => {
          const currentX =
            node.startX + (node.targetX - node.startX) * progress;
          const currentY =
            node.startY + (node.targetY - node.startY) * progress;
          node.currentX = currentX;
          node.currentY = currentY;
          layer.beginFill(scenePaletteColors.npcPulse, 0.8);
          layer.drawCircle(
            currentX,
            currentY,
            Math.min(
              npcAnimation.width / npcAnimation.cols,
              npcAnimation.height / npcAnimation.rows
            ) / 4
          );
          layer.endFill();
        });
      }

      function updateNpcTargets(npcList, width, height, cols, rows) {
        const layer = pixiLayers.npc;
        if (!layer) return;
        if (!npcList || !npcList.length) {
          layer.clear();
          npcAnimation = null;
          return;
        }
        const prevNodes = (npcAnimation && npcAnimation.nodes) || new Map();
        const nodes = new Map();
        const tileWidth = width / cols;
        const tileHeight = height / rows;
        npcList.slice(0, 32).forEach((npc, idx) => {
          const seed = npc.id || npc.npc_id || npc.name || `npc-${idx}`;
          const coord =
            typeof npc.x === "number" && typeof npc.y === "number"
              ? { x: npc.x, y: npc.y }
              : hashToCoord(seed, cols, rows);
          const px = coord.x * tileWidth + tileWidth / 2;
          const py = coord.y * tileHeight + tileHeight / 2;
          const prev = prevNodes.get(seed);
          nodes.set(seed, {
            id: seed,
            startX: prev ? prev.currentX ?? prev.targetX ?? px : px,
            startY: prev ? prev.currentY ?? prev.targetY ?? py : py,
            targetX: px,
            targetY: py,
            currentX: prev ? prev.currentX ?? px : px,
            currentY: prev ? prev.currentY ?? py : py,
          });
        });
        npcAnimation = {
          nodes,
          startTime: performance.now(),
          duration: 420,
          width,
          height,
          cols,
          rows,
        };
        ensureAnimationTicker();
        drawNpcLayer(0);
      }

      function renderNpcVisionCones(npcList, width, height, cols, rows, scene) {
        const layer = pixiLayers.vision;
        if (!layer) return;
        layer.clear();
        if (!npcList || !npcList.length) {
          return;
        }
        const tileWidth = width / cols;
        const tileHeight = height / rows;
        const baseRadius = Math.max(tileWidth, tileHeight);
        npcList.slice(0, 32).forEach((npc, idx) => {
          const cone = npc.view_cone || npc.vision_cone || npc.vision;
          if (!cone || cone.enabled === false) {
            return;
          }
          const seed = npc.id || npc.npc_id || npc.name || `npc-${idx}`;
          const coord =
            typeof npc.x === "number" && typeof npc.y === "number"
              ? { x: npc.x, y: npc.y }
              : hashToCoord(seed, cols, rows);
          const baseX = coord.x * tileWidth + tileWidth / 2;
          const baseY = coord.y * tileHeight + tileHeight / 2;
          const rangeTiles = clamp(
            Number(cone.range ?? cone.distance ?? cone.radius ?? 4),
            0.25,
            16
          );
          const radius = baseRadius * rangeTiles;
          const directionDeg =
            cone.angle ?? cone.direction ?? cone.heading ?? npc.angle ?? npc.heading ?? 0;
          const spreadDeg = clamp(
            Number(cone.spread ?? cone.fov ?? cone.angle_range ?? 60),
            10,
            180
          );
          const direction = (directionDeg * Math.PI) / 180;
          const spread = (spreadDeg * Math.PI) / 180;
          const steps = Math.max(6, Math.floor(spreadDeg / 5));
          const color = parseColorHex(
            cone.color ||
              (cone.hostile || npc.hostile
                ? scenePaletteColors.highlightCrit
                : scenePaletteColors.visionCone),
            scenePaletteColors.visionCone
          );
          layer.beginFill(color, 0.12);
          layer.moveTo(baseX, baseY);
          for (let i = 0; i <= steps; i += 1) {
            const t = i / steps;
            const angle = direction - spread / 2 + t * spread;
            const x = baseX + Math.cos(angle) * radius;
            const y = baseY + Math.sin(angle) * radius;
            layer.lineTo(x, y);
          }
          layer.lineTo(baseX, baseY);
          layer.endFill();
          layer.lineStyle(1, color, 0.45);
          layer.moveTo(baseX, baseY);
          for (let i = 0; i <= steps; i += 1) {
            const t = i / steps;
            const angle = direction - spread / 2 + t * spread;
            const x = baseX + Math.cos(angle) * radius;
            const y = baseY + Math.sin(angle) * radius;
            layer.lineTo(x, y);
          }
          layer.lineTo(baseX, baseY);
        });
        if (scene && scene.camera) {
          layer.zIndex = 5;
        }
      }

      function drawPlayerLayer(progress) {
        const layer = pixiLayers.player;
        if (!layer || !playerAnimation) return;
        layer.clear();
        const interpX =
          playerAnimation.startX +
          (playerAnimation.targetX - playerAnimation.startX) * progress;
        const interpY =
          playerAnimation.startY +
          (playerAnimation.targetY - playerAnimation.startY) * progress;
        let offsetX = 0;
        let offsetY = 0;
        if (playerAnimation.impact) {
          const wobble =
            Math.sin(progress * Math.PI) *
            (playerAnimation.radius * 0.35);
          offsetX = Math.cos(playerAnimation.impactAngle) * wobble;
          offsetY = Math.sin(playerAnimation.impactAngle) * wobble;
        }
        const currentX = interpX + offsetX;
        const currentY = interpY + offsetY;
        playerAnimation.currentX = currentX;
        playerAnimation.currentY = currentY;
        const stridePulse =
          Math.sin(progress * Math.PI * 2) * playerAnimation.radius * 0.12;
        const radius = playerAnimation.radius + stridePulse;
        const hasTrail = playerAnimation.trailLength > 2;
        if (hasTrail) {
          layer.lineStyle(1.4, scenePaletteColors.playerLine, 0.3);
          layer.moveTo(playerAnimation.startX, playerAnimation.startY);
          layer.lineTo(currentX, currentY);
        }
        layer.lineStyle(2, scenePaletteColors.playerLine, 0.9);
        layer.beginFill(scenePaletteColors.playerFill, 0.6);
        layer.drawCircle(currentX, currentY, radius);
        layer.endFill();
        layer.beginFill(0xffffff, 0.12);
        layer.drawCircle(currentX, currentY, Math.max(2, radius * 0.6));
        layer.endFill();
      }

      function stepPlayerAnimation() {
        if (!playerAnimation || !pixiLayers.player) {
          return;
        }
        const now = performance.now();
        const duration = playerAnimation.duration || 320;
        const progress = easeOutCubic(
          Math.min(1, (now - playerAnimation.startTime) / duration)
        );
        drawPlayerLayer(progress);
        if (progress >= 1) {
          playerAnimation.startX = playerAnimation.targetX;
          playerAnimation.startY = playerAnimation.targetY;
          playerAnimation.currentX = playerAnimation.targetX;
          playerAnimation.currentY = playerAnimation.targetY;
          playerAnimation.startTime = now;
        }
      }

      function clearPlayerAnimation() {
        playerAnimation = null;
        if (pixiLayers.player && pixiLayers.player.clear) {
          pixiLayers.player.clear();
        }
      }

      function updatePlayerAvatar(player, width, height, cols, rows) {
        if (!pixiLayers.player) return;
        if (!player) {
          clearPlayerAnimation();
          return;
        }
        const coord = getPlayerCoord(player, cols, rows);
        const tileWidth = width / cols;
        const tileHeight = height / rows;
        const px = coord.x * tileWidth + tileWidth / 2;
        const py = coord.y * tileHeight + tileHeight / 2;
        const prev = playerAnimation || {};
        const dx = px - (prev.currentX ?? prev.targetX ?? px);
        const dy = py - (prev.currentY ?? prev.targetY ?? py);
        const trailLength = Math.hypot(dx, dy);
        const impact =
          player?.animation === "hit" || player?.status === "blocked";
        playerAnimation = {
          startX: prev.currentX ?? prev.targetX ?? px,
          startY: prev.currentY ?? prev.targetY ?? py,
          targetX: px,
          targetY: py,
          currentX: prev.currentX ?? px,
          currentY: prev.currentY ?? py,
          startTime: performance.now(),
          duration: impact ? 260 : 360,
          radius: Math.min(tileWidth, tileHeight) / 3,
          impact,
          impactAngle: impact
            ? Math.atan2(dy || 0.001, dx || 0.001) + Math.PI
            : Math.atan2(dy || 0.001, dx || 0.001),
          trailLength,
        };
        ensureAnimationTicker();
        drawPlayerLayer(0);
      }

      let radialMenuTimeout = null;
      let radialAnchorTimeout = null;
      let lastInteractionTargets = [];
      let dragState = null;
      let dragGhost = null;
      let npcAnimation = null;
      let playerAnimation = null;
      let animationTickerAttached = false;
      let lastFinalLogSignature = null;

      function ensureRadialMenuRoot() {
        let menu = document.getElementById("radialMenu");
        if (!menu) {
          menu = document.createElement("div");
          menu.id = "radialMenu";
          menu.className = "radial-menu";
          menu.setAttribute("role", "menu");
          menu.innerHTML = `
            <div class="radial-context" id="radialMenuContext"></div>
            <div class="radial-center" id="radialMenuLabel">Context</div>
            <div class="radial-actions" id="radialMenuActions"></div>
          `;
          document.body.appendChild(menu);
          menu.dataset.bound = "true";
          menu.addEventListener("pointerenter", () => {
            if (radialMenuTimeout) {
              clearTimeout(radialMenuTimeout);
              radialMenuTimeout = null;
            }
          });
          menu.addEventListener("pointerleave", () => {
            hideRadialMenu();
          });
          window.addEventListener("pointerdown", (evt) => {
            if (
              menu.classList.contains("visible") &&
              !menu.contains(evt.target)
            ) {
              hideRadialMenu(true);
            }
          });
        }
        return menu;
      }

      function isNpcTarget(target) {
        if (!target) return false;
        const tokens = [
          target.target_type,
          target.type,
          target.category,
          target.target_id,
          target.id,
        ]
          .filter(Boolean)
          .map((item) => item.toString().toLowerCase());
        if (tokens.some((token) => token.includes("npc"))) {
          return true;
        }
        if (
          target.role ||
          target.stance ||
          target.trust != null ||
          (Array.isArray(target.tags) && target.tags.length)
        ) {
          return true;
        }
        return false;
      }

      function ensureRadialAnchorPanel() {
        let panel = document.getElementById("radialAnchorPanel");
        if (!panel) {
          panel = document.createElement("div");
          panel.id = "radialAnchorPanel";
          panel.className = "radial-anchor-panel";
          panel.innerHTML = `
            <div class="radial-anchor-name"></div>
            <div class="radial-anchor-meta"></div>
            <div class="radial-anchor-notes small"></div>
          `;
          document.body.appendChild(panel);
        }
        return panel;
      }

      function hideRadialAnchorPanel(immediate = false) {
        const panel = document.getElementById("radialAnchorPanel");
        if (!panel) return;
        if (radialAnchorTimeout) {
          clearTimeout(radialAnchorTimeout);
          radialAnchorTimeout = null;
        }
        if (immediate) {
          panel.classList.remove("visible");
          return;
        }
        radialAnchorTimeout = setTimeout(() => {
          panel.classList.remove("visible");
        }, 450);
      }

      function hideRadialMenu(immediate = false) {
        const menu = ensureRadialMenuRoot();
        if (radialMenuTimeout) {
          clearTimeout(radialMenuTimeout);
          radialMenuTimeout = null;
        }
        if (immediate) {
          menu.classList.remove("visible");
          hideRadialAnchorPanel(true);
          return;
        }
        radialMenuTimeout = setTimeout(() => {
          menu.classList.remove("visible");
          hideRadialAnchorPanel(true);
        }, 600);
      }

      function renderRadialAnchorPanel(target, anchorInfo) {
        if (!target || !anchorInfo) {
          hideRadialAnchorPanel(true);
          return;
        }
        const panel = ensureRadialAnchorPanel();
        if (radialAnchorTimeout) {
          clearTimeout(radialAnchorTimeout);
          radialAnchorTimeout = null;
        }
        const nameEl = panel.querySelector(".radial-anchor-name");
        if (nameEl) {
          nameEl.textContent =
            target.name ||
            target.label ||
            target.alias ||
            target.target_id ||
            "Target";
        }
        const metaEl = panel.querySelector(".radial-anchor-meta");
        if (metaEl) {
          metaEl.innerHTML = "";
          const metaBits = [];
          const pushMeta = (value) => {
            if (value === undefined || value === null) return;
            let text = "";
            if (typeof value === "number") {
              text = value.toString();
            } else if (typeof value === "string") {
              text = value;
            } else {
              return;
            }
            text = text.trim();
            if (text) {
              metaBits.push(text);
            }
          };
          pushMeta(target.location || target.room || target.zone);
          pushMeta(
            target.status ||
              target.stance ||
              target.disposition ||
              target.alert
          );
          if (Number.isFinite(target.trust)) {
            pushMeta(`Trust ${target.trust}`);
          } else if (Number.isFinite(target.trust_score)) {
            pushMeta(`Trust ${target.trust_score}`);
          }
          pushMeta(target.distance || target.range_label);
          const tagPool = [];
          if (Array.isArray(target.tags)) {
            tagPool.push(...target.tags);
          }
          if (Array.isArray(target.traits)) {
            tagPool.push(...target.traits);
          }
          tagPool.slice(0, 2).forEach((entry) => pushMeta(entry));
          const uniqueMeta = [];
          const seen = new Set();
          metaBits.forEach((bit) => {
            if (!seen.has(bit)) {
              uniqueMeta.push(bit);
              seen.add(bit);
            }
          });
          const finalBits = uniqueMeta.length ? uniqueMeta : ["HazÄ±r"];
          finalBits.slice(0, 5).forEach((bit) => {
            const span = document.createElement("span");
            span.textContent = bit;
            metaEl.appendChild(span);
          });
        }
        const notesEl = panel.querySelector(".radial-anchor-notes");
        if (notesEl) {
          const detail =
            (typeof target.notes === "string" && target.notes.trim()) ||
            (typeof target.summary === "string" && target.summary.trim()) ||
            (typeof target.description === "string" &&
              target.description.trim()) ||
            "";
          if (detail) {
            const limit = 160;
            const trimmed =
              detail.length > limit
                ? `${detail.slice(0, limit - 1).trimEnd()}â¦`
                : detail;
            notesEl.textContent = trimmed;
            notesEl.style.display = "block";
          } else {
            notesEl.textContent = "";
            notesEl.style.display = "none";
          }
        }
        const width = panel.offsetWidth || 200;
        const height = panel.offsetHeight || 120;
        const tileWidth = anchorInfo.tileWidth || 0;
        const tileHeight = anchorInfo.tileHeight || 0;
        const anchorX = anchorInfo.x + tileWidth * 0.6;
        const anchorY = anchorInfo.y - tileHeight * 0.5;
        const safeX = clamp(
          anchorX,
          width / 2 + 12,
          window.innerWidth - width / 2 - 12
        );
        const safeY = clamp(
          anchorY,
          height + 12,
          window.innerHeight - 12
        );
        panel.style.left = `${safeX}px`;
        panel.style.top = `${safeY}px`;
        requestAnimationFrame(() => {
          panel.classList.add("visible");
        });
      }

      function showRadialMenu(target, actions, position) {
        const menu = ensureRadialMenuRoot();
        if (radialMenuTimeout) {
          clearTimeout(radialMenuTimeout);
          radialMenuTimeout = null;
        }
        const label = document.getElementById("radialMenuLabel");
        const actionBox = document.getElementById("radialMenuActions");
        if (!actionBox) return;
        const targetName =
          target?.name ||
          target?.label ||
          target?.id ||
          target?.target_id ||
          "TARGET";
        label.textContent = targetName;
        const contextBox = document.getElementById("radialMenuContext");
        if (contextBox) {
          const metaBits = [];
          if (target?.location) {
            metaBits.push(target.location);
          }
          if (target?.status) {
            metaBits.push(target.status);
          }
          const detail =
            target?.notes && typeof target.notes === "string"
              ? target.notes
              : "";
          const metaMarkup = metaBits.length
            ? metaBits.map((bit) => `<span>${bit}</span>`).join("")
            : "<span>HazÄ±r</span>";
          contextBox.innerHTML = `
            <strong>${targetName}</strong>
            <div class="radial-meta">${metaMarkup}</div>
            ${detail ? `<div class="small" style="margin-top:4px;">${detail}</div>` : ""}
          `;
        }
        actionBox.innerHTML = "";
        (actions || []).forEach((action) => {
          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = "radial-button";
          btn.textContent = action.label || action.action_id || "Action";
          btn.disabled = action.enabled === false;
          btn.title = action.summary || "";
          if (action.safe_function && action.enabled !== false) {
            btn.addEventListener("click", () => {
              hideRadialMenu(true);
              runSafeAction(action.safe_function, {
                target_id: target.target_id || target.id,
                action_id: action.action_id,
              });
            });
          }
          actionBox.appendChild(btn);
        });
        let screenX = position?.x ?? null;
        let screenY = position?.y ?? null;
        let anchorInfo = null;
        if (
          position &&
          position.col != null &&
          position.row != null
        ) {
          const tilePos = tileToScreenPosition(position.col, position.row);
          if (tilePos) {
            screenX = tilePos.x;
            screenY = tilePos.y;
            anchorInfo = tilePos;
          }
        }
        if (screenX == null || screenY == null) {
          screenX = window.innerWidth / 2;
          screenY = window.innerHeight / 2;
        }
        menu.dataset.anchor = "";
        const shouldAnchorPanel = Boolean(anchorInfo && isNpcTarget(target));
        if (shouldAnchorPanel) {
          screenX += anchorInfo.tileWidth * 0.5 + 18;
          screenY -= anchorInfo.tileHeight * 0.25;
          menu.dataset.anchor = "npc";
        }
        const menuRect = menu.getBoundingClientRect();
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        const offsetX = clamp(
          screenX - menuRect.width / 2,
          12,
          viewportWidth - menuRect.width - 12
        );
        const offsetY = clamp(
          screenY - menuRect.height / 2,
          12,
          viewportHeight - menuRect.height - 12
        );
        menu.style.left = `${offsetX}px`;
        menu.style.top = `${offsetY}px`;
        menu.classList.add("visible");
        if (shouldAnchorPanel) {
          renderRadialAnchorPanel(target, anchorInfo);
        } else {
          hideRadialAnchorPanel(true);
        }
      }

      function ensureDragGhost() {
        if (!dragGhost) {
          dragGhost = document.createElement("div");
          dragGhost.className = "drag-ghost";
          document.body.appendChild(dragGhost);
        }
        return dragGhost;
      }

      function updateDragGhost(slot, clientX, clientY, isValid) {
        const ghost = ensureDragGhost();
        ghost.textContent =
          slot?.label ||
          slot?.item_id ||
          slot?.slot_id ||
          slot?.safe_function ||
          "Item";
        ghost.style.left = `${clientX}px`;
        ghost.style.top = `${clientY}px`;
        ghost.classList.add("visible");
        ghost.classList.toggle("invalid", !isValid);
      }

      function hideDragGhost() {
        if (dragGhost) {
          dragGhost.classList.remove("visible");
          dragGhost.classList.remove("invalid");
        }
      }

      function initPixiScene() {
        if (typeof PIXI === "undefined") {
          console.warn("PixiJS is not available.");
          return null;
        }
        if (pixiApp) {
          return pixiApp;
        }
        const container = document.getElementById("sceneContainer");
        if (!container) {
          return null;
        }
        pixiApp = new PIXI.Application({
          width: container.clientWidth || 640,
          height: container.clientHeight || 360,
          backgroundAlpha: 0,
          antialias: true,
          resolution: window.devicePixelRatio || 1,
          autoDensity: true,
        });
        container.innerHTML = "";
        container.appendChild(pixiApp.view);
        pixiApp.view.addEventListener("contextmenu", (evt) => {
          evt.preventDefault();
          hideRadialMenu(true);
        });
        pixiLayers.root = new PIXI.Container();
        pixiApp.stage.addChild(pixiLayers.root);
        pixiLayers.grid = new PIXI.Graphics();
        pixiLayers.overlays = new PIXI.Graphics();
        pixiLayers.particles = new PIXI.Container();
        pixiLayers.vision = new PIXI.Graphics();
        pixiLayers.highlights = new PIXI.Graphics();
        pixiLayers.npc = new PIXI.Graphics();
        pixiLayers.player = new PIXI.Graphics();
        pixiLayers.cinematic = new PIXI.Graphics();
        pixiLayers.dragTargets = new PIXI.Graphics();
        pixiLayers.pulse = new PIXI.Graphics();
        pixiLayers.dragPreview = new PIXI.Graphics();
        pixiLayers.root.addChild(
          pixiLayers.grid,
          pixiLayers.overlays,
          pixiLayers.particles,
          pixiLayers.vision,
          pixiLayers.highlights,
          pixiLayers.npc,
          pixiLayers.player,
          pixiLayers.cinematic,
          pixiLayers.dragTargets,
          pixiLayers.dragPreview,
          pixiLayers.pulse
        );
        pixiApp.stage.interactive = true;
        pixiApp.stage.hitArea = pixiApp.renderer.screen;
        pixiApp.stage.on("pointerdown", handlePixiPointerDown);
        pixiApp.stage.on("pointermove", handlePixiPointerMove);
        pixiApp.stage.on("pointerup", handlePixiPointerUp);
        pixiApp.stage.on("pointerupoutside", handlePixiPointerUp);
        pixiApp.view.addEventListener("wheel", handleSceneWheel, { passive: false });
        window.addEventListener("resize", resizePixiScene);
        resizePixiScene();
        applyCameraState();
        return pixiApp;
      }

      function resizePixiScene() {
        if (!pixiApp) return;
        const container = document.getElementById("sceneContainer");
        if (!container) return;
        const width = container.clientWidth || 640;
        const height = container.clientHeight || 360;
        pixiApp.renderer.resize(width, height);
        applyCameraState();
      }

      function clearPixiScene() {
        Object.entries(pixiLayers).forEach(([key, layer]) => {
          if (!layer || layer === pixiLayers.root) {
            return;
          }
          if (layer.clear) {
            layer.clear();
          }
          if (layer.removeChildren && key !== "root") {
            layer.removeChildren();
          }
        });
        npcAnimation = null;
        playerAnimation = null;
        particleEmitters.forEach((emitter) => destroyParticleEmitter(emitter));
        particleEmitters.clear();
      }

      function getTileRect(seed, cols, rows, width, height) {
        const { x, y } = hashToCoord(seed, cols, rows);
        const tileWidth = width / cols;
        const tileHeight = height / rows;
        return {
          x: x * tileWidth,
          y: y * tileHeight,
          w: tileWidth,
          h: tileHeight,
        };
      }

      function areaToPixelRect(area, cols, rows, width, height) {
        if (!area) return null;
        const tileWidth = width / Math.max(1, cols);
        const tileHeight = height / Math.max(1, rows);
        return {
          x: area.col * tileWidth,
          y: area.row * tileHeight,
          w: Math.max(tileWidth, area.width * tileWidth),
          h: Math.max(tileHeight, area.height * tileHeight),
        };
      }

      function resolveOverlayArea(overlay, cols, rows) {
        if (!overlay) return null;
        const candidate = overlay.bounds || overlay.area || overlay.region;
        if (candidate) {
          const normalized = normalizeAreaBounds(candidate, cols, rows);
          if (normalized) return normalized;
        }
        if (
          Array.isArray(overlay.tile) &&
          overlay.tile.length >= 2
        ) {
          const normalized = normalizeAreaBounds(
            overlay.tile.length >= 4
              ? overlay.tile
              : [overlay.tile[0], overlay.tile[1], 1, 1],
            cols,
            rows
          );
          if (normalized) return normalized;
        }
        if (
          typeof overlay.col === "number" &&
          typeof overlay.row === "number"
        ) {
          return normalizeAreaBounds(
            {
              col: overlay.col,
              row: overlay.row,
              width: overlay.width || 1,
              height: overlay.height || 1,
            },
            cols,
            rows
          );
        }
        return null;
      }

      function collectUnifiedOverlays(scene, themeOverride = null) {
        const combined = [];
        const base = scene && Array.isArray(scene.overlays) ? scene.overlays : [];
        base.forEach((entry) => {
          if (entry) combined.push(entry);
        });
        const seenIds = new Set(
          combined
            .map((entry) =>
              entry && entry.id != null ? entry.id.toString() : null
            )
            .filter(Boolean)
        );
        const appendFrom = (source, sourceKey) => {
          (source || []).forEach((entry, idx) => {
            if (!entry) return;
            const rawId =
              entry.id ??
              entry.label ??
              entry.name ??
              `${sourceKey}-${idx}`;
            const baseId = rawId.toString();
            let overlayId = baseId;
            let suffix = 1;
            while (seenIds.has(overlayId)) {
              overlayId = `${baseId}-${suffix}`;
              suffix += 1;
            }
            seenIds.add(overlayId);
            combined.push({
              id: overlayId,
              label: entry.label || entry.name,
              color: entry.color || entry.tint,
              alpha: entry.alpha,
              pattern: entry.pattern || entry.style,
              bounds: entry.bounds || entry.area || entry.region,
              tile: entry.tile,
              detail: entry.detail,
              severity: entry.severity,
              source: sourceKey,
            });
          });
        };
        const sceneAssets =
          scene &&
          scene.theme_assets &&
          Array.isArray(scene.theme_assets.scene_overlays)
            ? scene.theme_assets.scene_overlays
            : null;
        const themeAssets =
          themeOverride &&
          themeOverride.theme_assets &&
          Array.isArray(themeOverride.theme_assets.scene_overlays)
            ? themeOverride.theme_assets.scene_overlays
            : null;
        if (sceneAssets) {
          appendFrom(sceneAssets, "theme");
        } else if (themeAssets) {
          appendFrom(themeAssets, "theme");
        }
        return combined;
      }

      function getPlayerCoord(player, cols, rows) {
        if (!player) {
          return hashToCoord("player", cols, rows);
        }
        if (
          typeof player.x === "number" &&
          typeof player.y === "number" &&
          player.x >= 0 &&
          player.y >= 0
        ) {
          return { x: player.x, y: player.y };
        }
        return hashToCoord(player.id || player.name || "player", cols, rows);
      }

      function updatePixiScene(scene, theme) {
        const app = initPixiScene();
        if (!app) return;
        if (!scene) {
          clearPixiScene();
          return;
        }
        resizePixiScene();
        const width = app.renderer.width;
        const height = app.renderer.height;
        const cols = Math.max(4, Number(scene.grid_columns) || 12);
        const rows = Math.max(4, Number(scene.grid_rows) || 12);
        const grid = pixiLayers.grid;
        const overlays = pixiLayers.overlays;
        const highlights = pixiLayers.highlights;
        const npcLayer = pixiLayers.npc;
        const playerLayer = pixiLayers.player;
        const cinematicLayer = pixiLayers.cinematic;
        const pulse = pixiLayers.pulse;
        scenePaletteColors.grid = resolveThemeColorHex("grid", 0x243c5a, theme);
        scenePaletteColors.overlay = resolveThemeColorHex("overlay", 0x1d4ed8, theme);
        scenePaletteColors.hazard = resolveThemeColorHex("danger", 0xfb7185, theme);
        scenePaletteColors.highlightInfo = resolveThemeColorHex("info", 0x22d3ee, theme);
        scenePaletteColors.highlightWarn = resolveThemeColorHex("warning", 0xfbbf24, theme);
        scenePaletteColors.highlightCrit = resolveThemeColorHex("danger", 0xf87171, theme);
        scenePaletteColors.playerLine = resolveThemeColorHex("player", 0x22d3ee, theme);
        scenePaletteColors.playerFill = resolveThemeColorHex("player_fill", 0x0ea5e9, theme);
        scenePaletteColors.npcPulse = resolveThemeColorHex("npc", 0xfcd34d, theme);
        scenePaletteColors.visionCone = resolveThemeColorHex("vision", 0xfcd34d, theme);
        if (grid) {
          grid.clear();
          grid.lineStyle(1, scenePaletteColors.grid, 0.4);
          for (let c = 0; c <= cols; c += 1) {
            grid.moveTo((width / cols) * c, 0);
            grid.lineTo((width / cols) * c, height);
          }
          for (let r = 0; r <= rows; r += 1) {
            grid.moveTo(0, (height / rows) * r);
            grid.lineTo(width, (height / rows) * r);
          }
        }
        if (overlays) {
          overlays.clear();
          const overlayEntries = collectUnifiedOverlays(scene, theme);
          overlayEntries.slice(0, 24).forEach((overlay, idx) => {
            const area = resolveOverlayArea(overlay, cols, rows);
            const rect = area
              ? areaToPixelRect(area, cols, rows, width, height)
              : getTileRect(
                  overlay?.id || overlay?.label || `overlay-${idx}`,
                  cols,
                  rows,
                  width,
                  height
                );
            if (!rect) {
              return;
            }
            const fillColor = parseColorHex(
              overlay?.color || resolveThemeColor("overlay", "#1d4ed8", theme),
              scenePaletteColors.overlay
            );
            const rawAlpha = Number(overlay?.alpha);
            const overlayAlpha = Number.isFinite(rawAlpha)
              ? clamp(rawAlpha, 0.05, 0.85)
              : 0.25;
            overlays.beginFill(fillColor, overlayAlpha);
            overlays.drawRoundedRect(
              rect.x + 2,
              rect.y + 2,
              Math.max(4, rect.w - 4),
              Math.max(4, rect.h - 4),
              4
            );
            overlays.endFill();
            const pattern = (overlay?.pattern || "").toLowerCase();
            if (pattern === "outline") {
              overlays.lineStyle(
                2,
                fillColor,
                Math.min(1, overlayAlpha + 0.25)
              );
              overlays.drawRoundedRect(
                rect.x + 1,
                rect.y + 1,
                Math.max(2, rect.w - 2),
                Math.max(2, rect.h - 2),
                4
              );
              overlays.lineStyle(0);
            } else if (pattern === "hatch" || pattern === "chevron") {
              overlays.lineStyle(
                1,
                fillColor,
                Math.min(1, overlayAlpha + 0.2)
              );
              const spacing = 12;
              for (
                let offset = -rect.h;
                offset < rect.w + rect.h;
                offset += spacing
              ) {
                overlays.moveTo(rect.x + offset, rect.y);
                overlays.lineTo(
                  rect.x + offset + rect.h,
                  rect.y + rect.h
                );
              }
              overlays.lineStyle(0);
            }
          });
          (scene.hazard_zones || []).slice(0, 12).forEach((hazard, idx) => {
            const seed = hazard.id || hazard.label || `hazard-${idx}`;
            const rect = getTileRect(seed, cols, rows, width, height);
            const hazardColor = parseColorHex(
              hazard.color,
              scenePaletteColors.hazard
            );
            overlays.beginFill(hazardColor, 0.2);
            overlays.drawRoundedRect(
              rect.x + 6,
              rect.y + 6,
              rect.w - 12,
              rect.h - 12,
              4
            );
            overlays.endFill();
          });
          (scene.fog_zones || []).slice(0, 12).forEach((fog, idx) => {
            const seed = fog.id || fog.label || `fog-${idx}`;
            const rect = getTileRect(seed, cols, rows, width, height);
            const fogColor = parseColorHex(
              resolveThemeColor("fog", "#e2e8f0", theme),
              0xe2e8f0
            );
            overlays.beginFill(fogColor, 0.15);
            overlays.drawRect(rect.x, rect.y, rect.w, rect.h);
            overlays.endFill();
          });
        }
        if (highlights) {
          highlights.clear();
          const highlightList = scene.highlights || scene.event_markers || [];
          highlightList.slice(0, 16).forEach((highlight, idx) => {
            const seed = highlight.id || highlight.label || `highlight-${idx}`;
            const rect = getTileRect(seed, cols, rows, width, height);
            const severity = (highlight.status || highlight.severity || "info").toLowerCase();
            const color =
              severity === "critical"
                ? scenePaletteColors.highlightCrit
                : severity === "warning"
                ? scenePaletteColors.highlightWarn
                : scenePaletteColors.highlightInfo;
            highlights.beginFill(color, 0.35);
            highlights.drawRect(rect.x + 4, rect.y + 4, rect.w - 8, rect.h - 8);
            highlights.endFill();
          });
        }
        const npcList =
          scene.npc_positions ||
          (scene.map_state && scene.map_state.npc_positions) ||
          [];
        updateNpcTargets(npcList, width, height, cols, rows);
        renderNpcVisionCones(npcList, width, height, cols, rows, scene);
        updatePlayerAvatar(scene.player, width, height, cols, rows);
        syncParticleEmitters(scene.effects || [], width, height, cols, rows);
        if (cinematicLayer) {
          renderCinematicEffects(
            scene.effects || [],
            cinematicLayer,
            width,
            height,
            cols,
            rows,
            scene
          );
        }
        if (pulse) {
          pulse.clear();
        }
        syncCameraFromScene(scene, width, height, cols, rows);
        applyCameraState();
      }

      async function runSafeAction(name, kwargs = {}, metadata = {}) {
        if (!name || actionInFlight) return;
        actionInFlight = true;
        try {
          const response = await api("/game/action", {
            method: "POST",
            body: JSON.stringify({
              name,
              kwargs,
              metadata,
            }),
          });
          if (response.player_view) {
            updatePlayerView(response.player_view);
          } else {
            await refreshState();
          }
          return response;
        } catch (err) {
          console.warn("Action failed", err);
          appendMapActivityEntry(
            `<strong>Action failed</strong><br>${err.message || err}`
          );
          throw err;
        } finally {
          actionInFlight = false;
        }
      }

      async function queueMovement(key) {
        const directionMap = { w: "north", a: "west", s: "south", d: "east" };
        const direction = directionMap[key.toLowerCase()];
        if (!direction) return;
        appendMapActivityEntry(
          `<strong>Input</strong><br>Move request: ${direction}`
        );
        await runSafeAction("move_player", { direction });
      }

      function handleKeyShortcuts(event) {
        const target = event.target;
        if (target && ["INPUT", "TEXTAREA", "SELECT"].includes(target.tagName)) {
          return;
        }
        const key = event.key.toLowerCase();
        if (["w", "a", "s", "d"].includes(key)) {
          event.preventDefault();
          queueMovement(key);
          return;
        }
        if (key === "q") {
          event.preventDefault();
          setPlannerActiveIndex(plannerState.activeIndex - 1);
          return;
        }
        if (key === "e") {
          event.preventDefault();
          setPlannerActiveIndex(plannerState.activeIndex + 1);
          return;
        }
        if (key === " ") {
          event.preventDefault();
          applyActiveRecommendation();
          return;
        }
        if (key === "tab") {
          event.preventDefault();
          cycleLayerFilter(event.shiftKey ? -1 : 1);
        }
      }

      function handlePixiPointerDown(event) {
        if (!pixiApp) return;
        if (event.data.button === 1) {
          startCameraDrag(event);
          return;
        }
        if (!lastSceneSnapshot) return;
        hideRadialMenu(true);
        const cols = Math.max(
          4,
          Number(lastSceneSnapshot.grid_columns) || 12
        );
        const rows = Math.max(
          4,
          Number(lastSceneSnapshot.grid_rows) || 12
        );
        const local = event.data.getLocalPosition(
          pixiLayers.root || pixiApp.stage
        );
        const width = pixiApp.renderer.width;
        const height = pixiApp.renderer.height;
        const col = clamp(
          Math.floor((local.x / width) * cols),
          0,
          cols - 1
        );
        const row = clamp(
          Math.floor((local.y / height) * rows),
          0,
          rows - 1
        );
        const tileId = `tile-${col}-${row}`;
        if (event.data.button === 2) {
          event.stopPropagation();
          event.data.originalEvent?.preventDefault?.();
          const npcTargets = collectInteractionTargetsAt(col, row);
          if (npcTargets.length) {
            showRadialMenu(
              npcTargets[0],
              npcTargets[0].actions || [],
              { col, row }
            );
            pulseSceneMarkers([tileId]);
            return;
          }
        }
        pulseSceneMarkers([tileId]);
        runSafeAction("move_player", {
          target_col: col,
          target_row: row,
        });
      }

      function handlePixiPointerMove(event) {
        if (
          !cameraDragState.active ||
          (cameraDragState.pointerId !== null &&
            event.data.pointerId !== cameraDragState.pointerId)
        ) {
          return;
        }
        updateCameraDrag(event.data.global || { x: 0, y: 0 });
      }

      function handlePixiPointerUp(event) {
        if (
          cameraDragState.active &&
          (cameraDragState.pointerId === null ||
            !event ||
            event.data.pointerId === cameraDragState.pointerId)
        ) {
          endCameraDrag();
        }
      }

      async function api(path, opts = {}) {
        const timeoutMs = 300000; // 5 minutes
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), timeoutMs);

        try {
          const res = await fetch(path, {
            headers: { "Content-Type": "application/json" },
            signal: controller.signal,
            ...opts,
          });
          clearTimeout(timeoutId);
          if (!res.ok) throw new Error("Request failed");
          return await res.json();
        } catch (err) {
          clearTimeout(timeoutId);
          if (err.name === "AbortError") {
            throw new Error(
              "Request timed out after 5 minutes. LLM processing may take longer."
            );
          }
          throw err;
        }
      }

      function renderMetrics(panel) {
        const box = document.getElementById("metricsPanel");
        if (!panel) {
          box.innerHTML = '<p class="small">No metrics reported.</p>';
          return;
        }
        box.innerHTML = Object.entries(panel)
          .map(([key, val]) => {
            const pct = Math.max(0, Math.min(100, Number(val)));
            return `
            <div class="metric-row">
              <strong style="width:90px;text-transform:capitalize;">${key}</strong>
              <div class="metric-bar"><span style="width:${pct}%"></span></div>
              <span class="small">${val}</span>
            </div>`;
          })
          .join("");
      }

      function renderMiniMap(scene, themeOverride = null) {
        const canvas = document.getElementById("miniMapCanvas");
        const status = document.getElementById("miniMapStatus");
        if (!canvas || !canvas.getContext) {
          if (status) status.textContent = "";
          return;
        }
        const ctx = canvas.getContext("2d");
        const width = canvas.width;
        const height = canvas.height;
        ctx.clearRect(0, 0, width, height);
        if (!scene || !Object.keys(scene).length) {
          ctx.fillStyle = "#030712";
          ctx.fillRect(0, 0, width, height);
          if (status) status.textContent = "Mini map hazÄ±r deÄil.";
          return;
        }
        const cols = Math.max(1, Number(scene.grid_columns) || 12);
        const rows = Math.max(1, Number(scene.grid_rows) || 12);
        if (status) status.textContent = `Grid ${cols}Ã${rows}`;
        const palette = getThemePalette(scene);
        const bgColor = palette.mini_bg || palette.background || "#030712";
        const gridColor = palette.grid || "rgba(255,255,255,0.06)";
        const playerColor =
          palette.player || palette.accent || palette.primary || "#22d3ee";
        const npcColor =
          palette.npc ||
          palette.warning ||
          palette.secondary ||
          "#fcd34d";
        const highlightInfo = palette.info || "#22d3ee";
        const highlightWarn = palette.warning || "#fbbf24";
        const highlightCrit = palette.danger || "#f87171";
        ctx.fillStyle = bgColor;
        ctx.fillRect(0, 0, width, height);
        ctx.strokeStyle = gridColor;
        ctx.lineWidth = 1;
        const tileWidth = width / cols;
        const tileHeight = height / rows;
        for (let c = 0; c <= cols; c += 1) {
          ctx.beginPath();
          ctx.moveTo(c * tileWidth + 0.5, 0);
          ctx.lineTo(c * tileWidth + 0.5, height);
          ctx.stroke();
        }
        for (let r = 0; r <= rows; r += 1) {
          ctx.beginPath();
          ctx.moveTo(0, r * tileHeight + 0.5);
          ctx.lineTo(width, r * tileHeight + 0.5);
          ctx.stroke();
        }
        const overlayEntries = collectUnifiedOverlays(scene, themeOverride);
        overlayEntries.slice(0, 12).forEach((overlay, idx) => {
          const area = resolveOverlayArea(overlay, cols, rows);
          if (!area) return;
          const rect = {
            x: area.col * tileWidth,
            y: area.row * tileHeight,
            w: Math.max(tileWidth, area.width * tileWidth),
            h: Math.max(tileHeight, area.height * tileHeight),
          };
          const fillColor = toCssColor(
            overlay?.color || resolveThemeColor("overlay", "#1d4ed8", themeOverride),
            "#1d4ed8"
          );
          const rawAlpha = Number(overlay?.alpha);
          const overlayAlpha = Number.isFinite(rawAlpha)
            ? clamp(rawAlpha, 0.05, 0.7)
            : 0.2;
          ctx.save();
          ctx.globalAlpha = overlayAlpha;
          ctx.fillStyle = fillColor;
          ctx.fillRect(
            rect.x + 1,
            rect.y + 1,
            Math.max(2, rect.w - 2),
            Math.max(2, rect.h - 2)
          );
          ctx.restore();
          const pattern = (overlay?.pattern || "").toLowerCase();
          if (pattern === "outline") {
            ctx.save();
            ctx.globalAlpha = Math.min(1, overlayAlpha + 0.15);
            ctx.strokeStyle = fillColor;
            ctx.lineWidth = 1;
            ctx.strokeRect(
              rect.x + 0.5,
              rect.y + 0.5,
              Math.max(1, rect.w - 1),
              Math.max(1, rect.h - 1)
            );
            ctx.restore();
          } else if (pattern === "hatch" || pattern === "chevron") {
            ctx.save();
            ctx.globalAlpha = Math.min(1, overlayAlpha + 0.2);
            ctx.strokeStyle = fillColor;
            ctx.lineWidth = 1;
            const spacing = 6;
            for (
              let offset = -rect.h;
              offset < rect.w + rect.h;
              offset += spacing
            ) {
              ctx.beginPath();
              ctx.moveTo(rect.x + offset, rect.y);
              ctx.lineTo(rect.x + offset + rect.h, rect.y + rect.h);
              ctx.stroke();
            }
            ctx.restore();
          }
        });
        const toPoint = (coord) => ({
          x: (coord.x + 0.5) * tileWidth,
          y: (coord.y + 0.5) * tileHeight,
        });
        const drawMarker = (coord, color, radius = Math.max(2, tileWidth * 0.2)) => {
          const point = toPoint(coord);
          ctx.beginPath();
          ctx.fillStyle = color;
          ctx.arc(point.x, point.y, radius, 0, Math.PI * 2);
          ctx.fill();
        };
        const playerCoord = getPlayerCoord(scene.player, cols, rows);
        if (playerCoord) {
          const point = toPoint(playerCoord);
          const radius = Math.max(tileWidth, tileHeight) * 0.4;
          const gradient = ctx.createRadialGradient(
            point.x,
            point.y,
            radius * 0.1,
            point.x,
            point.y,
            radius
          );
          gradient.addColorStop(0, `${toCssColor(playerColor, "#22d3ee")}88`);
          gradient.addColorStop(1, `${toCssColor(playerColor, "#22d3ee")}11`);
          ctx.beginPath();
          ctx.fillStyle = gradient;
          ctx.arc(point.x, point.y, radius, 0, Math.PI * 2);
          ctx.fill();
          drawMarker(playerCoord, toCssColor(playerColor, "#22d3ee"), radius * 0.35);
        }
        const npcList =
          scene.npc_positions ||
          (scene.map_state && scene.map_state.npc_positions) ||
          [];
        npcList.slice(0, 24).forEach((npc, idx) => {
          const seed = npc.id || npc.npc_id || npc.name || `npc-${idx}`;
          let coord = null;
          if (typeof npc.x === "number" && typeof npc.y === "number") {
            coord = { x: npc.x, y: npc.y };
          } else {
            coord = hashToCoord(seed, cols, rows);
          }
          drawMarker(coord, toCssColor(npcColor, "#fcd34d"), Math.max(2, tileWidth * 0.2));
        });
        const highlights = scene.highlights || [];
        highlights.slice(0, 10).forEach((highlight, idx) => {
          const seed =
            highlight.id ||
            highlight.label ||
            highlight.detail ||
            `highlight-${idx}`;
          const coord = hashToCoord(seed, cols, rows);
          const severity = (highlight.status || highlight.severity || "info").toLowerCase();
          const color =
            severity === "critical"
              ? highlightCrit
              : severity === "warning"
              ? highlightWarn
              : highlightInfo;
          drawMarker(coord, toCssColor(color, "#22d3ee"), Math.max(3, tileWidth * 0.3));
        });
        if (scene.camera) {
          const target = resolveCameraTargetCoord(
            scene.camera,
            scene,
            cols,
            rows
          );
          if (target) {
            const point = toPoint(target);
            ctx.strokeStyle = toCssColor(palette.accent || "#60a5fa", "#60a5fa");
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(point.x, point.y, Math.max(4, tileWidth * 0.4), 0, Math.PI * 2);
            ctx.stroke();
          }
        }
      }

      function renderSceneState(scene, theme) {
        const meta = document.getElementById("sceneMeta");
        if (!meta) {
          return;
        }
        if (!scene || Object.keys(scene).length === 0) {
          meta.innerHTML = '<p class="small">Scene telemetry not available.</p>';
          lastSceneSnapshot = null;
          lastThemeSnapshot = null;
          updatePixiScene(null, null);
          renderMiniMap(null, null);
          return;
        }
        try {
          lastSceneSnapshot = JSON.parse(JSON.stringify(scene));
        } catch (err) {
          lastSceneSnapshot = scene;
        }
        try {
          lastThemeSnapshot = theme ? JSON.parse(JSON.stringify(theme)) : null;
        } catch (err) {
          lastThemeSnapshot = theme || null;
        }
        const cols = Math.max(4, Number(scene.grid_columns) || 12);
        const rows = Math.max(4, Number(scene.grid_rows) || 12);
        const player = scene.player || {};
        const themeName =
          (theme && theme.title) || scene.theme_id || "Siege Bastion";
        const focus =
          (scene.camera && scene.camera.focus) ||
          player.room ||
          scene.current_room ||
          "unknown";
        const effectText = (scene.effects || [])
          .map((fx) => fx.effect_type)
          .join(", ");
        meta.innerHTML = `
          <div><strong>Theme:</strong> ${themeName} | <strong>Room:</strong> ${focus}</div>
          <div class="small">Grid ${cols}Ã${rows} | Effects: ${
          effectText || "None"
        }</div>
        `;
        updatePixiScene(scene, theme);
        renderMiniMap(scene, theme);
      }

      function pulseSceneMarkers(ids) {
        if (
          !ids ||
          !ids.length ||
          !lastSceneSnapshot ||
          !pixiLayers.pulse ||
          !pixiApp
        ) {
          return;
        }
        const app = initPixiScene();
        if (!app) return;
        const width = app.renderer.width;
        const height = app.renderer.height;
        const cols = Math.max(
          4,
          Number(lastSceneSnapshot.grid_columns) || 12
        );
        const rows = Math.max(
          4,
          Number(lastSceneSnapshot.grid_rows) || 12
        );
        const pulse = pixiLayers.pulse;
        pulse.clear();
        const tileWidth = width / cols;
        const tileHeight = height / rows;
        ids.slice(0, 8).forEach((id, index) => {
          const { x, y } = hashToCoord(id, cols, rows);
          const color = index % 2 ? 0xf97316 : 0xa855f7;
          pulse.lineStyle(3, color, 0.9);
          pulse.drawRoundedRect(
            x * tileWidth + 4,
            y * tileHeight + 4,
            tileWidth - 8,
            tileHeight - 8,
            6
          );
        });
        setTimeout(() => pulse.clear(), 500);
      }

      function renderPlannerRecommendations(recommendations) {
        const list = document.getElementById("plannerRecommendations");
        if (!list) return;
        if (!recommendations || !recommendations.length) {
          plannerState.recommendations = [];
          plannerState.activeIndex = 0;
          list.innerHTML =
            '<li class="small">No planner guidance surfaced this turn.</li>';
          updatePlannerHighlight();
          return;
        }
        plannerState.recommendations = recommendations.slice();
        if (plannerState.activeIndex >= plannerState.recommendations.length) {
          plannerState.activeIndex = 0;
        }
        list.innerHTML = "";
        plannerState.recommendations.forEach((rec, idx) => {
          const risk = (rec.risk_level || "info").toLowerCase();
          const cls =
            risk === "high"
              ? "critical"
              : risk === "low"
              ? "info"
              : risk === "medium"
              ? "warning"
              : risk;
          const bias =
            rec.accept_bias != null
              ? ` Â· bias ${Math.round(rec.accept_bias * 100)}%`
              : "";
          const li = document.createElement("li");
          li.dataset.plannerIndex = String(idx);
          li.className = `${cls} ${
            idx === plannerState.activeIndex ? "active" : ""
          }`.trim();
          li.innerHTML = `
            <strong>${rec.summary}</strong>
            <div class="small">${rec.agent || "planner"} Â· ${
            rec.tone || "neutral"
          }${bias}</div>
            ${
              rec.detail
                ? `<div class="small" style="margin-top:4px;">${rec.detail}</div>`
                : ""
          }
          `;
          li.addEventListener("click", () => handlePlannerClick(idx));
          list.appendChild(li);
        });
        updatePlannerHighlight();
      }

      function handlePlannerClick(index) {
        setPlannerActiveIndex(index);
      }

      function setPlannerActiveIndex(nextIndex) {
        const len = plannerState.recommendations.length;
        if (!len) {
          plannerState.activeIndex = 0;
          updatePlannerHighlight();
          return;
        }
        const normalized = ((nextIndex % len) + len) % len;
        plannerState.activeIndex = normalized;
        updatePlannerHighlight();
      }

      function updatePlannerHighlight() {
        const list = document.getElementById("plannerRecommendations");
        if (!list) return;
        list.querySelectorAll("li[data-planner-index]").forEach((item) => {
          const idx = Number(item.getAttribute("data-planner-index"));
          if (Number.isNaN(idx)) return;
          if (idx === plannerState.activeIndex) {
            item.classList.add("active");
          } else {
            item.classList.remove("active");
          }
        });
      }

      function applyActiveRecommendation() {
        if (!plannerState.recommendations.length) return;
        const rec = plannerState.recommendations[plannerState.activeIndex];
        if (!rec || !rec.id) return;
        playTurn(rec.id);
      }

      function mapSeverityClass(level) {
        const key = (level || "info").toLowerCase();
        if (key === "high" || key === "critical" || key === "danger") {
          return "critical";
        }
        if (key === "medium" || key === "warning") {
          return "warning";
        }
        return "info";
      }

      function renderHudAlerts(alerts) {
        const list = document.getElementById("hudAlerts");
        if (!list) return;
        if (!alerts || !alerts.length) {
          list.innerHTML = '<li class="small">No HUD alerts.</li>';
          return;
        }
        list.innerHTML = alerts
          .map((alert) => {
            const cls = mapSeverityClass(alert.severity);
            return `<li class="status-pill ${cls}">
              <strong>${alert.title || alert.id}</strong>
              <span>${alert.detail || ""}</span>
            </li>`;
          })
          .join("");
      }

      function renderFinalSignals(signals) {
        const list = document.getElementById("finalSignals");
        if (!list) return;
        if (!signals || !signals.length) {
          list.innerHTML =
            '<li class="small">No finale telegraphs detected yet.</li>';
          return;
        }
        list.innerHTML = signals
          .map((signal) => {
            const cls = mapSeverityClass(signal.severity);
            const eta =
              signal.turns_until != null
                ? ` Â· ${signal.turns_until} turn(s)`
                : "";
            return `<li class="status-pill ${cls}">
              <strong>${signal.phase || "phase"}</strong>
              <span>${signal.description || ""}${eta}</span>
            </li>`;
          })
          .join("");
      }

      function renderFinalCinematic(cinematic) {
        const timelineEl = document.getElementById("finalTimeline");
        const npcEl = document.getElementById("finalNPCSpotlight");
        const mapEl = document.getElementById("finalMapEffects");
        if (!timelineEl || !npcEl || !mapEl) return;
        if (!cinematic) {
          timelineEl.innerHTML =
            '<li class="small">Play to completion to unlock the finale.</li>';
          npcEl.innerHTML = "";
          mapEl.innerHTML = "";
          return;
        }
        const timeline = cinematic.timeline || [];
        timelineEl.innerHTML = timeline.length
          ? timeline
              .map(
                (entry) =>
                  `<li class="status-pill info"><strong>${entry.title}</strong><span>${
                    entry.detail || ""
                  }${entry.turn != null ? ` Â· turn ${entry.turn}` : ""}</span></li>`
              )
              .join("")
          : '<li class="small">No timeline entries.</li>';
        const spotlight = cinematic.npc_spotlight || [];
        npcEl.innerHTML = spotlight.length
          ? spotlight
              .map(
                (npc) =>
                  `<li class="status-pill ${
                    (npc.status || "").toLowerCase()
                  }"><strong>${npc.name}</strong><span>${npc.fate || ""}${
                    npc.loyalty ? ` Â· loyalty ${npc.loyalty}` : ""
                  }</span></li>`
              )
              .join("")
          : '<li class="small">No NPC spotlight.</li>';
        const effects = cinematic.map_effects || [];
        mapEl.innerHTML = effects.length
          ? effects
              .map(
                (effect) =>
                  `<li class="status-pill ${mapSeverityClass(
                    effect.severity
                  )}"><strong>${effect.effect}</strong><span>${
                    effect.location || "global"
                  }</span></li>`
              )
              .join("")
          : '<li class="small">No map effects reported.</li>';
      }

      function applyFinalCinematicEffects(cinematic) {
        const layer = pixiLayers.cinematic;
        if (!layer) return;
        layer.clear();
        if (!cinematic) return;
        const app = initPixiScene();
        if (!app || !lastSceneSnapshot) {
          return;
        }
        const width = app.renderer.width;
        const height = app.renderer.height;
        const cols = Math.max(
          4,
          Number(lastSceneSnapshot.grid_columns) || 12
        );
        const rows = Math.max(
          4,
          Number(lastSceneSnapshot.grid_rows) || 12
        );
        const effects = cinematic.map_effects || [];
        effects.slice(0, 12).forEach((effect, idx) => {
          const seed = effect.location || effect.effect || `cine-${idx}`;
          const rect = getTileRect(seed, cols, rows, width, height);
          const severity = (effect.severity || "").toLowerCase();
          const color =
            effect.color
              ? Number.parseInt(effect.color.replace("#", ""), 16)
              : severity === "critical"
              ? 0xeb4034
              : severity === "warning"
              ? 0xfacc15
              : 0x38bdf8;
          layer.beginFill(color, 0.18);
          layer.drawRect(rect.x, rect.y, rect.w, rect.h);
          layer.endFill();
        });
      }

      function renderFinalOverlay(view, winLoss) {
        const overlay = document.getElementById("finalOverlay");
        if (!overlay) return;
        const summary = view && view.final_summary;
        if (!summary) {
          overlay.classList.add("hidden");
          lastFinalCinematic = null;
          applyFinalCinematicEffects(null);
          return;
        }
        overlay.classList.remove("hidden");
        const outcome = winLoss || {};
        const title = document.getElementById("finalTitle");
        const outcomeEl = document.getElementById("finalOutcome");
        const summaryEl = document.getElementById("finalSummaryText");
        const unlocksEl = document.getElementById("finalUnlocks");
        const summaryTitle =
          typeof summary === "string" ? null : summary.title || summary.label;
        if (title) {
          title.textContent = summaryTitle || "Campaign Complete";
        }
        if (outcomeEl) {
          outcomeEl.innerHTML = `<strong>Status:</strong> ${
            outcome.status || "unknown"
          } ${outcome.reason ? `(${outcome.reason})` : ""}`;
        }
        if (summaryEl) {
          const text =
            typeof summary === "string"
              ? summary
              : summary.text || summary.detail || JSON.stringify(summary, null, 2);
          summaryEl.textContent = text;
        }
        if (unlocksEl) {
          const unlocks =
            (view.meta_progression && view.meta_progression.unlocks) || [];
          unlocksEl.innerHTML = unlocks.length
            ? unlocks
                .map(
                  (entry) =>
                    `<span class="chip">${
                      entry.label || entry.id || "Unlock"
                    }</span>`
                )
                .join("")
            : "No new unlocks.";
        }
        lastFinalCinematic = view.final_cinematic || null;
        renderFinalCinematic(lastFinalCinematic);
        applyFinalCinematicEffects(lastFinalCinematic);
        logFinalMapEntry(view, winLoss);
      }

      function closeFinalOverlay() {
        const overlay = document.getElementById("finalOverlay");
        if (overlay) {
          overlay.classList.add("hidden");
        }
      }

      function renderInventorySlots(slots) {
        const grid = document.getElementById("inventorySlots");
        if (!grid) return;
        if (!slots || !slots.length) {
          grid.innerHTML = '<p class="small">No inventory items equipped.</p>';
          return;
        }
        grid.innerHTML = "";
        slots.forEach((slot) => {
          const qty =
            slot && slot.quantity != null ? ` Â· x${slot.quantity}` : "";
          const cooldown =
            slot && slot.cooldown_turns != null
              ? ` Â· CD ${slot.cooldown_turns}`
              : "";
          const card = document.createElement("div");
          card.className = "inventory-slot";
          card.innerHTML = `
            <strong>${slot.label || slot.item_id || slot.slot_id}</strong>
            <div class="status">${slot.status || "ready"}${qty}${cooldown}</div>
            ${
              slot.description
                ? `<div class="small">${slot.description}</div>`
                : ""
            }
          `;
          if (slot.safe_function) {
            card.tabIndex = 0;
            card.classList.add("draggable");
            card.addEventListener("click", () =>
              runSafeAction(slot.safe_function, { slot_id: slot.slot_id })
            );
            card.addEventListener("keydown", (event) => {
              if (event.key === "Enter" || event.key === " ") {
                event.preventDefault();
                runSafeAction(slot.safe_function, { slot_id: slot.slot_id });
              }
            });
            card.addEventListener("pointerdown", (event) =>
              startInventoryDrag(slot, event)
            );
          }
          grid.appendChild(card);
        });
      }

      function renderInteractionTargets(targets) {
        if (Array.isArray(targets)) {
          lastInteractionTargets = targets.slice();
        } else {
          lastInteractionTargets = [];
        }
        const box = document.getElementById("interactionTargets");
        if (!box) return;
        if (!targets || !targets.length) {
          box.innerHTML =
            '<p class="small">No interaction targets in range.</p>';
          return;
        }
        box.innerHTML = "";
        targets.forEach((target) => {
          const wrapper = document.createElement("div");
          wrapper.className = "interaction-target";
          wrapper.innerHTML = `
            <strong>${target.name || target.target_id}</strong>
            <div class="small">${target.location || "unknown"} Â· ${
            target.status || ""
          }</div>
          `;
          const actionsRow = document.createElement("div");
          actionsRow.className = "interaction-actions";
          (target.actions || []).slice(0, 4).forEach((action) => {
            const button = document.createElement("button");
            button.type = "button";
            button.className = "chip";
            button.textContent = action.label;
            button.title = action.summary || "";
            button.disabled = action.enabled === false;
            if (action.safe_function) {
              button.addEventListener("click", () =>
                runSafeAction(action.safe_function, {
                  target_id: target.target_id,
                  action_id: action.action_id,
                })
              );
            }
            actionsRow.appendChild(button);
          });
          wrapper.appendChild(actionsRow);
          box.appendChild(wrapper);
        });
      }

      function renderInputHints(hints) {
        const list = document.getElementById("inputHints");
        if (!list) return;
        if (!hints || !hints.length) {
          list.innerHTML = '<li class="small">No keyboard hints configured.</li>';
          return;
        }
        list.innerHTML = hints
          .map((hint) => {
            const keys = (hint.keys || []).join(" / ");
            return `<li class="status-pill info">
              <strong>${hint.action}</strong>
              <span>${keys} Â· ${hint.description || ""}</span>
            </li>`;
          })
          .join("");
      }

      function renderThemeInfo(theme) {
        const box = document.getElementById("themeInfo");
        if (!box) return;
        if (!theme) {
          box.innerHTML = '<p class="small">Default siege theme active.</p>';
          return;
        }
        const palette = theme.palette || {};
        const paletteHtml = Object.entries(palette)
          .slice(0, 4)
          .map(
            ([key, value]) =>
              `<span class="chip" style="background:${value};border-color:${value};color:#020617">${key}</span>`
          )
          .join("");
        box.innerHTML = `
          <strong>${theme.title || theme.theme_id}</strong><br>
          <span class="small">HUD variant: ${
            theme.hud_variant || "classic"
          }</span>
          <div class="chip-list">${paletteHtml || "Palette pending"}</div>
        `;
        const motifs =
          (theme.theme_assets && theme.theme_assets.motifs) ||
          (theme.assets && theme.assets.motifs) ||
          [];
        if (motifs.length) {
          box.innerHTML += `
            <div class="chip-list">
              ${motifs
                .slice(0, 4)
                .map((motif) => `<span class="chip">${motif}</span>`)
                .join("")}
            </div>
          `;
        }
        if (activeThemeMeta && activeThemeMeta.id === theme.theme_id) {
          const tags = (activeThemeMeta.tags || []).join(", ");
          box.innerHTML += `<div class="small">${activeThemeMeta.description || ""}</div>`;
          if (tags) {
            box.innerHTML += `<div class="small">Tags: ${tags}</div>`;
          }
        }
      }

      async function loadThemes() {
        try {
          const payload = await api("/game/themes");
          availableThemes = payload.themes || [];
          activeThemeMeta = payload.active_theme || null;
          renderThemeSelector();
        } catch (err) {
          console.warn("Theme list failed", err);
          const info = document.getElementById("themeSelectInfo");
          if (info) {
            info.textContent = "Unable to load theme packages.";
          }
        }
      }

      function renderThemeSelector() {
        const select = document.getElementById("themeSelect");
        const info = document.getElementById("themeSelectInfo");
        if (!select) return;
        select.innerHTML = "";
        if (!availableThemes.length) {
          const placeholder = document.createElement("option");
          placeholder.value = "";
          placeholder.textContent = "No themes detected";
          select.appendChild(placeholder);
        } else {
          availableThemes.forEach((theme) => {
            const option = document.createElement("option");
            option.value = theme.id;
            option.textContent = `${theme.label || theme.id} (${theme.id})`;
            select.appendChild(option);
          });
        }
        if (activeThemeMeta && activeThemeMeta.id) {
          select.value = activeThemeMeta.id;
        }
        if (info) {
          info.textContent = activeThemeMeta
            ? `Active theme: ${activeThemeMeta.label || activeThemeMeta.id}`
            : "Theme changes reset the run.";
        }
      }

      async function applySelectedTheme() {
        const select = document.getElementById("themeSelect");
        if (!select) return;
        const themeId = select.value;
        if (!themeId) return;
        if (activeThemeMeta && themeId === activeThemeMeta.id) {
          return;
        }
        const confirmed = window.confirm(
          "Applying a theme resets the current run. Continue?"
        );
        if (!confirmed) {
          return;
        }
        try {
          const payload = await api("/game/theme", {
            method: "POST",
            body: JSON.stringify({ theme_id: themeId }),
          });
          activeThemeMeta = payload.theme || activeThemeMeta;
          if (payload.player_view) {
            updatePlayerView(payload.player_view);
          }
          await refreshState();
          await loadOptions();
          await loadThemes();
          appendMapActivityEntry(
            `<strong>Theme Applied</strong><br>${
              (payload.theme && (payload.theme.label || payload.theme.id)) ||
              themeId
            }`
          );
        } catch (err) {
          console.warn("Theme apply failed", err);
          alert(err.message || "Theme apply failed.");
        }
      }

      function renderAgentDominance(panel) {
        const summary = document.getElementById("agentDominanceSummary");
        const list = document.getElementById("agentDominanceList");
        const historyBox = document.getElementById("agentDominanceHistory");
        if (!summary || !list) return;
        if (
          !panel ||
          !Array.isArray(panel.domains) ||
          !panel.domains.length ||
          panel.total_calls == null
        ) {
          summary.innerHTML =
            '<p class="small">Agent dominance verisi yok.</p>';
          list.innerHTML = "";
          if (historyBox) {
            historyBox.innerHTML = "";
          }
          return;
        }
        const total = Number(panel.total_calls ?? 0);
        const unknown = Number(panel.unknown_calls ?? 0);
        const index =
          panel.dominance_index != null && !Number.isNaN(panel.dominance_index)
            ? Number(panel.dominance_index)
            : null;
        const turnLabel =
          panel.turn != null ? `Turn ${panel.turn}` : "Aktif turn";
        const unknownText = unknown ? ` &middot; ${unknown} bilinmeyen` : "";
        const indexText =
          typeof index === "number" ? ` &middot; Index ${index.toFixed(2)}` : "";
        const trendValue =
          typeof panel.dominance_trend === "number" &&
          !Number.isNaN(panel.dominance_trend)
            ? panel.dominance_trend
            : null;
        const trendText =
          trendValue !== null && trendValue !== 0
            ? ` &middot; Trend ${trendValue > 0 ? "+" : ""}${trendValue.toFixed(2)}`
            : "";
        summary.innerHTML = `${turnLabel}: <strong>${total}</strong> safe call${total === 1 ? "" : "s"}${unknownText}${indexText}${trendText}`;
        list.innerHTML = panel.domains
          .map((domain) => {
            const share = Number(domain.share_pct ?? 0);
            const target = Number(domain.target_pct ?? 0);
            const calls = Number(domain.calls ?? 0);
            const cls =
              domain.status === "critical"
                ? "critical"
                : domain.status === "warning"
                ? "warning"
                : "info";
            const desc = domain.description
              ? `<span>${domain.description}</span>`
              : "";
            const recent =
              Array.isArray(domain.recent_calls) && domain.recent_calls.length
                ? `<span class="small">Son: ${domain.recent_calls
                    .slice(-3)
                    .join(", ")}</span>`
                : "";
            return `<li class="status-pill ${cls}">
              <strong>${domain.label || domain.id}</strong>
              <span>${share.toFixed(1)}% ajan &middot; hedef ${target}% (${calls})</span>
              ${desc}
              ${recent}
            </li>`;
          })
          .join("");
        if (historyBox) {
          if (Array.isArray(panel.history) && panel.history.length) {
            historyBox.innerHTML = panel.history
              .map((entry) => {
                const turn = entry.turn != null ? entry.turn : "â";
                const idx =
                  entry.dominance_index != null && !Number.isNaN(entry.dominance_index)
                    ? Number(entry.dominance_index).toFixed(2)
                    : "--";
                const top = entry.top_domain || {};
                const label =
                  top.label || top.id || (top.share_pct != null ? "Top" : "â");
                const share =
                  top.share_pct != null && !Number.isNaN(top.share_pct)
                    ? `${Number(top.share_pct).toFixed(1)}%`
                    : "";
                const statusClass = top.status || "";
                return `<span class="history-chip ${statusClass}">
                  <strong>T${turn}</strong>
                  <span>${idx}</span>
                  <span>${label}${share ? " Â· " + share : ""}</span>
                </span>`;
              })
              .join("");
          } else {
            historyBox.innerHTML =
              '<p class="small">Dominance geÃ§miÅi kaydÄ± yok.</p>';
          }
        }
      }

      function renderAgentPulses(pulses) {
        const list = document.getElementById("agentPulseFeed");
        if (!list) return;
        if (!pulses || !pulses.length) {
          list.innerHTML =
            '<li class="small">Agent telemetry not reported.</li>';
          return;
        }
        list.innerHTML = pulses
          .map((pulse) => {
            const cls = pulse.status === "warning" ? "warning" : "info";
            const latency =
              typeof pulse.latency_ms === "number"
                ? `${pulse.latency_ms.toFixed(1)} ms`
                : "n/a";
            const confidence =
              typeof pulse.confidence === "number"
                ? `${pulse.confidence.toFixed(1)}%`
                : "";
            return `<li class="status-pill ${cls}">
              <strong>${pulse.agent}</strong>
              <span>Latency ${latency}${
              confidence ? ` Â· ${confidence}` : ""
            }</span>
              ${
                pulse.hint
                  ? `<div class="small">${pulse.hint}</div>`
                  : ""
              }
            </li>`;
          })
          .join("");
      }

      function renderNPCs(view) {
        const box = document.getElementById("npcCards");
        const trust = (view && view.npc_trust_overview) || [];
        if (!trust.length) {
          box.innerHTML = '<p class="small">No NPC trust data.</p>';
          return;
        }
        box.innerHTML = trust
          .map(
            (npc) =>
              `<div class="npc-card"><strong>${npc.name}</strong><br/><span class="small">Trust: ${npc.trust}</span></div>`
          )
          .join("");
      }

      function loyaltyClass(status) {
        switch ((status || "").toLowerCase()) {
          case "devoted":
            return "met";
          case "steady":
            return "tracking";
          case "wavering":
            return "warning";
          case "at_risk":
            return "critical";
          default:
            return "info";
        }
      }

      function renderNPCLoyalty(view) {
        const list = document.getElementById("npcLoyalty");
        if (!list) return;
        const loyalty = (view && view.npc_loyalty_panel) || [];
        if (!loyalty.length) {
          list.innerHTML =
            '<li class="small">No loyalty insights available.</li>';
          return;
        }
        list.innerHTML = loyalty
          .map((entry) => {
            const cls = loyaltyClass(entry.status);
            const role = entry.role ? `<span>${entry.role}</span>` : "";
            const stance = entry.stance ? `<span>${entry.stance}</span>` : "";
            const location = entry.location
              ? `<span>Loc: ${entry.location}</span>`
              : "";
            return `<li class="status-pill ${cls}">
            <strong>${entry.name}</strong>
            <span>Loyalty: ${entry.status || "unknown"} (${
              entry.trust ?? 0
            })</span>
            ${role}${stance}${location}
          </li>`;
          })
          .join("");
      }

      function pressureClass(status) {
        switch ((status || "").toLowerCase()) {
          case "critical":
            return "critical";
          case "pressured":
            return "warning";
          case "pending":
            return "warning";
          case "resolved":
            return "met";
          case "highlight":
            return "active";
          case "stable":
            return "met";
          default:
            return "info";
        }
      }

      function renderResourcePressure(view) {
        const list = document.getElementById("resourcePressure");
        if (!list) return;
        const entries = (view && view.resource_pressure) || [];
        if (!entries.length) {
          list.innerHTML =
            '<li class="small">No resource pressure detected.</li>';
          return;
        }
        list.innerHTML = entries
          .map((entry) => {
            const cls = pressureClass(entry.status);
            const detail = entry.hint ? `<span>${entry.hint}</span>` : "";
            const label = entry.label || entry.id;
            return `<li class="status-pill ${cls}">
            <strong>${label}</strong>
            <span>Value: ${entry.value ?? "--"} (${entry.source || ""})</span>
            ${detail}
          </li>`;
          })
          .join("");
      }

      function renderEventChain(view) {
        const list = document.getElementById("eventChain");
        if (!list) return;
        const chain = (view && view.event_chain) || [];
        if (!chain.length) {
          list.innerHTML = '<li class="small">No event chain data.</li>';
          return;
        }
        list.innerHTML = chain
          .map((entry) => {
            const cls = pressureClass(entry.status);
            const turn =
              entry.turn !== undefined && entry.turn !== null
                ? `<span>Turn ${entry.turn}</span>`
                : "";
            const detail = entry.detail ? `<span>${entry.detail}</span>` : "";
            return `<li class="status-pill ${cls}">
            <strong>${entry.label || entry.type}</strong>
            ${detail}
            ${turn}
          </li>`;
          })
          .join("");
      }

      function renderMetaProgression(view) {
        const panel = (view && view.meta_progression) || {};
        renderMetaUnlocks(panel.unlocks || []);
        renderMetaAchievements(panel.achievements || []);
        renderMetaShareCard(panel.share_card || {});
      }

      function metaStatusClass(status) {
        switch ((status || "").toLowerCase()) {
          case "active":
            return "met";
          case "pending":
            return "tracking";
          case "expired":
            return "disabled";
          default:
            return "info";
        }
      }

      function renderMetaUnlocks(unlocks) {
        const list = document.getElementById("metaUnlocks");
        if (!list) return;
        if (!unlocks.length) {
          list.innerHTML = '<li class="small">No unlocks earned yet.</li>';
          return;
        }
        list.innerHTML = unlocks
          .map((entry) => {
            const cls = metaStatusClass(entry.status);
            const turn =
              entry.turn !== undefined && entry.turn !== null
                ? `<span>Turn ${entry.turn}</span>`
                : "";
            return `<li class="status-pill ${cls}">
            <strong>${entry.label || entry.id}</strong>
            <span>Status: ${entry.status || "active"}</span>
            ${turn}
          </li>`;
          })
          .join("");
      }

      function metaTierClass(tier) {
        switch ((tier || "").toLowerCase()) {
          case "gold":
            return "met";
          case "silver":
            return "tracking";
          case "bronze":
            return "warning";
          default:
            return "info";
        }
      }

      function renderMetaAchievements(achievements) {
        const list = document.getElementById("metaAchievements");
        if (!list) return;
        if (!achievements.length) {
          list.innerHTML = '<li class="small">No achievements recorded.</li>';
          return;
        }
        list.innerHTML = achievements
          .map((entry) => {
            const cls = metaTierClass(entry.tier);
            const turn =
              entry.unlocked_turn !== undefined && entry.unlocked_turn !== null
                ? `<span>Turn ${entry.unlocked_turn}</span>`
                : "";
            const tier = entry.tier ? `<span>Tier: ${entry.tier}</span>` : "";
            return `<li class="status-pill ${cls}">
            <strong>${entry.label || entry.id}</strong>
            ${tier}
            ${turn}
          </li>`;
          })
          .join("");
      }

      function copyShareCard() {
        if (!lastShareCardText) {
          alert("Share card is not ready yet.");
          return;
        }
        if (navigator.clipboard && navigator.clipboard.writeText) {
          navigator.clipboard
            .writeText(lastShareCardText)
            .then(() => alert("Share card copied to clipboard."))
            .catch(() => alert("Copy failed. Please copy the text manually."));
        } else {
          alert(lastShareCardText);
        }
      }

      function renderMetaShareCard(shareCard) {
        const box = document.getElementById("metaShareCard");
        if (!box) return;
        if (!shareCard || !Object.keys(shareCard).length) {
          box.innerHTML = '<p class="small">No share card available.</p>';
          lastShareCardText = "";
          return;
        }
        const ready = shareCard.ready
          ? '<span class="status-pill met">Ready</span>'
          : '<span class="status-pill warning">In Progress</span>';
        const summary = shareCard.summary
          ? `<p>${shareCard.summary}</p>`
          : '<p class="small">Summary pending final turn.</p>';
        const player = shareCard.player
          ? `<p class="small">Player: ${shareCard.player}</p>`
          : "";
        const metrics = shareCard.metrics || {};
        const metricsHtml = Object.keys(metrics).length
          ? `<ul class="status-list">${Object.entries(metrics)
              .map(
                ([key, val]) =>
                  `<li class="status-pill info"><strong>${key}</strong><span>${val}</span></li>`
              )
              .join("")}</ul>`
          : "";
        const shareLines = [];
        if (shareCard.player) {
          shareLines.push(`Player: ${shareCard.player}`);
        }
        shareLines.push(`Summary: ${shareCard.summary || "(pending summary)"}`);
        lastShareCardText = shareCard.ready ? shareLines.join("\n") : "";
        box.innerHTML = `
        <div class="share-card-box">
          <div class="share-card-header">
            ${ready}
            <button class="secondary" onclick="copyShareCard()">Copy Summary</button>
          </div>
          ${player}
          ${summary}
          ${metricsHtml}
        </div>
      `;
      }

      function renderGuardrail(view) {
        const feed = document.getElementById("guardrailFeed");
        const notes = (view && view.guardrail_notes) || [];
        if (!notes.length) {
          feed.innerHTML = '<li class="small">No guardrail notes.</li>';
          return;
        }
        feed.innerHTML = notes
          .map(
            (note) => `<li><strong>${note.type}</strong>: ${note.message}</li>`
          )
          .join("");
      }

      function renderSafeFunctions(view) {
        const feed = document.getElementById("safeFunctionHistory");
        const history = (view && view.safe_function_history) || [];
        if (!history.length) {
          feed.innerHTML =
            '<li class="small">No safe function calls this turn.</li>';
          return;
        }
        feed.innerHTML = history
          .slice(-6)
          .reverse()
          .map(
            (entry) =>
              `<li><strong>${entry.name}</strong> ${
                entry.success ? "ok" : "failed"
              }</li>`
          )
          .join("");
      }

      function renderResourceBars(bars) {
        const box = document.getElementById("turnHudResources");
        if (!box) return;
        if (!bars || !bars.length) {
          box.innerHTML = '<p class="small">No resource data.</p>';
          return;
        }
        box.innerHTML = bars
          .map((bar) => {
            const value = Number(bar.value ?? 0);
            const pct = Math.max(0, Math.min(100, value));
            return `
            <div class="metric-row">
              <strong style="width:110px">${bar.label || bar.id}</strong>
              <div class="metric-bar"><span style="width:${pct}%"></span></div>
              <span class="small">${
                Number.isFinite(value) ? value.toFixed(0) : value
              }</span>
            </div>`;
          })
          .join("");
      }

      function renderConditionList(items, targetId, emptyText) {
        const box = document.getElementById(targetId);
        if (!box) return;
        if (!items || !items.length) {
          box.innerHTML = `<li class="small">${emptyText}</li>`;
          return;
        }
        box.innerHTML = items
          .map((entry) => {
            const status = entry.status || "info";
            const detail = entry.detail ? `<span>${entry.detail}</span>` : "";
            return `<li class="status-pill ${status}"><strong>${
              entry.label || entry.id
            }</strong>${detail}</li>`;
          })
          .join("");
      }

      function renderRiskList(items) {
        const box = document.getElementById("turnHudRisks");
        if (!box) return;
        if (!items || !items.length) {
          box.innerHTML = '<li class="small">No active risk signals.</li>';
          return;
        }
        box.innerHTML = items
          .map((entry) => {
            const action = entry.action ? `<span>${entry.action}</span>` : "";
            return `<li class="status-pill ${
              entry.severity || "warning"
            }"><strong>${entry.message}</strong>${action}</li>`;
          })
          .join("");
      }

      function renderJudgeTips(items) {
        const box = document.getElementById("turnHudJudge");
        if (!box) return;
        if (!items || !items.length) {
          box.innerHTML = '<li class="small">No judge notes right now.</li>';
          return;
        }
        box.innerHTML = items
          .map((entry) => {
            const action = entry.action ? `<span>${entry.action}</span>` : "";
            const message = entry.message
              ? `<span>${entry.message}</span>`
              : "";
            return `<li class="status-pill info"><strong>${
              entry.title || "Tip"
            }</strong>${message}${action}</li>`;
          })
          .join("");
      }

      function renderTurnHud(view) {
        const summary = document.getElementById("turnHudSummary");
        if (!summary) return;
        const hud = (view && view.turn_hud) || null;
        if (!hud || !Object.keys(hud).length) {
          summary.innerHTML =
            '<p class="small">Turn HUD is waiting for live data.</p>';
          renderResourceBars([]);
          renderConditionList([], "turnHudWins", "Win conditions unavailable.");
          renderConditionList([], "turnHudLosses", "Loss risks unavailable.");
          renderRiskList([]);
          renderJudgeTips([]);
          return;
        }
        summary.innerHTML = `
        <span class="hud-pill">Turn ${hud.turn}/${hud.turn_limit}</span>
        <span class="hud-pill">${hud.turns_remaining} turns left</span>
        <span class="hud-pill">Phase ${hud.phase || "unknown"}</span>
      `;
        renderResourceBars(hud.resource_bars || []);
        renderConditionList(
          hud.win_conditions || [],
          "turnHudWins",
          "No win path tracked."
        );
        renderConditionList(
          hud.loss_conditions || [],
          "turnHudLosses",
          "No loss risks detected."
        );
        renderRiskList(hud.risk_indicators || []);
        renderJudgeTips(hud.judge_tips || []);
      }

      function renderTutorialOverlay(view) {
        const box = document.getElementById("tutorialOverlay");
        if (!box) return;
        const overlay = (view && view.tutorial_overlay) || null;
        if (!overlay) {
          box.innerHTML =
            '<p class="small">Tutorial guidance completed. HUD now reflects live telemetry.</p>';
          return;
        }
        const objectiveItems = (overlay.objectives || [])
          .map((item) => `<li>${item}</li>`)
          .join("");
        const actions = (overlay.recommended_actions || [])
          .map((item) => `<li>${item}</li>`)
          .join("");
        const chips = (overlay.safe_function_examples || [])
          .map((fn) => `<span class="chip">${fn}</span>`)
          .join("");
        const highlights = (overlay.highlight_metrics || [])
          .map(
            (entry) =>
              `<li>${entry.metric}: ${entry.value ?? "-"} (${
                entry.status || "info"
              })</li>`
          )
          .join("");
        box.innerHTML = `
        <h3>${overlay.title || "Tutorial"}</h3>
        <p>${overlay.summary || ""}</p>
        <h4>Objectives</h4>
        <ul class="objective-list">${
          objectiveItems || "<li>Follow the HUD prompts.</li>"
        }</ul>
        <h4>Recommended Actions</h4>
        <ul class="objective-list">${
          actions || "<li>Experiment freely.</li>"
        }</ul>
        <div class="chip-list">${
          chips || '<span class="chip">No examples</span>'
        }</div>
        ${
          highlights
            ? `<h4>Focus Metrics</h4><ul class="objective-list">${highlights}</ul>`
            : ""
        }
      `;
      }

      function updateLayerFilter(value) {
        layerFilter = value;
        renderMapDetails(lastPlayerView);
      }

      function cycleLayerFilter(step = 1) {
        const order = ["all", "active", "hidden", "disabled", "highlight"];
        const currentIndex = order.indexOf(layerFilter);
        const nextIndex =
          currentIndex === -1
            ? 0
            : (currentIndex + step + order.length) % order.length;
        layerFilter = order[nextIndex];
        const select = document.getElementById("layerFilterSelect");
        if (select) {
          select.value = layerFilter;
        }
        renderMapDetails(lastPlayerView);
      }

      function updateMarkerFilter(value) {
        markerFilter = value;
        renderMapDetails(lastPlayerView);
      }

      async function loadSchemas() {
        try {
          const payload = await api("/safe-functions/schema");
          safeFunctionSchemas = payload.schemas || {};
          const select = document.getElementById("schemaSelect");
          if (select) {
            const keys = Object.keys(safeFunctionSchemas).sort();
            select.innerHTML =
              '<option value="">Select a safe function</option>';
            keys.forEach((key) => {
              const option = document.createElement("option");
              option.value = key;
              option.textContent = key;
              select.appendChild(option);
            });
          }
          renderSchemaViewer();
        } catch (err) {
          console.warn("Schema load failed", err);
          const viewer = document.getElementById("schemaViewer");
          if (viewer) {
            viewer.textContent = "Failed to load safe function schemas.";
          }
        }
      }

      function renderSchemaViewer() {
        const select = document.getElementById("schemaSelect");
        const box = document.getElementById("schemaViewer");
        if (!select || !box) return;
        const key = select.value;
        if (!key || !safeFunctionSchemas[key]) {
          box.textContent = "Select a safe function to view its JSON schema.";
          return;
        }
        box.textContent = JSON.stringify(safeFunctionSchemas[key], null, 2);
      }

      function downloadSchema() {
        const select = document.getElementById("schemaSelect");
        if (!select) return;
        const key = select.value;
        if (!key || !safeFunctionSchemas[key]) return;
        const blob = new Blob(
          [JSON.stringify(safeFunctionSchemas[key], null, 2)],
          {
            type: "application/json",
          }
        );
        const url = URL.createObjectURL(blob);
        const anchor = document.createElement("a");
        anchor.href = url;
        anchor.download = `${key}_schema.json`;
        document.body.appendChild(anchor);
        anchor.click();
        anchor.remove();
        setTimeout(() => URL.revokeObjectURL(url), 2000);
      }

      function renderMapDetails(view) {
        const mapState = (view && view.map_state) || {};
        const mapBox = document.getElementById("mapState");
        if (mapBox) {
          mapBox.textContent = JSON.stringify(mapState, null, 2);
        }
        const layers = mapState.layers || [];
        const markers = mapState.event_markers || [];
        const roles = mapState.npc_roles || [];
        const layerList = document.getElementById("mapLayers");
        const markerList = document.getElementById("mapMarkers");
        const roleList = document.getElementById("npcRoles");

        if (layerList) {
          const select = document.getElementById("layerFilterSelect");
          if (select) select.value = layerFilter;
          const filteredLayers =
            layerFilter === "all"
              ? layers
              : layers.filter(
                  (layer) => (layer.status || "").toLowerCase() === layerFilter
                );
          if (!filteredLayers.length) {
            layerList.innerHTML = '<li class="small">No custom layers.</li>';
          } else {
            layerList.innerHTML = filteredLayers
              .map((layer, idx) => {
                const status = (layer.status || "info").toLowerCase();
                const summary = layer.summary
                  ? `<span>${layer.summary}</span>`
                  : "";
                const threat = layer.threat_level
                  ? `<span>Threat: ${layer.threat_level}</span>`
                  : "";
                const idValue = String(
                  layer.id || layer.label || `layer-${idx}`
                );
                return `<li class="status-pill ${status}" data-layer-id="${idValue}"><strong>${
                  layer.label || layer.id || idValue
                }</strong>${summary}${threat}</li>`;
              })
              .join("");
          }
        }

        if (markerList) {
          const select = document.getElementById("markerFilterSelect");
          if (select) select.value = markerFilter;
          const filteredMarkers =
            markerFilter === "all"
              ? markers
              : markers.filter(
                  (marker) =>
                    (marker.severity || "info").toLowerCase() === markerFilter
                );
          if (!filteredMarkers.length) {
            markerList.innerHTML = '<li class="small">No event markers.</li>';
          } else {
            markerList.innerHTML = filteredMarkers
              .map((marker, idx) => {
                const sevr = (marker.severity || "info").toLowerCase();
                const summary = marker.summary
                  ? `<span>${marker.summary}</span>`
                  : "";
                const expires = marker.expires_turn
                  ? `<span>Expires turn ${marker.expires_turn}</span>`
                  : "";
                const idValue = String(
                  marker.id || `${marker.room || "marker"}-${idx}`
                );
                return `<li class="status-pill ${sevr}" data-marker-id="${idValue}"><strong>${
                  marker.room || "unknown"
                }</strong>${summary}${expires}</li>`;
              })
              .join("");
          }
        }

        if (roleList) {
          if (!roles.length) {
            roleList.innerHTML =
              '<li class="small">No NPC role assignments.</li>';
          } else {
            roleList.innerHTML = roles
              .map((role, idx) => {
                const stance = role.stance ? `<span>${role.stance}</span>` : "";
                const task = role.task ? `<span>${role.task}</span>` : "";
                const location = role.location
                  ? `<span>Loc: ${role.location}</span>`
                  : "";
                const priority =
                  typeof role.priority === "number"
                    ? `<span>Priority: ${(role.priority * 100).toFixed(
                        0
                      )}%</span>`
                    : "";
                const idValue = String(role.npc_id || `npc-${idx}`);
                return `<li class="status-pill ${
                  role.role ? "active" : "info"
                }" data-role-id="${idValue}"><strong>${
                  role.npc_id || idValue
                }</strong><span>${
                  role.role || ""
                }</span>${stance}${task}${location}${priority}</li>`;
              })
              .join("");
          }
        }
      }

      function renderNPCBehavior(view) {
        const list = document.getElementById("npcBehaviorTimeline");
        if (!list) return;
        const timeline = (view && view.npc_behavior_timeline) || [];
        if (!timeline.length) {
          list.innerHTML = '<li class="small">No scheduled NPC behaviors.</li>';
          return;
        }
        list.innerHTML = timeline
          .map((entry) => {
            const status = (entry.status || "scheduled").toLowerCase();
            const next = entry.next_location
              ? `Next: ${entry.next_location}`
              : "";
            const eta =
              typeof entry.next_turn === "number"
                ? `Turn ${entry.next_turn}`
                : "Pending";
            const route =
              entry.route_preview && entry.route_preview.length
                ? `<span>Route: ${entry.route_preview.join(" -> ")}</span>`
                : "";
            const pillClass =
              status === "in_progress"
                ? "active"
                : status === "disabled"
                ? "disabled"
                : "info";
            return `<li class="status-pill ${pillClass}">
            <strong>${entry.npc_id || "NPC"}</strong>
            <span>${entry.task || ""}</span>
            <span>${next} (${eta})</span>
            ${route}
          </li>`;
          })
          .join("");
      }

      function renderMapMetrics(metrics) {
        const box = document.getElementById("mapMetrics");
        if (!box) return;
        if (!metrics || Object.keys(metrics).length === 0) {
          box.innerHTML = '<p class="small">No map function telemetry yet.</p>';
          return;
        }
        const mapCalls = Number(metrics.map_calls ?? metrics.mapCalls ?? 0);
        const mapBatches = Number(
          metrics.map_batches ?? metrics.mapBatches ?? 0
        );
        const totalLatency = Number(
          metrics.map_fn_latency_ms ?? metrics.total_latency_ms ?? 0
        );
        const heaviestBatch = Number(
          metrics.snapshot_batch_ms ?? metrics.heaviest_batch_ms ?? 0
        );
        const batchRecords = metrics.batch_records || [];
        const batchesHtml = batchRecords.length
          ? `<ul class="status-list">${batchRecords
              .map(
                (batch) =>
                  `<li class="status-pill info"><strong>Batch ${
                    batch.batch_id
                  }</strong><span>${batch.calls || 0} calls | ${Number(
                    batch.latency_ms || 0
                  ).toFixed(1)} ms</span></li>`
              )
              .join("")}</ul>`
          : '<p class="small">No batches recorded.</p>';
        box.innerHTML = `
        <div class="metric-row"><span>Map safe function calls</span><strong>${mapCalls}</strong></div>
        <div class="metric-row"><span>Total map latency</span><strong>${totalLatency.toFixed(
          1
        )} ms</strong></div>
        <div class="metric-row"><span>Map batches</span><strong>${mapBatches}</strong></div>
        <div class="metric-row"><span>Heaviest batch</span><strong>${heaviestBatch.toFixed(
          1
        )} ms</strong></div>
        ${batchesHtml}
      `;
      }

      function renderPilotKpi(telemetry = {}) {
        const summaryEl = document.getElementById("pilotKpiSummary");
        const checkList = document.getElementById("pilotKpiChecks");
        const metaEl = document.getElementById("pilotProfileMeta");
        const notesEl = document.getElementById("pilotKpiNotes");
        if (!summaryEl || !checkList || !metaEl || !notesEl) return;
        const profile = telemetry.llm_profile || "default";
        const variants = telemetry.llm_variants || {};
        const variantText = Object.keys(variants).length
          ? Object.entries(variants)
              .map(([agent, variant]) => `${agent}:${variant}`)
              .join(", ")
          : "â";
        metaEl.innerHTML = `LLM profile: <strong>${profile}</strong><br>Variants: ${variantText}`;
        const kpi = telemetry.pilot_kpi;
        const classMap = { go: "met", watch: "warning", "no-go": "critical" };
        if (!kpi) {
          summaryEl.className = "status-pill info small";
          summaryEl.innerHTML = "<strong>Waiting for telemetryâ¦</strong>";
          checkList.innerHTML =
            '<li class="small">No KPI checks yet. Play a turn to populate.</li>';
          notesEl.textContent = "";
          return;
        }
        const statusClass = classMap[kpi.status] || "info";
        summaryEl.className = `status-pill ${statusClass}`;
        summaryEl.innerHTML = `<strong>${
          kpi.status?.toUpperCase() || "GO"
        }</strong>`;
        const checks = Array.isArray(kpi.checks) ? kpi.checks : [];
        if (!checks.length) {
          checkList.innerHTML =
            '<li class="small">No KPI checks reported.</li>';
        } else {
          checkList.innerHTML = checks
            .map((check) => {
              const cClass = classMap[check.status] || "info";
              const unit = check.unit || "";
              return `<li class="status-pill ${cClass}">
              <strong>${check.name}</strong>
              <span>${check.value}${unit ? " " + unit : ""} / limit ${
                check.limit
              }${unit ? " " + unit : ""}</span>
            </li>`;
            })
            .join("");
        }
        const notes = Array.isArray(kpi.notes) ? kpi.notes : [];
        notesEl.textContent = notes.length ? notes.join(" | ") : "";
      }

      function renderTelemetry(event) {
        if (!event) return;
        const box = document.getElementById("telemetry");
        if (box) {
          box.textContent = JSON.stringify(event, null, 2);
        }
        if (event.player_view) {
          updatePlayerView(event.player_view);
        }
        if (event.telemetry) {
          renderMapMetrics(event.telemetry.safe_function_metrics || {});
          renderPilotKpi(event.telemetry || {});
        } else {
          renderMapMetrics(null);
          renderPilotKpi({});
        }
        if (event.win_loss) {
          lastWinLoss = event.win_loss;
        }
        if (event.player_view) {
          renderFinalOverlay(event.player_view, lastWinLoss);
        }
        if (event.map_diff) {
          applyMapDiff(event.map_diff);
        }
      }

      async function refreshState() {
        const state = await api("/game/state");
        document.getElementById("state").textContent = JSON.stringify(
          state,
          null,
          2
        );
      }

      async function loadOptions() {
        const data = await api("/game/options");
        const opts = data.options || [];
        const list = document.getElementById("options");
        list.innerHTML = "";
        if (!opts.length) {
          list.innerHTML =
            '<li class="small">No options available. Try Play Turn.</li>';
        } else {
          opts.forEach((o, idx) => {
            const li = document.createElement("li");
            li.textContent =
              "[" +
              (idx + 1) +
              "] " +
              (o.text || "(no text)") +
              "  id=" +
              (o.id || "");
            li.onclick = () => playTurn(o.id);
            list.appendChild(li);
          });
        }
      }

      function updatePlayerView(view) {
        if (!view) return;
        lastPlayerView = view;
        renderSceneState(view.scene_state, view.theme);
        renderPlannerRecommendations(view.planner_recommendations || []);
        renderTurnHud(view);
        renderTutorialOverlay(view);
        renderMetrics(view.metrics_panel);
        renderNPCs(view);
        renderNPCLoyalty(view);
        renderResourcePressure(view);
        renderEventChain(view);
        renderMetaProgression(view);
        renderNPCBehavior(view);
        renderGuardrail(view);
        renderSafeFunctions(view);
        renderHudAlerts(view.hud_alerts || []);
        renderFinalSignals(view.final_signals || []);
        renderInventorySlots(view.inventory_slots || []);
        renderInteractionTargets(view.interaction_targets || []);
        renderInputHints(view.input_hints || []);
        renderAgentPulses(view.agent_pulses || []);
        renderAgentDominance(view.agent_dominance || null);
        renderThemeInfo(view.theme);
        applyThemePalette(view.theme);
        renderMapDetails(view);
      }

      function renderResultRich(result) {
        const box = document.getElementById("resultRich");
        const scene = (result && result.scene) || "";
        const win = (result && result.win_loss) || { status: "ongoing" };
        const choice = (result && result.player_choice) || {};
        box.innerHTML = `
        <div style="margin-bottom:8px"><strong>Scene</strong><br>${
          scene || "(no scene)"
        } </div>
        <div style="margin-top:8px"><strong>Committed Choice</strong>: <code>${
          choice.id || "(default or random)"
        }</code> - ${choice.text || ""}</div>
        <div style="margin-top:8px"><strong>Win/Loss</strong>: <code>${
          win.status
        }</code> ${win.reason ? "(" + win.reason + ")" : ""}</div>
      `;
        lastWinLoss = win;
        updatePlayerView(result.player_view);
        renderFinalOverlay(result.player_view, win);
      }

      async function playTurn(choiceId = null) {
        const result = await api("/game/turn", {
          method: "POST",
          body: JSON.stringify({ choice_id: choiceId }),
        });
        renderResultRich(result);
        document.getElementById("result").textContent = JSON.stringify(
          result,
          null,
          2
        );
        renderTelemetry(result);
        await refreshState();
        await loadOptions();
      }

      async function resetGame() {
        await api("/game/reset", { method: "POST" });
        document.getElementById("result").textContent = "";
        await refreshState();
        await loadOptions();
      }

      function bootTelemetry() {
        if ("EventSource" in window) {
          telemetrySource = new EventSource("/telemetry/events");
          telemetrySource.onmessage = (evt) => {
            try {
              renderTelemetry(JSON.parse(evt.data));
            } catch (err) {
              console.warn("Telemetry parse failed", err);
            }
          };
        } else {
          setInterval(async () => {
            try {
              const payload = await api("/telemetry/latest");
              renderTelemetry(payload.event);
            } catch (err) {
              console.warn("Telemetry poll failed", err);
            }
          }, 10000);
        }
      }

      window.addEventListener("pointermove", handleGlobalPointerMove);
      window.addEventListener("pointerup", handleGlobalPointerUp);
      window.addEventListener("pointercancel", handleGlobalPointerUp);

      window.addEventListener("DOMContentLoaded", async () => {
        applyAccessibilityState();
        captureBaseThemeVars();
        renderMapMetrics(null);
        renderPilotKpi({});
        await loadThemes();
        await refreshState();
        await loadOptions();
        await loadSchemas();
        bootTelemetry();
        window.addEventListener("keydown", handleKeyShortcuts);
        const zoomInBtn = document.getElementById("cameraZoomIn");
        if (zoomInBtn) {
          zoomInBtn.addEventListener("click", () => adjustCameraZoom(0.1));
        }
        const zoomOutBtn = document.getElementById("cameraZoomOut");
        if (zoomOutBtn) {
          zoomOutBtn.addEventListener("click", () => adjustCameraZoom(-0.1));
        }
        const resetBtn = document.getElementById("cameraReset");
        if (resetBtn) {
          resetBtn.addEventListener("click", () => resetCameraTransform(true));
        }
        const autoFollowToggle = document.getElementById(
          "cameraAutoFollowToggle"
        );
        if (autoFollowToggle) {
          autoFollowToggle.checked = cameraState.autoFollow;
          autoFollowToggle.addEventListener("change", (evt) => {
            setCameraAutoFollow(evt.target.checked);
          });
        }
      });
    </script>
    <base href="/ui/" />
  </head>
  <body>
    <h1>Fortress Director (Command Panel)</h1>
    <div class="row">
      <div class="card">
        <h2>Controls</h2>
        <button type="button" onclick="resetGame()">Reset Game</button>
        <button type="button" class="secondary" onclick="loadOptions()">
          Peek Options
        </button>
        <button type="button" onclick="playTurn(null)">
          Play Turn (default)
        </button>
        <button type="button" onclick="playTurn('__random__')">
          Play Turn (random)
        </button>
        <div class="theme-selector">
          <label for="themeSelect">Theme Selector</label>
          <select id="themeSelect" aria-label="Select theme"></select>
          <button type="button" class="secondary" onclick="applySelectedTheme()">
            Apply Theme
          </button>
          <div id="themeSelectInfo" class="small">
            Theme packages load on demand.
          </div>
        </div>
        <div class="accessibility-controls">
          <button
            type="button"
            id="btnHighContrast"
            class="secondary"
            aria-pressed="false"
            onclick="toggleContrast()"
          >
            High Contrast
          </button>
          <button
            type="button"
            id="btnLargeText"
            class="secondary"
            aria-pressed="false"
            onclick="toggleLargeText()"
          >
            Large Text
          </button>
        </div>
        <p class="small">
          Tip: Click an option below to choose explicitly.<br />
          Accessibility goals: WCAG AA contrast >= 4.5:1, interactive text >=
          16px, reduced motion respected.
        </p>
      </div>
      <div class="card">
        <h2>State Snapshot</h2>
        <pre id="state" class="small"></pre>
      </div>
      <div class="card" id="pilotKpiCard">
        <h2>Pilot KPI Monitor</h2>
        <div
          id="pilotKpiSummary"
          class="status-pill info small"
          aria-live="polite"
        >
          <strong>Waiting for telemetryâ¦</strong>
        </div>
        <ul id="pilotKpiChecks" class="status-list"></ul>
        <div id="pilotProfileMeta" class="small" style="margin-top: 8px"></div>
        <div id="pilotKpiNotes" class="small" style="margin-top: 8px"></div>
      </div>
    </div>

    <div class="row">
      <div class="card">
        <h2>Options</h2>
        <ul id="options" class="options"></ul>
      </div>
      <div class="card">
        <h2>Last Turn Result</h2>
        <div id="resultRich" class="small"></div>
        <pre id="result" class="small" style="margin-top: 8px"></pre>
      </div>
    </div>

    <div class="row">
      <div class="card hud-card">
        <h2>Turn HUD</h2>
        <div id="turnHudSummary" class="hud-summary small"></div>
        <div id="turnHudResources" class="hud-resources"></div>
        <div class="hud-columns">
          <div>
            <h3>Win Paths</h3>
            <ul id="turnHudWins" class="status-list"></ul>
          </div>
          <div>
            <h3>Loss Risks</h3>
            <ul id="turnHudLosses" class="status-list"></ul>
          </div>
        </div>
        <div class="hud-columns">
          <div>
            <h3>Risk Signals</h3>
            <ul id="turnHudRisks" class="status-list"></ul>
          </div>
          <div>
            <h3>Judge Tips</h3>
            <ul id="turnHudJudge" class="status-list"></ul>
          </div>
        </div>
      </div>
      <div class="card tutorial-card">
        <h2>Tutorial Overlay</h2>
        <div id="tutorialOverlay" class="small"></div>
      </div>
    </div>

    <div class="row">
      <div class="card scene-card">
        <h2>Battlefield Scene</h2>
        <div id="sceneContainer" aria-label="Scene preview canvas"></div>
        <div class="camera-controls">
          <span>
            <button type="button" class="secondary" id="cameraZoomIn">
              Zoom +
            </button>
            <button type="button" class="secondary" id="cameraZoomOut">
              Zoom -
            </button>
            <button type="button" class="secondary" id="cameraReset">
              Reset
            </button>
          </span>
          <label>
            <input
              type="checkbox"
              id="cameraAutoFollowToggle"
              checked="checked"
            />
            Auto-follow agents
          </label>
        </div>
        <div class="mini-map">
          <canvas id="miniMapCanvas" width="200" height="200" aria-label="Mini map"></canvas>
          <span id="miniMapStatus" class="small">Mini map hazÄ±r deÄil.</span>
        </div>
        <div id="sceneMeta" class="scene-meta small">
          Scene telemetry not loaded yet.
        </div>
      </div>
      <div class="card">
        <h2>Planner Recommendations</h2>
        <ul id="plannerRecommendations" class="planner-list"></ul>
      </div>
      <div class="card">
        <h2>Alerts & Shortcuts</h2>
        <ul id="hudAlerts" class="hud-alerts status-list"></ul>
        <div style="margin-top: 12px">
          <h3>Final Signals</h3>
          <ul id="finalSignals" class="status-list"></ul>
        </div>
        <div style="margin-top: 12px">
          <h3>Input Hints</h3>
          <ul id="inputHints" class="status-list"></ul>
        </div>
      </div>
      <div class="card">
        <h2>Agent Dominance</h2>
        <div
          id="agentDominanceSummary"
          class="small dominance-summary"
        ></div>
        <ul
          id="agentDominanceList"
          class="status-list agent-dominance"
        ></ul>
        <div id="agentDominanceHistory" class="dominance-history"></div>
      </div>
    </div>

    <div class="row">
      <div class="card">
        <h2>Metric Panel</h2>
        <div id="metricsPanel" class="small"></div>
      </div>
      <div class="card">
        <h2>NPC Trust</h2>
        <div id="npcCards" class="small"></div>
      </div>
      <div class="card">
        <h2>NPC Behavior Timeline</h2>
        <ul id="npcBehaviorTimeline" class="status-list"></ul>
      </div>
      <div class="card">
        <h2>Map + Rooms</h2>
        <pre id="mapState" class="small"></pre>
      </div>
      <div class="card">
        <h2>Map Layers</h2>
        <div class="filter-controls">
          <label
            >Layer Filter
            <select
              id="layerFilterSelect"
              onchange="updateLayerFilter(this.value)"
            >
              <option value="all">All</option>
              <option value="active">Active</option>
              <option value="hidden">Hidden</option>
              <option value="disabled">Disabled</option>
              <option value="highlight">Highlight</option>
            </select>
          </label>
        </div>
        <ul id="mapLayers" class="status-list"></ul>
      </div>
      <div class="card">
        <h2>Event Markers</h2>
        <div class="filter-controls">
          <label
            >Severity Filter
            <select
              id="markerFilterSelect"
              onchange="updateMarkerFilter(this.value)"
            >
              <option value="all">All</option>
              <option value="info">Info</option>
              <option value="warning">Warning</option>
              <option value="danger">Danger</option>
              <option value="critical">Critical</option>
            </select>
          </label>
        </div>
        <ul id="mapMarkers" class="status-list"></ul>
      </div>
      <div class="card">
        <h2>NPC Roles</h2>
        <ul id="npcRoles" class="status-list"></ul>
      </div>
      <div class="card">
        <h2>Map Function Metrics</h2>
        <div id="mapMetrics" class="small"></div>
      </div>
      <div class="card">
        <h2>Map Activity</h2>
        <p class="small">
          Live diff feed sourced from safe function calls. Recent updates
          animate on the relevant widgets.
        </p>
        <ul
          id="mapActivity"
          class="map-activity"
          aria-live="polite"
          aria-label="Recent map updates"
        ></ul>
      </div>
    </div>

    <div class="row">
      <div class="card">
        <h2>NPC Loyalty & Roles</h2>
        <ul id="npcLoyalty" class="status-list"></ul>
      </div>
      <div class="card">
        <h2>Resource Pressure</h2>
        <ul id="resourcePressure" class="status-list"></ul>
      </div>
      <div class="card">
        <h2>Event Chain Tracker</h2>
        <ul id="eventChain" class="status-list"></ul>
      </div>
    </div>

    <div class="row">
      <div class="card">
        <h2>Inventory</h2>
        <div id="inventorySlots" class="inventory-grid small"></div>
      </div>
      <div class="card">
        <h2>Interaction Targets</h2>
        <div id="interactionTargets" class="small"></div>
      </div>
      <div class="card">
        <h2>Agent System Pulse</h2>
        <ul id="agentPulseFeed" class="status-list agent-pulses"></ul>
        <div id="themeInfo" class="small" style="margin-top: 12px"></div>
      </div>
    </div>

    <div class="row">
      <div class="card">
        <h2>Meta Unlocks</h2>
        <ul id="metaUnlocks" class="status-list"></ul>
      </div>
      <div class="card">
        <h2>Meta Achievements</h2>
        <ul id="metaAchievements" class="status-list"></ul>
      </div>
      <div class="card">
        <h2>Share Card</h2>
        <div id="metaShareCard" class="small"></div>
      </div>
    </div>

    <div class="row">
      <div class="card">
        <h2>Safe Function Schemas</h2>
        <div class="filter-controls">
          <label
            >Function
            <select id="schemaSelect" onchange="renderSchemaViewer()">
              <option value="">Loading...</option>
            </select>
          </label>
          <button class="secondary" onclick="downloadSchema()">
            Download JSON
          </button>
        </div>
        <pre id="schemaViewer" class="small"></pre>
      </div>
    </div>

    <div class="row">
      <div class="card">
        <h2>Guardrail Feed</h2>
        <ul id="guardrailFeed" class="feed"></ul>
      </div>
      <div class="card">
        <h2>Safe Function History</h2>
        <ul id="safeFunctionHistory" class="feed"></ul>
      </div>
      <div class="card">
        <h2>Telemetry</h2>
        <pre id="telemetry" class="small"></pre>
      </div>
    </div>

    <div id="finalOverlay" class="final-overlay hidden" role="dialog" aria-live="polite">
      <div class="final-overlay-content">
        <h2 id="finalTitle">Campaign Complete</h2>
        <p id="finalOutcome" class="small"></p>
        <div id="finalSummaryText" class="small" style="margin-top: 12px"></div>
        <div id="finalUnlocks" class="chip-list" style="margin-top: 12px"></div>
        <div class="final-columns">
          <div style="flex:1 1 45%">
            <h3>Timeline</h3>
            <ul id="finalTimeline" class="status-list"></ul>
          </div>
          <div style="flex:1 1 45%">
            <h3>NPC Spotlight</h3>
            <ul id="finalNPCSpotlight" class="status-list"></ul>
          </div>
        </div>
        <div style="margin-top:12px">
          <h3>Map Effects</h3>
          <ul id="finalMapEffects" class="status-list"></ul>
        </div>
        <button style="margin-top: 20px" onclick="closeFinalOverlay()">Continue</button>
      </div>
    </div>
  </body>
</html>


